var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField = (obj, key2, value2) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
let currentComponent = null;
const setCurrentComponent = (component) => {
  currentComponent = component;
};
const h = (component, props, ...children) => {
  if (typeof component === "function") {
    currentComponent = component.name;
    return component({ ...props, children });
  }
  return {
    type: component.toString(),
    props,
    children: children.flat()
  };
};
const pathToRegex = (path) => {
  return new RegExp("^" + path.replace(/:\w+/g, "(.+)") + "$");
};
const createElement = (node) => {
  if (node === null || node === void 0) {
    return document.createDocumentFragment();
  }
  if (typeof node === "string" || typeof node === "number") {
    return document.createTextNode(String(node));
  }
  const isFragment = node.type === "fragment";
  if (isFragment) {
    return document.createDocumentFragment();
  }
  const element = document.createElement(node.type);
  Object.entries(node.props || {}).forEach(([attr, value2]) => {
    if (attr.startsWith("data-")) {
      element.setAttribute(attr, value2);
    } else {
      if (attr === "onclick") {
        element.onclick = value2;
      } else if (attr === "onchange") {
        element.onchange = value2;
      } else {
        element.setAttribute(attr, value2);
      }
    }
  });
  node.children.forEach((child) => element.appendChild(createElement(child)));
  return element;
};
const diffTextVDOM = (newVDOM, currentVDOM) => {
  if ((typeof newVDOM === "number" || typeof newVDOM === "string") && (typeof currentVDOM === "number" || typeof currentVDOM === "string")) {
    return true;
  }
  return false;
};
const updateElement = (parent2, newVDOM, currentVDOM, index2 = 0) => {
  let removeIndex = 0;
  const hasOnlyCurrentVDOM = (newVDOM === null || newVDOM === void 0) && currentVDOM !== null && currentVDOM !== void 0;
  const hasOnlyNewVDOM = (currentVDOM === null || currentVDOM === void 0) && newVDOM !== null && newVDOM !== void 0;
  if (parent2.childNodes) {
    if (hasOnlyCurrentVDOM) {
      parent2.removeChild(parent2.childNodes[index2]);
      return index2;
    }
  }
  if (hasOnlyNewVDOM) {
    parent2.appendChild(createElement(newVDOM));
    return;
  }
  if (diffTextVDOM(newVDOM, currentVDOM)) {
    if (String(newVDOM) !== String(currentVDOM)) {
      parent2.replaceChild(createElement(newVDOM), parent2.childNodes[index2]);
    }
    return;
  }
  if (!newVDOM || !currentVDOM)
    return;
  if (newVDOM.type !== currentVDOM.type) {
    parent2.replaceChild(createElement(newVDOM), parent2.childNodes[index2]);
    return;
  }
  updateAttributes(
    parent2.childNodes[index2],
    newVDOM.props ?? {},
    currentVDOM.props ?? {}
  );
  const maxLength = Math.max(
    newVDOM.children.length,
    currentVDOM.children.length
  );
  for (let i = 0; i < maxLength; i++) {
    const _removeIndex = updateElement(
      parent2.childNodes[index2],
      newVDOM.children[i],
      currentVDOM.children[i],
      i - removeIndex
    );
    removeIndex += typeof _removeIndex === "number" ? 1 : 0;
  }
};
const updateAttributes = (target, newProps, currentProps) => {
  for (const [attr, value2] of Object.entries(newProps)) {
    if (
      // sameFunction(currentProps[attr], newProps[attr]) ||
      // sameObject(currentProps[attr], newProps[attr]) ||
      currentProps[attr] === newProps[attr]
    )
      continue;
    if (attr === "onclick") {
      target.onclick = value2;
    } else if (attr === "onchange") {
      target.onchange = value2;
    } else {
      target.setAttribute(attr, value2);
    }
  }
  for (const attr of Object.keys(currentProps)) {
    if (newProps[attr] !== void 0)
      continue;
    if (attr === "onclick") {
      target.onclick = null;
    } else if (attr === "onchange") {
      target.onchange = null;
    } else if (attr.startsWith("class")) {
      target.removeAttribute("class");
    } else {
      target.removeAttribute(attr);
    }
  }
};
const shallowEqual = (obj1, obj2) => {
  var _a, _b;
  if (((_a = obj1 == null ? void 0 : obj1.type) == null ? void 0 : _a.toString().startsWith("image/")) && ((_b = obj2 == null ? void 0 : obj2.type) == null ? void 0 : _b.toString().startsWith("image/"))) {
    console.log("image type");
    return false;
  }
  if (Object.is(obj1, obj2)) {
    return true;
  }
  if (obj1 === null || obj2 === null || typeof obj1 !== "object" || typeof obj2 !== "object") {
    return false;
  }
  const keysA = Reflect.ownKeys(obj1);
  const keysB = Reflect.ownKeys(obj2);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(obj2, keysA[i]) || !Object.is(obj1[keysA[i]], obj2[keysA[i]])) {
      return false;
    }
  }
  if (!(obj1 instanceof WebSocket && obj2 instanceof WebSocket) && (obj1 instanceof WebSocket || obj2 instanceof WebSocket)) {
    return false;
  }
  if (obj1 instanceof WebSocket && obj2 instanceof WebSocket) {
    if (obj1.url !== obj2.url || obj1.readyState !== obj2.readyState) {
      return false;
    }
  }
  return true;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lottie$1 = { exports: {} };
(function(module, exports) {
  typeof navigator !== "undefined" && function(global2, factory) {
    module.exports = factory();
  }(commonjsGlobal, function() {
    var svgNS = "http://www.w3.org/2000/svg";
    var locationHref = "";
    var _useWebWorker = false;
    var initialDefaultFrame = -999999;
    var setWebWorker = function setWebWorker2(flag) {
      _useWebWorker = !!flag;
    };
    var getWebWorker = function getWebWorker2() {
      return _useWebWorker;
    };
    var setLocationHref = function setLocationHref2(value2) {
      locationHref = value2;
    };
    var getLocationHref = function getLocationHref2() {
      return locationHref;
    };
    function createTag(type) {
      return document.createElement(type);
    }
    function extendPrototype(sources, destination) {
      var i;
      var len = sources.length;
      var sourcePrototype;
      for (i = 0; i < len; i += 1) {
        sourcePrototype = sources[i].prototype;
        for (var attr in sourcePrototype) {
          if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr))
            destination.prototype[attr] = sourcePrototype[attr];
        }
      }
    }
    function getDescriptor(object, prop) {
      return Object.getOwnPropertyDescriptor(object, prop);
    }
    function createProxyFunction(prototype2) {
      function ProxyFunction() {
      }
      ProxyFunction.prototype = prototype2;
      return ProxyFunction;
    }
    var audioControllerFactory = function() {
      function AudioController(audioFactory) {
        this.audios = [];
        this.audioFactory = audioFactory;
        this._volume = 1;
        this._isMuted = false;
      }
      AudioController.prototype = {
        addAudio: function addAudio(audio) {
          this.audios.push(audio);
        },
        pause: function pause() {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].pause();
          }
        },
        resume: function resume() {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].resume();
          }
        },
        setRate: function setRate(rateValue) {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].setRate(rateValue);
          }
        },
        createAudio: function createAudio(assetPath) {
          if (this.audioFactory) {
            return this.audioFactory(assetPath);
          }
          if (window.Howl) {
            return new window.Howl({
              src: [assetPath]
            });
          }
          return {
            isPlaying: false,
            play: function play() {
              this.isPlaying = true;
            },
            seek: function seek() {
              this.isPlaying = false;
            },
            playing: function playing() {
            },
            rate: function rate() {
            },
            setVolume: function setVolume() {
            }
          };
        },
        setAudioFactory: function setAudioFactory(audioFactory) {
          this.audioFactory = audioFactory;
        },
        setVolume: function setVolume(value2) {
          this._volume = value2;
          this._updateVolume();
        },
        mute: function mute() {
          this._isMuted = true;
          this._updateVolume();
        },
        unmute: function unmute() {
          this._isMuted = false;
          this._updateVolume();
        },
        getVolume: function getVolume() {
          return this._volume;
        },
        _updateVolume: function _updateVolume() {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
          }
        }
      };
      return function() {
        return new AudioController();
      };
    }();
    var createTypedArray = function() {
      function createRegularArray(type, len) {
        var i = 0;
        var arr = [];
        var value2;
        switch (type) {
          case "int16":
          case "uint8c":
            value2 = 1;
            break;
          default:
            value2 = 1.1;
            break;
        }
        for (i = 0; i < len; i += 1) {
          arr.push(value2);
        }
        return arr;
      }
      function createTypedArrayFactory(type, len) {
        if (type === "float32") {
          return new Float32Array(len);
        }
        if (type === "int16") {
          return new Int16Array(len);
        }
        if (type === "uint8c") {
          return new Uint8ClampedArray(len);
        }
        return createRegularArray(type, len);
      }
      if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
        return createTypedArrayFactory;
      }
      return createRegularArray;
    }();
    function createSizedArray(len) {
      return Array.apply(null, {
        length: len
      });
    }
    function _typeof$6(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$6 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$6 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$6(obj);
    }
    var subframeEnabled = true;
    var expressionsPlugin = null;
    var expressionsInterfaces = null;
    var idPrefix$1 = "";
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var bmPow = Math.pow;
    var bmSqrt = Math.sqrt;
    var bmFloor = Math.floor;
    var bmMax = Math.max;
    var bmMin = Math.min;
    var BMMath = {};
    (function() {
      var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
      var i;
      var len = propertyNames.length;
      for (i = 0; i < len; i += 1) {
        BMMath[propertyNames[i]] = Math[propertyNames[i]];
      }
    })();
    BMMath.random = Math.random;
    BMMath.abs = function(val2) {
      var tOfVal = _typeof$6(val2);
      if (tOfVal === "object" && val2.length) {
        var absArr = createSizedArray(val2.length);
        var i;
        var len = val2.length;
        for (i = 0; i < len; i += 1) {
          absArr[i] = Math.abs(val2[i]);
        }
        return absArr;
      }
      return Math.abs(val2);
    };
    var defaultCurveSegments = 150;
    var degToRads = Math.PI / 180;
    var roundCorner = 0.5519;
    function styleDiv(element) {
      element.style.position = "absolute";
      element.style.top = 0;
      element.style.left = 0;
      element.style.display = "block";
      element.style.transformOrigin = "0 0";
      element.style.webkitTransformOrigin = "0 0";
      element.style.backfaceVisibility = "visible";
      element.style.webkitBackfaceVisibility = "visible";
      element.style.transformStyle = "preserve-3d";
      element.style.webkitTransformStyle = "preserve-3d";
      element.style.mozTransformStyle = "preserve-3d";
    }
    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
      this.type = type;
      this.currentTime = currentTime;
      this.totalTime = totalTime;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMCompleteEvent(type, frameMultiplier) {
      this.type = type;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
      this.type = type;
      this.currentLoop = currentLoop;
      this.totalLoops = totalLoops;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMSegmentStartEvent(type, firstFrame, totalFrames) {
      this.type = type;
      this.firstFrame = firstFrame;
      this.totalFrames = totalFrames;
    }
    function BMDestroyEvent(type, target) {
      this.type = type;
      this.target = target;
    }
    function BMRenderFrameErrorEvent(nativeError, currentTime) {
      this.type = "renderFrameError";
      this.nativeError = nativeError;
      this.currentTime = currentTime;
    }
    function BMConfigErrorEvent(nativeError) {
      this.type = "configError";
      this.nativeError = nativeError;
    }
    var createElementID = /* @__PURE__ */ function() {
      var _count = 0;
      return function createID() {
        _count += 1;
        return idPrefix$1 + "__lottie_element_" + _count;
      };
    }();
    function HSVtoRGB(h3, s, v) {
      var r;
      var g;
      var b;
      var i;
      var f;
      var p;
      var q;
      var t;
      i = Math.floor(h3 * 6);
      f = h3 * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return [r, g, b];
    }
    function RGBtoHSV(r, g, b) {
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var d = max - min;
      var h3;
      var s = max === 0 ? 0 : d / max;
      var v = max / 255;
      switch (max) {
        case min:
          h3 = 0;
          break;
        case r:
          h3 = g - b + d * (g < b ? 6 : 0);
          h3 /= 6 * d;
          break;
        case g:
          h3 = b - r + d * 2;
          h3 /= 6 * d;
          break;
        case b:
          h3 = r - g + d * 4;
          h3 /= 6 * d;
          break;
      }
      return [h3, s, v];
    }
    function addSaturationToRGB(color2, offset) {
      var hsv = RGBtoHSV(color2[0] * 255, color2[1] * 255, color2[2] * 255);
      hsv[1] += offset;
      if (hsv[1] > 1) {
        hsv[1] = 1;
      } else if (hsv[1] <= 0) {
        hsv[1] = 0;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    function addBrightnessToRGB(color2, offset) {
      var hsv = RGBtoHSV(color2[0] * 255, color2[1] * 255, color2[2] * 255);
      hsv[2] += offset;
      if (hsv[2] > 1) {
        hsv[2] = 1;
      } else if (hsv[2] < 0) {
        hsv[2] = 0;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    function addHueToRGB(color2, offset) {
      var hsv = RGBtoHSV(color2[0] * 255, color2[1] * 255, color2[2] * 255);
      hsv[0] += offset / 360;
      if (hsv[0] > 1) {
        hsv[0] -= 1;
      } else if (hsv[0] < 0) {
        hsv[0] += 1;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    var rgbToHex = function() {
      var colorMap = [];
      var i;
      var hex2;
      for (i = 0; i < 256; i += 1) {
        hex2 = i.toString(16);
        colorMap[i] = hex2.length === 1 ? "0" + hex2 : hex2;
      }
      return function(r, g, b) {
        if (r < 0) {
          r = 0;
        }
        if (g < 0) {
          g = 0;
        }
        if (b < 0) {
          b = 0;
        }
        return "#" + colorMap[r] + colorMap[g] + colorMap[b];
      };
    }();
    var setSubframeEnabled = function setSubframeEnabled2(flag) {
      subframeEnabled = !!flag;
    };
    var getSubframeEnabled = function getSubframeEnabled2() {
      return subframeEnabled;
    };
    var setExpressionsPlugin = function setExpressionsPlugin2(value2) {
      expressionsPlugin = value2;
    };
    var getExpressionsPlugin = function getExpressionsPlugin2() {
      return expressionsPlugin;
    };
    var setExpressionInterfaces = function setExpressionInterfaces2(value2) {
      expressionsInterfaces = value2;
    };
    var getExpressionInterfaces = function getExpressionInterfaces2() {
      return expressionsInterfaces;
    };
    var setDefaultCurveSegments = function setDefaultCurveSegments2(value2) {
      defaultCurveSegments = value2;
    };
    var getDefaultCurveSegments = function getDefaultCurveSegments2() {
      return defaultCurveSegments;
    };
    var setIdPrefix = function setIdPrefix2(value2) {
      idPrefix$1 = value2;
    };
    function createNS(type) {
      return document.createElementNS(svgNS, type);
    }
    function _typeof$5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$5 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$5 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$5(obj);
    }
    var dataManager = /* @__PURE__ */ function() {
      var _counterId = 1;
      var processes = [];
      var workerFn;
      var workerInstance;
      var workerProxy = {
        onmessage: function onmessage() {
        },
        postMessage: function postMessage(path) {
          workerFn({
            data: path
          });
        }
      };
      var _workerSelf = {
        postMessage: function postMessage(data2) {
          workerProxy.onmessage({
            data: data2
          });
        }
      };
      function createWorker(fn) {
        if (window.Worker && window.Blob && getWebWorker()) {
          var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
            type: "text/javascript"
          });
          var url = URL.createObjectURL(blob);
          return new Worker(url);
        }
        workerFn = fn;
        return workerProxy;
      }
      function setupWorker() {
        if (!workerInstance) {
          workerInstance = createWorker(function workerStart(e) {
            function dataFunctionManager() {
              function completeLayers(layers, comps) {
                var layerData;
                var i;
                var len = layers.length;
                var j;
                var jLen;
                var k;
                var kLen;
                for (i = 0; i < len; i += 1) {
                  layerData = layers[i];
                  if ("ks" in layerData && !layerData.completed) {
                    layerData.completed = true;
                    if (layerData.hasMask) {
                      var maskProps = layerData.masksProperties;
                      jLen = maskProps.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (maskProps[j].pt.k.i) {
                          convertPathsToAbsoluteValues(maskProps[j].pt.k);
                        } else {
                          kLen = maskProps[j].pt.k.length;
                          for (k = 0; k < kLen; k += 1) {
                            if (maskProps[j].pt.k[k].s) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                            }
                            if (maskProps[j].pt.k[k].e) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                            }
                          }
                        }
                      }
                    }
                    if (layerData.ty === 0) {
                      layerData.layers = findCompLayers(layerData.refId, comps);
                      completeLayers(layerData.layers, comps);
                    } else if (layerData.ty === 4) {
                      completeShapes(layerData.shapes);
                    } else if (layerData.ty === 5) {
                      completeText(layerData);
                    }
                  }
                }
              }
              function completeChars(chars, assets) {
                if (chars) {
                  var i = 0;
                  var len = chars.length;
                  for (i = 0; i < len; i += 1) {
                    if (chars[i].t === 1) {
                      chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);
                      completeLayers(chars[i].data.layers, assets);
                    }
                  }
                }
              }
              function findComp(id, comps) {
                var i = 0;
                var len = comps.length;
                while (i < len) {
                  if (comps[i].id === id) {
                    return comps[i];
                  }
                  i += 1;
                }
                return null;
              }
              function findCompLayers(id, comps) {
                var comp2 = findComp(id, comps);
                if (comp2) {
                  if (!comp2.layers.__used) {
                    comp2.layers.__used = true;
                    return comp2.layers;
                  }
                  return JSON.parse(JSON.stringify(comp2.layers));
                }
                return null;
              }
              function completeShapes(arr) {
                var i;
                var len = arr.length;
                var j;
                var jLen;
                for (i = len - 1; i >= 0; i -= 1) {
                  if (arr[i].ty === "sh") {
                    if (arr[i].ks.k.i) {
                      convertPathsToAbsoluteValues(arr[i].ks.k);
                    } else {
                      jLen = arr[i].ks.k.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (arr[i].ks.k[j].s) {
                          convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                        }
                        if (arr[i].ks.k[j].e) {
                          convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                        }
                      }
                    }
                  } else if (arr[i].ty === "gr") {
                    completeShapes(arr[i].it);
                  }
                }
              }
              function convertPathsToAbsoluteValues(path) {
                var i;
                var len = path.i.length;
                for (i = 0; i < len; i += 1) {
                  path.i[i][0] += path.v[i][0];
                  path.i[i][1] += path.v[i][1];
                  path.o[i][0] += path.v[i][0];
                  path.o[i][1] += path.v[i][1];
                }
              }
              function checkVersion(minimum, animVersionString) {
                var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                if (minimum[0] > animVersion[0]) {
                  return true;
                }
                if (animVersion[0] > minimum[0]) {
                  return false;
                }
                if (minimum[1] > animVersion[1]) {
                  return true;
                }
                if (animVersion[1] > minimum[1]) {
                  return false;
                }
                if (minimum[2] > animVersion[2]) {
                  return true;
                }
                if (animVersion[2] > minimum[2]) {
                  return false;
                }
                return null;
              }
              var checkText = /* @__PURE__ */ function() {
                var minimumVersion = [4, 4, 14];
                function updateTextLayer(textLayer) {
                  var documentData = textLayer.t.d;
                  textLayer.t.d = {
                    k: [{
                      s: documentData,
                      t: 0
                    }]
                  };
                }
                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 5) {
                      updateTextLayer(layers[i]);
                    }
                  }
                }
                return function(animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              var checkChars = /* @__PURE__ */ function() {
                var minimumVersion = [4, 7, 99];
                return function(animationData) {
                  if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                    var i;
                    var len = animationData.chars.length;
                    for (i = 0; i < len; i += 1) {
                      var charData = animationData.chars[i];
                      if (charData.data && charData.data.shapes) {
                        completeShapes(charData.data.shapes);
                        charData.data.ip = 0;
                        charData.data.op = 99999;
                        charData.data.st = 0;
                        charData.data.sr = 1;
                        charData.data.ks = {
                          p: {
                            k: [0, 0],
                            a: 0
                          },
                          s: {
                            k: [100, 100],
                            a: 0
                          },
                          a: {
                            k: [0, 0],
                            a: 0
                          },
                          r: {
                            k: 0,
                            a: 0
                          },
                          o: {
                            k: 100,
                            a: 0
                          }
                        };
                        if (!animationData.chars[i].t) {
                          charData.data.shapes.push({
                            ty: "no"
                          });
                          charData.data.shapes[0].it.push({
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            },
                            sk: {
                              k: 0,
                              a: 0
                            },
                            sa: {
                              k: 0,
                              a: 0
                            },
                            ty: "tr"
                          });
                        }
                      }
                    }
                  }
                };
              }();
              var checkPathProperties = /* @__PURE__ */ function() {
                var minimumVersion = [5, 7, 15];
                function updateTextLayer(textLayer) {
                  var pathData = textLayer.t.p;
                  if (typeof pathData.a === "number") {
                    pathData.a = {
                      a: 0,
                      k: pathData.a
                    };
                  }
                  if (typeof pathData.p === "number") {
                    pathData.p = {
                      a: 0,
                      k: pathData.p
                    };
                  }
                  if (typeof pathData.r === "number") {
                    pathData.r = {
                      a: 0,
                      k: pathData.r
                    };
                  }
                }
                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 5) {
                      updateTextLayer(layers[i]);
                    }
                  }
                }
                return function(animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              var checkColors = /* @__PURE__ */ function() {
                var minimumVersion = [4, 1, 9];
                function iterateShapes(shapes) {
                  var i;
                  var len = shapes.length;
                  var j;
                  var jLen;
                  for (i = 0; i < len; i += 1) {
                    if (shapes[i].ty === "gr") {
                      iterateShapes(shapes[i].it);
                    } else if (shapes[i].ty === "fl" || shapes[i].ty === "st") {
                      if (shapes[i].c.k && shapes[i].c.k[0].i) {
                        jLen = shapes[i].c.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (shapes[i].c.k[j].s) {
                            shapes[i].c.k[j].s[0] /= 255;
                            shapes[i].c.k[j].s[1] /= 255;
                            shapes[i].c.k[j].s[2] /= 255;
                            shapes[i].c.k[j].s[3] /= 255;
                          }
                          if (shapes[i].c.k[j].e) {
                            shapes[i].c.k[j].e[0] /= 255;
                            shapes[i].c.k[j].e[1] /= 255;
                            shapes[i].c.k[j].e[2] /= 255;
                            shapes[i].c.k[j].e[3] /= 255;
                          }
                        }
                      } else {
                        shapes[i].c.k[0] /= 255;
                        shapes[i].c.k[1] /= 255;
                        shapes[i].c.k[2] /= 255;
                        shapes[i].c.k[3] /= 255;
                      }
                    }
                  }
                }
                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 4) {
                      iterateShapes(layers[i].shapes);
                    }
                  }
                }
                return function(animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              var checkShapes = /* @__PURE__ */ function() {
                var minimumVersion = [4, 4, 18];
                function completeClosingShapes(arr) {
                  var i;
                  var len = arr.length;
                  var j;
                  var jLen;
                  for (i = len - 1; i >= 0; i -= 1) {
                    if (arr[i].ty === "sh") {
                      if (arr[i].ks.k.i) {
                        arr[i].ks.k.c = arr[i].closed;
                      } else {
                        jLen = arr[i].ks.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (arr[i].ks.k[j].s) {
                            arr[i].ks.k[j].s[0].c = arr[i].closed;
                          }
                          if (arr[i].ks.k[j].e) {
                            arr[i].ks.k[j].e[0].c = arr[i].closed;
                          }
                        }
                      }
                    } else if (arr[i].ty === "gr") {
                      completeClosingShapes(arr[i].it);
                    }
                  }
                }
                function iterateLayers(layers) {
                  var layerData;
                  var i;
                  var len = layers.length;
                  var j;
                  var jLen;
                  var k;
                  var kLen;
                  for (i = 0; i < len; i += 1) {
                    layerData = layers[i];
                    if (layerData.hasMask) {
                      var maskProps = layerData.masksProperties;
                      jLen = maskProps.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (maskProps[j].pt.k.i) {
                          maskProps[j].pt.k.c = maskProps[j].cl;
                        } else {
                          kLen = maskProps[j].pt.k.length;
                          for (k = 0; k < kLen; k += 1) {
                            if (maskProps[j].pt.k[k].s) {
                              maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                            }
                            if (maskProps[j].pt.k[k].e) {
                              maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                            }
                          }
                        }
                      }
                    }
                    if (layerData.ty === 4) {
                      completeClosingShapes(layerData.shapes);
                    }
                  }
                }
                return function(animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              function completeData(animationData) {
                if (animationData.__complete) {
                  return;
                }
                checkColors(animationData);
                checkText(animationData);
                checkChars(animationData);
                checkPathProperties(animationData);
                checkShapes(animationData);
                completeLayers(animationData.layers, animationData.assets);
                completeChars(animationData.chars, animationData.assets);
                animationData.__complete = true;
              }
              function completeText(data2) {
                if (data2.t.a.length === 0 && !("m" in data2.t.p))
                  ;
              }
              var moduleOb = {};
              moduleOb.completeData = completeData;
              moduleOb.checkColors = checkColors;
              moduleOb.checkChars = checkChars;
              moduleOb.checkPathProperties = checkPathProperties;
              moduleOb.checkShapes = checkShapes;
              moduleOb.completeLayers = completeLayers;
              return moduleOb;
            }
            if (!_workerSelf.dataManager) {
              _workerSelf.dataManager = dataFunctionManager();
            }
            if (!_workerSelf.assetLoader) {
              _workerSelf.assetLoader = /* @__PURE__ */ function() {
                function formatResponse(xhr) {
                  var contentTypeHeader = xhr.getResponseHeader("content-type");
                  if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                    return xhr.response;
                  }
                  if (xhr.response && _typeof$5(xhr.response) === "object") {
                    return xhr.response;
                  }
                  if (xhr.response && typeof xhr.response === "string") {
                    return JSON.parse(xhr.response);
                  }
                  if (xhr.responseText) {
                    return JSON.parse(xhr.responseText);
                  }
                  return null;
                }
                function loadAsset(path, fullPath, callback2, errorCallback) {
                  var response;
                  var xhr = new XMLHttpRequest();
                  try {
                    xhr.responseType = "json";
                  } catch (err) {
                  }
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      if (xhr.status === 200) {
                        response = formatResponse(xhr);
                        callback2(response);
                      } else {
                        try {
                          response = formatResponse(xhr);
                          callback2(response);
                        } catch (err) {
                          if (errorCallback) {
                            errorCallback(err);
                          }
                        }
                      }
                    }
                  };
                  try {
                    xhr.open(["G", "E", "T"].join(""), path, true);
                  } catch (error) {
                    xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, true);
                  }
                  xhr.send();
                }
                return {
                  load: loadAsset
                };
              }();
            }
            if (e.data.type === "loadAnimation") {
              _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data2) {
                _workerSelf.dataManager.completeData(data2);
                _workerSelf.postMessage({
                  id: e.data.id,
                  payload: data2,
                  status: "success"
                });
              }, function() {
                _workerSelf.postMessage({
                  id: e.data.id,
                  status: "error"
                });
              });
            } else if (e.data.type === "complete") {
              var animation = e.data.animation;
              _workerSelf.dataManager.completeData(animation);
              _workerSelf.postMessage({
                id: e.data.id,
                payload: animation,
                status: "success"
              });
            } else if (e.data.type === "loadData") {
              _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data2) {
                _workerSelf.postMessage({
                  id: e.data.id,
                  payload: data2,
                  status: "success"
                });
              }, function() {
                _workerSelf.postMessage({
                  id: e.data.id,
                  status: "error"
                });
              });
            }
          });
          workerInstance.onmessage = function(event) {
            var data2 = event.data;
            var id = data2.id;
            var process = processes[id];
            processes[id] = null;
            if (data2.status === "success") {
              process.onComplete(data2.payload);
            } else if (process.onError) {
              process.onError();
            }
          };
        }
      }
      function createProcess(onComplete, onError) {
        _counterId += 1;
        var id = "processId_" + _counterId;
        processes[id] = {
          onComplete,
          onError
        };
        return id;
      }
      function loadAnimation2(path, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: "loadAnimation",
          path,
          fullPath: window.location.origin + window.location.pathname,
          id: processId
        });
      }
      function loadData(path, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: "loadData",
          path,
          fullPath: window.location.origin + window.location.pathname,
          id: processId
        });
      }
      function completeAnimation(anim, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: "complete",
          animation: anim,
          id: processId
        });
      }
      return {
        loadAnimation: loadAnimation2,
        loadData,
        completeAnimation
      };
    }();
    var ImagePreloader = function() {
      var proxyImage = function() {
        var canvas2 = createTag("canvas");
        canvas2.width = 1;
        canvas2.height = 1;
        var ctx2 = canvas2.getContext("2d");
        ctx2.fillStyle = "rgba(0,0,0,0)";
        ctx2.fillRect(0, 0, 1, 1);
        return canvas2;
      }();
      function imageLoaded() {
        this.loadedAssets += 1;
        if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
          if (this.imagesLoadedCb) {
            this.imagesLoadedCb(null);
          }
        }
      }
      function footageLoaded() {
        this.loadedFootagesCount += 1;
        if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
          if (this.imagesLoadedCb) {
            this.imagesLoadedCb(null);
          }
        }
      }
      function getAssetsPath(assetData, assetsPath, originalPath) {
        var path = "";
        if (assetData.e) {
          path = assetData.p;
        } else if (assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf("images/") !== -1) {
            imagePath = imagePath.split("/")[1];
          }
          path = assetsPath + imagePath;
        } else {
          path = originalPath;
          path += assetData.u ? assetData.u : "";
          path += assetData.p;
        }
        return path;
      }
      function testImageLoaded(img) {
        var _count = 0;
        var intervalId = setInterval((function() {
          var box = img.getBBox();
          if (box.width || _count > 500) {
            this._imageLoaded();
            clearInterval(intervalId);
          }
          _count += 1;
        }).bind(this), 50);
      }
      function createImageData(assetData) {
        var path = getAssetsPath(assetData, this.assetsPath, this.path);
        var img = createNS("image");
        if (isSafari) {
          this.testImageLoaded(img);
        } else {
          img.addEventListener("load", this._imageLoaded, false);
        }
        img.addEventListener("error", (function() {
          ob2.img = proxyImage;
          this._imageLoaded();
        }).bind(this), false);
        img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
        if (this._elementHelper.append) {
          this._elementHelper.append(img);
        } else {
          this._elementHelper.appendChild(img);
        }
        var ob2 = {
          img,
          assetData
        };
        return ob2;
      }
      function createImgData(assetData) {
        var path = getAssetsPath(assetData, this.assetsPath, this.path);
        var img = createTag("img");
        img.crossOrigin = "anonymous";
        img.addEventListener("load", this._imageLoaded, false);
        img.addEventListener("error", (function() {
          ob2.img = proxyImage;
          this._imageLoaded();
        }).bind(this), false);
        img.src = path;
        var ob2 = {
          img,
          assetData
        };
        return ob2;
      }
      function createFootageData(data2) {
        var ob2 = {
          assetData: data2
        };
        var path = getAssetsPath(data2, this.assetsPath, this.path);
        dataManager.loadData(path, (function(footageData) {
          ob2.img = footageData;
          this._footageLoaded();
        }).bind(this), (function() {
          ob2.img = {};
          this._footageLoaded();
        }).bind(this));
        return ob2;
      }
      function loadAssets(assets, cb) {
        this.imagesLoadedCb = cb;
        var i;
        var len = assets.length;
        for (i = 0; i < len; i += 1) {
          if (!assets[i].layers) {
            if (!assets[i].t || assets[i].t === "seq") {
              this.totalImages += 1;
              this.images.push(this._createImageData(assets[i]));
            } else if (assets[i].t === 3) {
              this.totalFootages += 1;
              this.images.push(this.createFootageData(assets[i]));
            }
          }
        }
      }
      function setPath(path) {
        this.path = path || "";
      }
      function setAssetsPath(path) {
        this.assetsPath = path || "";
      }
      function getAsset(assetData) {
        var i = 0;
        var len = this.images.length;
        while (i < len) {
          if (this.images[i].assetData === assetData) {
            return this.images[i].img;
          }
          i += 1;
        }
        return null;
      }
      function destroy() {
        this.imagesLoadedCb = null;
        this.images.length = 0;
      }
      function loadedImages() {
        return this.totalImages === this.loadedAssets;
      }
      function loadedFootages() {
        return this.totalFootages === this.loadedFootagesCount;
      }
      function setCacheType(type, elementHelper) {
        if (type === "svg") {
          this._elementHelper = elementHelper;
          this._createImageData = this.createImageData.bind(this);
        } else {
          this._createImageData = this.createImgData.bind(this);
        }
      }
      function ImagePreloaderFactory() {
        this._imageLoaded = imageLoaded.bind(this);
        this._footageLoaded = footageLoaded.bind(this);
        this.testImageLoaded = testImageLoaded.bind(this);
        this.createFootageData = createFootageData.bind(this);
        this.assetsPath = "";
        this.path = "";
        this.totalImages = 0;
        this.totalFootages = 0;
        this.loadedAssets = 0;
        this.loadedFootagesCount = 0;
        this.imagesLoadedCb = null;
        this.images = [];
      }
      ImagePreloaderFactory.prototype = {
        loadAssets,
        setAssetsPath,
        setPath,
        loadedImages,
        loadedFootages,
        destroy,
        getAsset,
        createImgData,
        createImageData,
        imageLoaded,
        footageLoaded,
        setCacheType
      };
      return ImagePreloaderFactory;
    }();
    function BaseEvent() {
    }
    BaseEvent.prototype = {
      triggerEvent: function triggerEvent(eventName, args) {
        if (this._cbs[eventName]) {
          var callbacks = this._cbs[eventName];
          for (var i = 0; i < callbacks.length; i += 1) {
            callbacks[i](args);
          }
        }
      },
      addEventListener: function addEventListener(eventName, callback2) {
        if (!this._cbs[eventName]) {
          this._cbs[eventName] = [];
        }
        this._cbs[eventName].push(callback2);
        return (function() {
          this.removeEventListener(eventName, callback2);
        }).bind(this);
      },
      removeEventListener: function removeEventListener(eventName, callback2) {
        if (!callback2) {
          this._cbs[eventName] = null;
        } else if (this._cbs[eventName]) {
          var i = 0;
          var len = this._cbs[eventName].length;
          while (i < len) {
            if (this._cbs[eventName][i] === callback2) {
              this._cbs[eventName].splice(i, 1);
              i -= 1;
              len -= 1;
            }
            i += 1;
          }
          if (!this._cbs[eventName].length) {
            this._cbs[eventName] = null;
          }
        }
      }
    };
    var markerParser = /* @__PURE__ */ function() {
      function parsePayloadLines(payload) {
        var lines = payload.split("\r\n");
        var keys = {};
        var line;
        var keysCount = 0;
        for (var i = 0; i < lines.length; i += 1) {
          line = lines[i].split(":");
          if (line.length === 2) {
            keys[line[0]] = line[1].trim();
            keysCount += 1;
          }
        }
        if (keysCount === 0) {
          throw new Error();
        }
        return keys;
      }
      return function(_markers) {
        var markers = [];
        for (var i = 0; i < _markers.length; i += 1) {
          var _marker = _markers[i];
          var markerData = {
            time: _marker.tm,
            duration: _marker.dr
          };
          try {
            markerData.payload = JSON.parse(_markers[i].cm);
          } catch (_) {
            try {
              markerData.payload = parsePayloadLines(_markers[i].cm);
            } catch (__) {
              markerData.payload = {
                name: _markers[i].cm
              };
            }
          }
          markers.push(markerData);
        }
        return markers;
      };
    }();
    var ProjectInterface = /* @__PURE__ */ function() {
      function registerComposition(comp2) {
        this.compositions.push(comp2);
      }
      return function() {
        function _thisProjectFunction(name2) {
          var i = 0;
          var len = this.compositions.length;
          while (i < len) {
            if (this.compositions[i].data && this.compositions[i].data.nm === name2) {
              if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                this.compositions[i].prepareFrame(this.currentFrame);
              }
              return this.compositions[i].compInterface;
            }
            i += 1;
          }
          return null;
        }
        _thisProjectFunction.compositions = [];
        _thisProjectFunction.currentFrame = 0;
        _thisProjectFunction.registerComposition = registerComposition;
        return _thisProjectFunction;
      };
    }();
    var renderers = {};
    var registerRenderer = function registerRenderer2(key2, value2) {
      renderers[key2] = value2;
    };
    function getRenderer(key2) {
      return renderers[key2];
    }
    function getRegisteredRenderer() {
      if (renderers.canvas) {
        return "canvas";
      }
      for (var key2 in renderers) {
        if (renderers[key2]) {
          return key2;
        }
      }
      return "";
    }
    function _typeof$4(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$4 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$4 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$4(obj);
    }
    var AnimationItem = function AnimationItem2() {
      this._cbs = [];
      this.name = "";
      this.path = "";
      this.isLoaded = false;
      this.currentFrame = 0;
      this.currentRawFrame = 0;
      this.firstFrame = 0;
      this.totalFrames = 0;
      this.frameRate = 0;
      this.frameMult = 0;
      this.playSpeed = 1;
      this.playDirection = 1;
      this.playCount = 0;
      this.animationData = {};
      this.assets = [];
      this.isPaused = true;
      this.autoplay = false;
      this.loop = true;
      this.renderer = null;
      this.animationID = createElementID();
      this.assetsPath = "";
      this.timeCompleted = 0;
      this.segmentPos = 0;
      this.isSubframeEnabled = getSubframeEnabled();
      this.segments = [];
      this._idle = true;
      this._completedLoop = false;
      this.projectInterface = ProjectInterface();
      this.imagePreloader = new ImagePreloader();
      this.audioController = audioControllerFactory();
      this.markers = [];
      this.configAnimation = this.configAnimation.bind(this);
      this.onSetupError = this.onSetupError.bind(this);
      this.onSegmentComplete = this.onSegmentComplete.bind(this);
      this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
      this.expressionsPlugin = getExpressionsPlugin();
    };
    extendPrototype([BaseEvent], AnimationItem);
    AnimationItem.prototype.setParams = function(params) {
      if (params.wrapper || params.container) {
        this.wrapper = params.wrapper || params.container;
      }
      var animType = "svg";
      if (params.animType) {
        animType = params.animType;
      } else if (params.renderer) {
        animType = params.renderer;
      }
      var RendererClass = getRenderer(animType);
      this.renderer = new RendererClass(this, params.rendererSettings);
      this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
      this.renderer.setProjectInterface(this.projectInterface);
      this.animType = animType;
      if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
        this.loop = true;
      } else if (params.loop === false) {
        this.loop = false;
      } else {
        this.loop = parseInt(params.loop, 10);
      }
      this.autoplay = "autoplay" in params ? params.autoplay : true;
      this.name = params.name ? params.name : "";
      this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
      this.assetsPath = params.assetsPath;
      this.initialSegment = params.initialSegment;
      if (params.audioFactory) {
        this.audioController.setAudioFactory(params.audioFactory);
      }
      if (params.animationData) {
        this.setupAnimation(params.animationData);
      } else if (params.path) {
        if (params.path.lastIndexOf("\\") !== -1) {
          this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
        } else {
          this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
        }
        this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
        this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
        dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
      }
    };
    AnimationItem.prototype.onSetupError = function() {
      this.trigger("data_failed");
    };
    AnimationItem.prototype.setupAnimation = function(data2) {
      dataManager.completeAnimation(data2, this.configAnimation);
    };
    AnimationItem.prototype.setData = function(wrapper, animationData) {
      if (animationData) {
        if (_typeof$4(animationData) !== "object") {
          animationData = JSON.parse(animationData);
        }
      }
      var params = {
        wrapper,
        animationData
      };
      var wrapperAttributes = wrapper.attributes;
      params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
      params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
      var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
      if (loop === "false") {
        params.loop = false;
      } else if (loop === "true") {
        params.loop = true;
      } else if (loop !== "") {
        params.loop = parseInt(loop, 10);
      }
      var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
      params.autoplay = autoplay !== "false";
      params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
      var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
      if (prerender === "false") {
        params.prerender = false;
      }
      if (!params.path) {
        this.trigger("destroy");
      } else {
        this.setParams(params);
      }
    };
    AnimationItem.prototype.includeLayers = function(data2) {
      if (data2.op > this.animationData.op) {
        this.animationData.op = data2.op;
        this.totalFrames = Math.floor(data2.op - this.animationData.ip);
      }
      var layers = this.animationData.layers;
      var i;
      var len = layers.length;
      var newLayers = data2.layers;
      var j;
      var jLen = newLayers.length;
      for (j = 0; j < jLen; j += 1) {
        i = 0;
        while (i < len) {
          if (layers[i].id === newLayers[j].id) {
            layers[i] = newLayers[j];
            break;
          }
          i += 1;
        }
      }
      if (data2.chars || data2.fonts) {
        this.renderer.globalData.fontManager.addChars(data2.chars);
        this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
      }
      if (data2.assets) {
        len = data2.assets.length;
        for (i = 0; i < len; i += 1) {
          this.animationData.assets.push(data2.assets[i]);
        }
      }
      this.animationData.__complete = false;
      dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
    };
    AnimationItem.prototype.onSegmentComplete = function(data2) {
      this.animationData = data2;
      var expressionsPlugin2 = getExpressionsPlugin();
      if (expressionsPlugin2) {
        expressionsPlugin2.initExpressions(this);
      }
      this.loadNextSegment();
    };
    AnimationItem.prototype.loadNextSegment = function() {
      var segments = this.animationData.segments;
      if (!segments || segments.length === 0 || !this.autoloadSegments) {
        this.trigger("data_ready");
        this.timeCompleted = this.totalFrames;
        return;
      }
      var segment = segments.shift();
      this.timeCompleted = segment.time * this.frameRate;
      var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
      this.segmentPos += 1;
      dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {
        this.trigger("data_failed");
      }).bind(this));
    };
    AnimationItem.prototype.loadSegments = function() {
      var segments = this.animationData.segments;
      if (!segments) {
        this.timeCompleted = this.totalFrames;
      }
      this.loadNextSegment();
    };
    AnimationItem.prototype.imagesLoaded = function() {
      this.trigger("loaded_images");
      this.checkLoaded();
    };
    AnimationItem.prototype.preloadImages = function() {
      this.imagePreloader.setAssetsPath(this.assetsPath);
      this.imagePreloader.setPath(this.path);
      this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    };
    AnimationItem.prototype.configAnimation = function(animData) {
      if (!this.renderer) {
        return;
      }
      try {
        this.animationData = animData;
        if (this.initialSegment) {
          this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
          this.firstFrame = Math.round(this.initialSegment[0]);
        } else {
          this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
          this.firstFrame = Math.round(this.animationData.ip);
        }
        this.renderer.configAnimation(animData);
        if (!animData.assets) {
          animData.assets = [];
        }
        this.assets = this.animationData.assets;
        this.frameRate = this.animationData.fr;
        this.frameMult = this.animationData.fr / 1e3;
        this.renderer.searchExtraCompositions(animData.assets);
        this.markers = markerParser(animData.markers || []);
        this.trigger("config_ready");
        this.preloadImages();
        this.loadSegments();
        this.updaFrameModifier();
        this.waitForFontsLoaded();
        if (this.isPaused) {
          this.audioController.pause();
        }
      } catch (error) {
        this.triggerConfigError(error);
      }
    };
    AnimationItem.prototype.waitForFontsLoaded = function() {
      if (!this.renderer) {
        return;
      }
      if (this.renderer.globalData.fontManager.isLoaded) {
        this.checkLoaded();
      } else {
        setTimeout(this.waitForFontsLoaded.bind(this), 20);
      }
    };
    AnimationItem.prototype.checkLoaded = function() {
      if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
        this.isLoaded = true;
        var expressionsPlugin2 = getExpressionsPlugin();
        if (expressionsPlugin2) {
          expressionsPlugin2.initExpressions(this);
        }
        this.renderer.initItems();
        setTimeout((function() {
          this.trigger("DOMLoaded");
        }).bind(this), 0);
        this.gotoFrame();
        if (this.autoplay) {
          this.play();
        }
      }
    };
    AnimationItem.prototype.resize = function(width2, height2) {
      var _width = typeof width2 === "number" ? width2 : void 0;
      var _height = typeof height2 === "number" ? height2 : void 0;
      this.renderer.updateContainerSize(_width, _height);
    };
    AnimationItem.prototype.setSubframe = function(flag) {
      this.isSubframeEnabled = !!flag;
    };
    AnimationItem.prototype.gotoFrame = function() {
      this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
      if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
        this.currentFrame = this.timeCompleted;
      }
      this.trigger("enterFrame");
      this.renderFrame();
      this.trigger("drawnFrame");
    };
    AnimationItem.prototype.renderFrame = function() {
      if (this.isLoaded === false || !this.renderer) {
        return;
      }
      try {
        if (this.expressionsPlugin) {
          this.expressionsPlugin.resetFrame();
        }
        this.renderer.renderFrame(this.currentFrame + this.firstFrame);
      } catch (error) {
        this.triggerRenderFrameError(error);
      }
    };
    AnimationItem.prototype.play = function(name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      if (this.isPaused === true) {
        this.isPaused = false;
        this.trigger("_play");
        this.audioController.resume();
        if (this._idle) {
          this._idle = false;
          this.trigger("_active");
        }
      }
    };
    AnimationItem.prototype.pause = function(name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      if (this.isPaused === false) {
        this.isPaused = true;
        this.trigger("_pause");
        this._idle = true;
        this.trigger("_idle");
        this.audioController.pause();
      }
    };
    AnimationItem.prototype.togglePause = function(name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      if (this.isPaused === true) {
        this.play();
      } else {
        this.pause();
      }
    };
    AnimationItem.prototype.stop = function(name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      this.pause();
      this.playCount = 0;
      this._completedLoop = false;
      this.setCurrentRawFrameValue(0);
    };
    AnimationItem.prototype.getMarkerData = function(markerName) {
      var marker;
      for (var i = 0; i < this.markers.length; i += 1) {
        marker = this.markers[i];
        if (marker.payload && marker.payload.name === markerName) {
          return marker;
        }
      }
      return null;
    };
    AnimationItem.prototype.goToAndStop = function(value2, isFrame, name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      var numValue = Number(value2);
      if (isNaN(numValue)) {
        var marker = this.getMarkerData(value2);
        if (marker) {
          this.goToAndStop(marker.time, true);
        }
      } else if (isFrame) {
        this.setCurrentRawFrameValue(value2);
      } else {
        this.setCurrentRawFrameValue(value2 * this.frameModifier);
      }
      this.pause();
    };
    AnimationItem.prototype.goToAndPlay = function(value2, isFrame, name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      var numValue = Number(value2);
      if (isNaN(numValue)) {
        var marker = this.getMarkerData(value2);
        if (marker) {
          if (!marker.duration) {
            this.goToAndStop(marker.time, true);
          } else {
            this.playSegments([marker.time, marker.time + marker.duration], true);
          }
        }
      } else {
        this.goToAndStop(numValue, isFrame, name2);
      }
      this.play();
    };
    AnimationItem.prototype.advanceTime = function(value2) {
      if (this.isPaused === true || this.isLoaded === false) {
        return;
      }
      var nextValue = this.currentRawFrame + value2 * this.frameModifier;
      var _isComplete = false;
      if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
        if (!this.loop || this.playCount === this.loop) {
          if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
            _isComplete = true;
            nextValue = this.totalFrames - 1;
          }
        } else if (nextValue >= this.totalFrames) {
          this.playCount += 1;
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            this.setCurrentRawFrameValue(nextValue % this.totalFrames);
            this._completedLoop = true;
            this.trigger("loopComplete");
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
      } else if (nextValue < 0) {
        if (!this.checkSegments(nextValue % this.totalFrames)) {
          if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
            this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
            if (!this._completedLoop) {
              this._completedLoop = true;
            } else {
              this.trigger("loopComplete");
            }
          } else {
            _isComplete = true;
            nextValue = 0;
          }
        }
      } else {
        this.setCurrentRawFrameValue(nextValue);
      }
      if (_isComplete) {
        this.setCurrentRawFrameValue(nextValue);
        this.pause();
        this.trigger("complete");
      }
    };
    AnimationItem.prototype.adjustSegment = function(arr, offset) {
      this.playCount = 0;
      if (arr[1] < arr[0]) {
        if (this.frameModifier > 0) {
          if (this.playSpeed < 0) {
            this.setSpeed(-this.playSpeed);
          } else {
            this.setDirection(-1);
          }
        }
        this.totalFrames = arr[0] - arr[1];
        this.timeCompleted = this.totalFrames;
        this.firstFrame = arr[1];
        this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
      } else if (arr[1] > arr[0]) {
        if (this.frameModifier < 0) {
          if (this.playSpeed < 0) {
            this.setSpeed(-this.playSpeed);
          } else {
            this.setDirection(1);
          }
        }
        this.totalFrames = arr[1] - arr[0];
        this.timeCompleted = this.totalFrames;
        this.firstFrame = arr[0];
        this.setCurrentRawFrameValue(1e-3 + offset);
      }
      this.trigger("segmentStart");
    };
    AnimationItem.prototype.setSegment = function(init, end) {
      var pendingFrame = -1;
      if (this.isPaused) {
        if (this.currentRawFrame + this.firstFrame < init) {
          pendingFrame = init;
        } else if (this.currentRawFrame + this.firstFrame > end) {
          pendingFrame = end - init;
        }
      }
      this.firstFrame = init;
      this.totalFrames = end - init;
      this.timeCompleted = this.totalFrames;
      if (pendingFrame !== -1) {
        this.goToAndStop(pendingFrame, true);
      }
    };
    AnimationItem.prototype.playSegments = function(arr, forceFlag) {
      if (forceFlag) {
        this.segments.length = 0;
      }
      if (_typeof$4(arr[0]) === "object") {
        var i;
        var len = arr.length;
        for (i = 0; i < len; i += 1) {
          this.segments.push(arr[i]);
        }
      } else {
        this.segments.push(arr);
      }
      if (this.segments.length && forceFlag) {
        this.adjustSegment(this.segments.shift(), 0);
      }
      if (this.isPaused) {
        this.play();
      }
    };
    AnimationItem.prototype.resetSegments = function(forceFlag) {
      this.segments.length = 0;
      this.segments.push([this.animationData.ip, this.animationData.op]);
      if (forceFlag) {
        this.checkSegments(0);
      }
    };
    AnimationItem.prototype.checkSegments = function(offset) {
      if (this.segments.length) {
        this.adjustSegment(this.segments.shift(), offset);
        return true;
      }
      return false;
    };
    AnimationItem.prototype.destroy = function(name2) {
      if (name2 && this.name !== name2 || !this.renderer) {
        return;
      }
      this.renderer.destroy();
      this.imagePreloader.destroy();
      this.trigger("destroy");
      this._cbs = null;
      this.onEnterFrame = null;
      this.onLoopComplete = null;
      this.onComplete = null;
      this.onSegmentStart = null;
      this.onDestroy = null;
      this.renderer = null;
      this.expressionsPlugin = null;
      this.imagePreloader = null;
      this.projectInterface = null;
    };
    AnimationItem.prototype.setCurrentRawFrameValue = function(value2) {
      this.currentRawFrame = value2;
      this.gotoFrame();
    };
    AnimationItem.prototype.setSpeed = function(val2) {
      this.playSpeed = val2;
      this.updaFrameModifier();
    };
    AnimationItem.prototype.setDirection = function(val2) {
      this.playDirection = val2 < 0 ? -1 : 1;
      this.updaFrameModifier();
    };
    AnimationItem.prototype.setLoop = function(isLooping) {
      this.loop = isLooping;
    };
    AnimationItem.prototype.setVolume = function(val2, name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      this.audioController.setVolume(val2);
    };
    AnimationItem.prototype.getVolume = function() {
      return this.audioController.getVolume();
    };
    AnimationItem.prototype.mute = function(name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      this.audioController.mute();
    };
    AnimationItem.prototype.unmute = function(name2) {
      if (name2 && this.name !== name2) {
        return;
      }
      this.audioController.unmute();
    };
    AnimationItem.prototype.updaFrameModifier = function() {
      this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
      this.audioController.setRate(this.playSpeed * this.playDirection);
    };
    AnimationItem.prototype.getPath = function() {
      return this.path;
    };
    AnimationItem.prototype.getAssetsPath = function(assetData) {
      var path = "";
      if (assetData.e) {
        path = assetData.p;
      } else if (this.assetsPath) {
        var imagePath = assetData.p;
        if (imagePath.indexOf("images/") !== -1) {
          imagePath = imagePath.split("/")[1];
        }
        path = this.assetsPath + imagePath;
      } else {
        path = this.path;
        path += assetData.u ? assetData.u : "";
        path += assetData.p;
      }
      return path;
    };
    AnimationItem.prototype.getAssetData = function(id) {
      var i = 0;
      var len = this.assets.length;
      while (i < len) {
        if (id === this.assets[i].id) {
          return this.assets[i];
        }
        i += 1;
      }
      return null;
    };
    AnimationItem.prototype.hide = function() {
      this.renderer.hide();
    };
    AnimationItem.prototype.show = function() {
      this.renderer.show();
    };
    AnimationItem.prototype.getDuration = function(isFrame) {
      return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
    };
    AnimationItem.prototype.updateDocumentData = function(path, documentData, index2) {
      try {
        var element = this.renderer.getElementByPath(path);
        element.updateDocumentData(documentData, index2);
      } catch (error) {
      }
    };
    AnimationItem.prototype.trigger = function(name2) {
      if (this._cbs && this._cbs[name2]) {
        switch (name2) {
          case "enterFrame":
            this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
            break;
          case "drawnFrame":
            this.drawnFrameEvent.currentTime = this.currentFrame;
            this.drawnFrameEvent.totalTime = this.totalFrames;
            this.drawnFrameEvent.direction = this.frameModifier;
            this.triggerEvent(name2, this.drawnFrameEvent);
            break;
          case "loopComplete":
            this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
            break;
          case "complete":
            this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
            break;
          case "segmentStart":
            this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
            break;
          case "destroy":
            this.triggerEvent(name2, new BMDestroyEvent(name2, this));
            break;
          default:
            this.triggerEvent(name2);
        }
      }
      if (name2 === "enterFrame" && this.onEnterFrame) {
        this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
      }
      if (name2 === "loopComplete" && this.onLoopComplete) {
        this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
      }
      if (name2 === "complete" && this.onComplete) {
        this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
      }
      if (name2 === "segmentStart" && this.onSegmentStart) {
        this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
      }
      if (name2 === "destroy" && this.onDestroy) {
        this.onDestroy.call(this, new BMDestroyEvent(name2, this));
      }
    };
    AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
      var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
      this.triggerEvent("error", error);
      if (this.onError) {
        this.onError.call(this, error);
      }
    };
    AnimationItem.prototype.triggerConfigError = function(nativeError) {
      var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
      this.triggerEvent("error", error);
      if (this.onError) {
        this.onError.call(this, error);
      }
    };
    var animationManager = function() {
      var moduleOb = {};
      var registeredAnimations = [];
      var initTime = 0;
      var len = 0;
      var playingAnimationsNum = 0;
      var _stopped = true;
      var _isFrozen = false;
      function removeElement(ev) {
        var i = 0;
        var animItem = ev.target;
        while (i < len) {
          if (registeredAnimations[i].animation === animItem) {
            registeredAnimations.splice(i, 1);
            i -= 1;
            len -= 1;
            if (!animItem.isPaused) {
              subtractPlayingCount();
            }
          }
          i += 1;
        }
      }
      function registerAnimation(element, animationData) {
        if (!element) {
          return null;
        }
        var i = 0;
        while (i < len) {
          if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
            return registeredAnimations[i].animation;
          }
          i += 1;
        }
        var animItem = new AnimationItem();
        setupAnimation(animItem, element);
        animItem.setData(element, animationData);
        return animItem;
      }
      function getRegisteredAnimations() {
        var i;
        var lenAnims = registeredAnimations.length;
        var animations = [];
        for (i = 0; i < lenAnims; i += 1) {
          animations.push(registeredAnimations[i].animation);
        }
        return animations;
      }
      function addPlayingCount() {
        playingAnimationsNum += 1;
        activate();
      }
      function subtractPlayingCount() {
        playingAnimationsNum -= 1;
      }
      function setupAnimation(animItem, element) {
        animItem.addEventListener("destroy", removeElement);
        animItem.addEventListener("_active", addPlayingCount);
        animItem.addEventListener("_idle", subtractPlayingCount);
        registeredAnimations.push({
          elem: element,
          animation: animItem
        });
        len += 1;
      }
      function loadAnimation2(params) {
        var animItem = new AnimationItem();
        setupAnimation(animItem, null);
        animItem.setParams(params);
        return animItem;
      }
      function setSpeed(val2, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setSpeed(val2, animation);
        }
      }
      function setDirection(val2, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setDirection(val2, animation);
        }
      }
      function play(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.play(animation);
        }
      }
      function resume(nowTime) {
        var elapsedTime = nowTime - initTime;
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.advanceTime(elapsedTime);
        }
        initTime = nowTime;
        if (playingAnimationsNum && !_isFrozen) {
          window.requestAnimationFrame(resume);
        } else {
          _stopped = true;
        }
      }
      function first(nowTime) {
        initTime = nowTime;
        window.requestAnimationFrame(resume);
      }
      function pause(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.pause(animation);
        }
      }
      function goToAndStop(value2, isFrame, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.goToAndStop(value2, isFrame, animation);
        }
      }
      function stop(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.stop(animation);
        }
      }
      function togglePause(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.togglePause(animation);
        }
      }
      function destroy(animation) {
        var i;
        for (i = len - 1; i >= 0; i -= 1) {
          registeredAnimations[i].animation.destroy(animation);
        }
      }
      function searchAnimations2(animationData, standalone, renderer) {
        var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
        var i;
        var lenAnims = animElements.length;
        for (i = 0; i < lenAnims; i += 1) {
          if (renderer) {
            animElements[i].setAttribute("data-bm-type", renderer);
          }
          registerAnimation(animElements[i], animationData);
        }
        if (standalone && lenAnims === 0) {
          if (!renderer) {
            renderer = "svg";
          }
          var body = document.getElementsByTagName("body")[0];
          body.innerText = "";
          var div2 = createTag("div");
          div2.style.width = "100%";
          div2.style.height = "100%";
          div2.setAttribute("data-bm-type", renderer);
          body.appendChild(div2);
          registerAnimation(div2, animationData);
        }
      }
      function resize() {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.resize();
        }
      }
      function activate() {
        if (!_isFrozen && playingAnimationsNum) {
          if (_stopped) {
            window.requestAnimationFrame(first);
            _stopped = false;
          }
        }
      }
      function freeze() {
        _isFrozen = true;
      }
      function unfreeze() {
        _isFrozen = false;
        activate();
      }
      function setVolume(val2, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setVolume(val2, animation);
        }
      }
      function mute(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.mute(animation);
        }
      }
      function unmute(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.unmute(animation);
        }
      }
      moduleOb.registerAnimation = registerAnimation;
      moduleOb.loadAnimation = loadAnimation2;
      moduleOb.setSpeed = setSpeed;
      moduleOb.setDirection = setDirection;
      moduleOb.play = play;
      moduleOb.pause = pause;
      moduleOb.stop = stop;
      moduleOb.togglePause = togglePause;
      moduleOb.searchAnimations = searchAnimations2;
      moduleOb.resize = resize;
      moduleOb.goToAndStop = goToAndStop;
      moduleOb.destroy = destroy;
      moduleOb.freeze = freeze;
      moduleOb.unfreeze = unfreeze;
      moduleOb.setVolume = setVolume;
      moduleOb.mute = mute;
      moduleOb.unmute = unmute;
      moduleOb.getRegisteredAnimations = getRegisteredAnimations;
      return moduleOb;
    }();
    var BezierFactory = function() {
      var ob2 = {};
      ob2.getBezierEasing = getBezierEasing;
      var beziers = {};
      function getBezierEasing(a, b, c, d, nm) {
        var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
        if (beziers[str]) {
          return beziers[str];
        }
        var bezEasing = new BezierEasing([a, b, c, d]);
        beziers[str] = bezEasing;
        return bezEasing;
      }
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 1e-3;
      var SUBDIVISION_PRECISION = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      var float32ArraySupported = typeof Float32Array === "function";
      function A(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0)
            return aGuessT;
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function BezierEasing(points) {
        this._p = points;
        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        this._precomputed = false;
        this.get = this.get.bind(this);
      }
      BezierEasing.prototype = {
        get: function get(x) {
          var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
          if (!this._precomputed)
            this._precompute();
          if (mX1 === mY1 && mX2 === mY2)
            return x;
          if (x === 0)
            return 0;
          if (x === 1)
            return 1;
          return calcBezier(this._getTForX(x), mY1, mY2);
        },
        // Private part
        _precompute: function _precompute() {
          var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
          this._precomputed = true;
          if (mX1 !== mY1 || mX2 !== mY2) {
            this._calcSampleValues();
          }
        },
        _calcSampleValues: function _calcSampleValues() {
          var mX1 = this._p[0], mX2 = this._p[2];
          for (var i = 0; i < kSplineTableSize; ++i) {
            this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
          }
        },
        /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
        _getTForX: function _getTForX(aX) {
          var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          }
          if (initialSlope === 0) {
            return guessForT;
          }
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      };
      return ob2;
    }();
    var pooling = /* @__PURE__ */ function() {
      function _double(arr) {
        return arr.concat(createSizedArray(arr.length));
      }
      return {
        "double": _double
      };
    }();
    var poolFactory = /* @__PURE__ */ function() {
      return function(initialLength, _create, _release) {
        var _length = 0;
        var _maxLength = initialLength;
        var pool = createSizedArray(_maxLength);
        var ob2 = {
          newElement,
          release
        };
        function newElement() {
          var element;
          if (_length) {
            _length -= 1;
            element = pool[_length];
          } else {
            element = _create();
          }
          return element;
        }
        function release(element) {
          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }
          if (_release) {
            _release(element);
          }
          pool[_length] = element;
          _length += 1;
        }
        return ob2;
      };
    }();
    var bezierLengthPool = function() {
      function create() {
        return {
          addedLength: 0,
          percents: createTypedArray("float32", getDefaultCurveSegments()),
          lengths: createTypedArray("float32", getDefaultCurveSegments())
        };
      }
      return poolFactory(8, create);
    }();
    var segmentsLengthPool = function() {
      function create() {
        return {
          lengths: [],
          totalLength: 0
        };
      }
      function release(element) {
        var i;
        var len = element.lengths.length;
        for (i = 0; i < len; i += 1) {
          bezierLengthPool.release(element.lengths[i]);
        }
        element.lengths.length = 0;
      }
      return poolFactory(8, create, release);
    }();
    function bezFunction() {
      var math = Math;
      function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
        var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
        return det1 > -1e-3 && det1 < 1e-3;
      }
      function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
        if (z1 === 0 && z2 === 0 && z3 === 0) {
          return pointOnLine2D(x1, y1, x2, y2, x3, y3);
        }
        var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
        var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
        var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
        var diffDist;
        if (dist1 > dist2) {
          if (dist1 > dist3) {
            diffDist = dist1 - dist2 - dist3;
          } else {
            diffDist = dist3 - dist2 - dist1;
          }
        } else if (dist3 > dist2) {
          diffDist = dist3 - dist2 - dist1;
        } else {
          diffDist = dist2 - dist1 - dist3;
        }
        return diffDist > -1e-4 && diffDist < 1e-4;
      }
      var getBezierLength = /* @__PURE__ */ function() {
        return function(pt1, pt2, pt3, pt4) {
          var curveSegments = getDefaultCurveSegments();
          var k;
          var i;
          var len;
          var ptCoord;
          var perc;
          var addedLength = 0;
          var ptDistance;
          var point = [];
          var lastPoint = [];
          var lengthData = bezierLengthPool.newElement();
          len = pt3.length;
          for (k = 0; k < curveSegments; k += 1) {
            perc = k / (curveSegments - 1);
            ptDistance = 0;
            for (i = 0; i < len; i += 1) {
              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
              point[i] = ptCoord;
              if (lastPoint[i] !== null) {
                ptDistance += bmPow(point[i] - lastPoint[i], 2);
              }
              lastPoint[i] = point[i];
            }
            if (ptDistance) {
              ptDistance = bmSqrt(ptDistance);
              addedLength += ptDistance;
            }
            lengthData.percents[k] = perc;
            lengthData.lengths[k] = addedLength;
          }
          lengthData.addedLength = addedLength;
          return lengthData;
        };
      }();
      function getSegmentsLength(shapeData) {
        var segmentsLength = segmentsLengthPool.newElement();
        var closed = shapeData.c;
        var pathV = shapeData.v;
        var pathO = shapeData.o;
        var pathI = shapeData.i;
        var i;
        var len = shapeData._length;
        var lengths = segmentsLength.lengths;
        var totalLength = 0;
        for (i = 0; i < len - 1; i += 1) {
          lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
          totalLength += lengths[i].addedLength;
        }
        if (closed && len) {
          lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
          totalLength += lengths[i].addedLength;
        }
        segmentsLength.totalLength = totalLength;
        return segmentsLength;
      }
      function BezierData(length2) {
        this.segmentLength = 0;
        this.points = new Array(length2);
      }
      function PointData(partial, point) {
        this.partialLength = partial;
        this.point = point;
      }
      var buildBezierData = /* @__PURE__ */ function() {
        var storedData = {};
        return function(pt1, pt2, pt3, pt4) {
          var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
          if (!storedData[bezierName]) {
            var curveSegments = getDefaultCurveSegments();
            var k;
            var i;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point;
            var lastPoint = null;
            if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
              curveSegments = 2;
            }
            var bezierData = new BezierData(curveSegments);
            len = pt3.length;
            for (k = 0; k < curveSegments; k += 1) {
              point = createSizedArray(len);
              perc = k / (curveSegments - 1);
              ptDistance = 0;
              for (i = 0; i < len; i += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                point[i] = ptCoord;
                if (lastPoint !== null) {
                  ptDistance += bmPow(point[i] - lastPoint[i], 2);
                }
              }
              ptDistance = bmSqrt(ptDistance);
              addedLength += ptDistance;
              bezierData.points[k] = new PointData(ptDistance, point);
              lastPoint = point;
            }
            bezierData.segmentLength = addedLength;
            storedData[bezierName] = bezierData;
          }
          return storedData[bezierName];
        };
      }();
      function getDistancePerc(perc, bezierData) {
        var percents = bezierData.percents;
        var lengths = bezierData.lengths;
        var len = percents.length;
        var initPos = bmFloor((len - 1) * perc);
        var lengthPos = perc * bezierData.addedLength;
        var lPerc = 0;
        if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
          return percents[initPos];
        }
        var dir = lengths[initPos] > lengthPos ? -1 : 1;
        var flag = true;
        while (flag) {
          if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
            lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
            flag = false;
          } else {
            initPos += dir;
          }
          if (initPos < 0 || initPos >= len - 1) {
            if (initPos === len - 1) {
              return percents[initPos];
            }
            flag = false;
          }
        }
        return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
      }
      function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
        var t1 = getDistancePerc(percent, bezierData);
        var u1 = 1 - t1;
        var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
        var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
        return [ptX, ptY];
      }
      var bezierSegmentPoints = createTypedArray("float32", 8);
      function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
        if (startPerc < 0) {
          startPerc = 0;
        } else if (startPerc > 1) {
          startPerc = 1;
        }
        var t0 = getDistancePerc(startPerc, bezierData);
        endPerc = endPerc > 1 ? 1 : endPerc;
        var t1 = getDistancePerc(endPerc, bezierData);
        var i;
        var len = pt1.length;
        var u0 = 1 - t0;
        var u1 = 1 - t1;
        var u0u0u0 = u0 * u0 * u0;
        var t0u0u0_3 = t0 * u0 * u0 * 3;
        var t0t0u0_3 = t0 * t0 * u0 * 3;
        var t0t0t0 = t0 * t0 * t0;
        var u0u0u1 = u0 * u0 * u1;
        var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
        var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
        var t0t0t1 = t0 * t0 * t1;
        var u0u1u1 = u0 * u1 * u1;
        var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
        var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
        var t0t1t1 = t0 * t1 * t1;
        var u1u1u1 = u1 * u1 * u1;
        var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
        var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
        var t1t1t1 = t1 * t1 * t1;
        for (i = 0; i < len; i += 1) {
          bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1e3) / 1e3;
          bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1e3) / 1e3;
          bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1e3) / 1e3;
          bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1e3) / 1e3;
        }
        return bezierSegmentPoints;
      }
      return {
        getSegmentsLength,
        getNewSegment,
        getPointInSegment,
        buildBezierData,
        pointOnLine2D,
        pointOnLine3D
      };
    }
    var bez = bezFunction();
    var initFrame = initialDefaultFrame;
    var mathAbs = Math.abs;
    function interpolateValue(frameNum, caching) {
      var offsetTime = this.offsetTime;
      var newValue;
      if (this.propType === "multidimensional") {
        newValue = createTypedArray("float32", this.pv.length);
      }
      var iterationIndex = caching.lastIndex;
      var i = iterationIndex;
      var len = this.keyframes.length - 1;
      var flag = true;
      var keyData;
      var nextKeyData;
      var keyframeMetadata;
      while (flag) {
        keyData = this.keyframes[i];
        nextKeyData = this.keyframes[i + 1];
        if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
          if (keyData.h) {
            keyData = nextKeyData;
          }
          iterationIndex = 0;
          break;
        }
        if (nextKeyData.t - offsetTime > frameNum) {
          iterationIndex = i;
          break;
        }
        if (i < len - 1) {
          i += 1;
        } else {
          iterationIndex = 0;
          flag = false;
        }
      }
      keyframeMetadata = this.keyframesMetadata[i] || {};
      var k;
      var kLen;
      var perc;
      var jLen;
      var j;
      var fnc;
      var nextKeyTime = nextKeyData.t - offsetTime;
      var keyTime = keyData.t - offsetTime;
      var endValue;
      if (keyData.to) {
        if (!keyframeMetadata.bezierData) {
          keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
        }
        var bezierData = keyframeMetadata.bezierData;
        if (frameNum >= nextKeyTime || frameNum < keyTime) {
          var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
          kLen = bezierData.points[ind].point.length;
          for (k = 0; k < kLen; k += 1) {
            newValue[k] = bezierData.points[ind].point[k];
          }
        } else {
          if (keyframeMetadata.__fnct) {
            fnc = keyframeMetadata.__fnct;
          } else {
            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
            keyframeMetadata.__fnct = fnc;
          }
          perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
          var distanceInLine = bezierData.segmentLength * perc;
          var segmentPerc;
          var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
          j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
          flag = true;
          jLen = bezierData.points.length;
          while (flag) {
            addedLength += bezierData.points[j].partialLength;
            if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
              kLen = bezierData.points[j].point.length;
              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[j].point[k];
              }
              break;
            } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
              segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
              kLen = bezierData.points[j].point.length;
              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
              }
              break;
            }
            if (j < jLen - 1) {
              j += 1;
            } else {
              flag = false;
            }
          }
          caching._lastPoint = j;
          caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
          caching._lastKeyframeIndex = i;
        }
      } else {
        var outX;
        var outY;
        var inX;
        var inY;
        var keyValue;
        len = keyData.s.length;
        endValue = nextKeyData.s || keyData.e;
        if (this.sh && keyData.h !== 1) {
          if (frameNum >= nextKeyTime) {
            newValue[0] = endValue[0];
            newValue[1] = endValue[1];
            newValue[2] = endValue[2];
          } else if (frameNum <= keyTime) {
            newValue[0] = keyData.s[0];
            newValue[1] = keyData.s[1];
            newValue[2] = keyData.s[2];
          } else {
            var quatStart = createQuaternion(keyData.s);
            var quatEnd = createQuaternion(endValue);
            var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
            quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
          }
        } else {
          for (i = 0; i < len; i += 1) {
            if (keyData.h !== 1) {
              if (frameNum >= nextKeyTime) {
                perc = 1;
              } else if (frameNum < keyTime) {
                perc = 0;
              } else {
                if (keyData.o.x.constructor === Array) {
                  if (!keyframeMetadata.__fnct) {
                    keyframeMetadata.__fnct = [];
                  }
                  if (!keyframeMetadata.__fnct[i]) {
                    outX = keyData.o.x[i] === void 0 ? keyData.o.x[0] : keyData.o.x[i];
                    outY = keyData.o.y[i] === void 0 ? keyData.o.y[0] : keyData.o.y[i];
                    inX = keyData.i.x[i] === void 0 ? keyData.i.x[0] : keyData.i.x[i];
                    inY = keyData.i.y[i] === void 0 ? keyData.i.y[0] : keyData.i.y[i];
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyframeMetadata.__fnct[i] = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct[i];
                  }
                } else if (!keyframeMetadata.__fnct) {
                  outX = keyData.o.x;
                  outY = keyData.o.y;
                  inX = keyData.i.x;
                  inY = keyData.i.y;
                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                  keyData.keyframeMetadata = fnc;
                } else {
                  fnc = keyframeMetadata.__fnct;
                }
                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
              }
            }
            endValue = nextKeyData.s || keyData.e;
            keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
            if (this.propType === "multidimensional") {
              newValue[i] = keyValue;
            } else {
              newValue = keyValue;
            }
          }
        }
      }
      caching.lastIndex = iterationIndex;
      return newValue;
    }
    function slerp(a, b, t) {
      var out = [];
      var ax = a[0];
      var ay = a[1];
      var az = a[2];
      var aw = a[3];
      var bx = b[0];
      var by = b[1];
      var bz = b[2];
      var bw = b[3];
      var omega;
      var cosom;
      var sinom;
      var scale0;
      var scale1;
      cosom = ax * bx + ay * by + az * bz + aw * bw;
      if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      if (1 - cosom > 1e-6) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        scale0 = 1 - t;
        scale1 = t;
      }
      out[0] = scale0 * ax + scale1 * bx;
      out[1] = scale0 * ay + scale1 * by;
      out[2] = scale0 * az + scale1 * bz;
      out[3] = scale0 * aw + scale1 * bw;
      return out;
    }
    function quaternionToEuler(out, quat) {
      var qx = quat[0];
      var qy = quat[1];
      var qz = quat[2];
      var qw = quat[3];
      var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
      var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
      var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
      out[0] = heading / degToRads;
      out[1] = attitude / degToRads;
      out[2] = bank / degToRads;
    }
    function createQuaternion(values) {
      var heading = values[0] * degToRads;
      var attitude = values[1] * degToRads;
      var bank = values[2] * degToRads;
      var c1 = Math.cos(heading / 2);
      var c2 = Math.cos(attitude / 2);
      var c3 = Math.cos(bank / 2);
      var s1 = Math.sin(heading / 2);
      var s2 = Math.sin(attitude / 2);
      var s3 = Math.sin(bank / 2);
      var w = c1 * c2 * c3 - s1 * s2 * s3;
      var x = s1 * s2 * c3 + c1 * c2 * s3;
      var y = s1 * c2 * c3 + c1 * s2 * s3;
      var z = c1 * s2 * c3 - s1 * c2 * s3;
      return [x, y, z, w];
    }
    function getValueAtCurrentTime() {
      var frameNum = this.comp.renderedFrame - this.offsetTime;
      var initTime = this.keyframes[0].t - this.offsetTime;
      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
      if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
        if (this._caching.lastFrame >= frameNum) {
          this._caching._lastKeyframeIndex = -1;
          this._caching.lastIndex = 0;
        }
        var renderResult = this.interpolateValue(frameNum, this._caching);
        this.pv = renderResult;
      }
      this._caching.lastFrame = frameNum;
      return this.pv;
    }
    function setVValue(val2) {
      var multipliedValue;
      if (this.propType === "unidimensional") {
        multipliedValue = val2 * this.mult;
        if (mathAbs(this.v - multipliedValue) > 1e-5) {
          this.v = multipliedValue;
          this._mdf = true;
        }
      } else {
        var i = 0;
        var len = this.v.length;
        while (i < len) {
          multipliedValue = val2[i] * this.mult;
          if (mathAbs(this.v[i] - multipliedValue) > 1e-5) {
            this.v[i] = multipliedValue;
            this._mdf = true;
          }
          i += 1;
        }
      }
    }
    function processEffectsSequence() {
      if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
        return;
      }
      if (this.lock) {
        this.setVValue(this.pv);
        return;
      }
      this.lock = true;
      this._mdf = this._isFirstFrame;
      var i;
      var len = this.effectsSequence.length;
      var finalValue = this.kf ? this.pv : this.data.k;
      for (i = 0; i < len; i += 1) {
        finalValue = this.effectsSequence[i](finalValue);
      }
      this.setVValue(finalValue);
      this._isFirstFrame = false;
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    }
    function addEffect(effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.container.addDynamicProperty(this);
    }
    function ValueProperty(elem2, data2, mult, container) {
      this.propType = "unidimensional";
      this.mult = mult || 1;
      this.data = data2;
      this.v = mult ? data2.k * mult : data2.k;
      this.pv = data2.k;
      this._mdf = false;
      this.elem = elem2;
      this.container = container;
      this.comp = elem2.comp;
      this.k = false;
      this.kf = false;
      this.vel = 0;
      this.effectsSequence = [];
      this._isFirstFrame = true;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.addEffect = addEffect;
    }
    function MultiDimensionalProperty(elem2, data2, mult, container) {
      this.propType = "multidimensional";
      this.mult = mult || 1;
      this.data = data2;
      this._mdf = false;
      this.elem = elem2;
      this.container = container;
      this.comp = elem2.comp;
      this.k = false;
      this.kf = false;
      this.frameId = -1;
      var i;
      var len = data2.k.length;
      this.v = createTypedArray("float32", len);
      this.pv = createTypedArray("float32", len);
      this.vel = createTypedArray("float32", len);
      for (i = 0; i < len; i += 1) {
        this.v[i] = data2.k[i] * this.mult;
        this.pv[i] = data2.k[i];
      }
      this._isFirstFrame = true;
      this.effectsSequence = [];
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.addEffect = addEffect;
    }
    function KeyframedValueProperty(elem2, data2, mult, container) {
      this.propType = "unidimensional";
      this.keyframes = data2.k;
      this.keyframesMetadata = [];
      this.offsetTime = elem2.data.st;
      this.frameId = -1;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: 0,
        _lastKeyframeIndex: -1
      };
      this.k = true;
      this.kf = true;
      this.data = data2;
      this.mult = mult || 1;
      this.elem = elem2;
      this.container = container;
      this.comp = elem2.comp;
      this.v = initFrame;
      this.pv = initFrame;
      this._isFirstFrame = true;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.interpolateValue = interpolateValue;
      this.effectsSequence = [getValueAtCurrentTime.bind(this)];
      this.addEffect = addEffect;
    }
    function KeyframedMultidimensionalProperty(elem2, data2, mult, container) {
      this.propType = "multidimensional";
      var i;
      var len = data2.k.length;
      var s;
      var e;
      var to2;
      var ti;
      for (i = 0; i < len - 1; i += 1) {
        if (data2.k[i].to && data2.k[i].s && data2.k[i + 1] && data2.k[i + 1].s) {
          s = data2.k[i].s;
          e = data2.k[i + 1].s;
          to2 = data2.k[i].to;
          ti = data2.k[i].ti;
          if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to2[0], s[1] + to2[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to2[0], s[1] + to2[1], s[2] + to2[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
            data2.k[i].to = null;
            data2.k[i].ti = null;
          }
          if (s[0] === e[0] && s[1] === e[1] && to2[0] === 0 && to2[1] === 0 && ti[0] === 0 && ti[1] === 0) {
            if (s.length === 2 || s[2] === e[2] && to2[2] === 0 && ti[2] === 0) {
              data2.k[i].to = null;
              data2.k[i].ti = null;
            }
          }
        }
      }
      this.effectsSequence = [getValueAtCurrentTime.bind(this)];
      this.data = data2;
      this.keyframes = data2.k;
      this.keyframesMetadata = [];
      this.offsetTime = elem2.data.st;
      this.k = true;
      this.kf = true;
      this._isFirstFrame = true;
      this.mult = mult || 1;
      this.elem = elem2;
      this.container = container;
      this.comp = elem2.comp;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.interpolateValue = interpolateValue;
      this.frameId = -1;
      var arrLen = data2.k[0].s.length;
      this.v = createTypedArray("float32", arrLen);
      this.pv = createTypedArray("float32", arrLen);
      for (i = 0; i < arrLen; i += 1) {
        this.v[i] = initFrame;
        this.pv[i] = initFrame;
      }
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: createTypedArray("float32", arrLen)
      };
      this.addEffect = addEffect;
    }
    var PropertyFactory = /* @__PURE__ */ function() {
      function getProp(elem2, data2, type, mult, container) {
        if (data2.sid) {
          data2 = elem2.globalData.slotManager.getProp(data2);
        }
        var p;
        if (!data2.k.length) {
          p = new ValueProperty(elem2, data2, mult, container);
        } else if (typeof data2.k[0] === "number") {
          p = new MultiDimensionalProperty(elem2, data2, mult, container);
        } else {
          switch (type) {
            case 0:
              p = new KeyframedValueProperty(elem2, data2, mult, container);
              break;
            case 1:
              p = new KeyframedMultidimensionalProperty(elem2, data2, mult, container);
              break;
          }
        }
        if (p.effectsSequence.length) {
          container.addDynamicProperty(p);
        }
        return p;
      }
      var ob2 = {
        getProp
      };
      return ob2;
    }();
    function DynamicPropertyContainer() {
    }
    DynamicPropertyContainer.prototype = {
      addDynamicProperty: function addDynamicProperty(prop) {
        if (this.dynamicProperties.indexOf(prop) === -1) {
          this.dynamicProperties.push(prop);
          this.container.addDynamicProperty(this);
          this._isAnimated = true;
        }
      },
      iterateDynamicProperties: function iterateDynamicProperties() {
        this._mdf = false;
        var i;
        var len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
          if (this.dynamicProperties[i]._mdf) {
            this._mdf = true;
          }
        }
      },
      initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
        this.container = container;
        this.dynamicProperties = [];
        this._mdf = false;
        this._isAnimated = false;
      }
    };
    var pointPool = function() {
      function create() {
        return createTypedArray("float32", 2);
      }
      return poolFactory(8, create);
    }();
    function ShapePath() {
      this.c = false;
      this._length = 0;
      this._maxLength = 8;
      this.v = createSizedArray(this._maxLength);
      this.o = createSizedArray(this._maxLength);
      this.i = createSizedArray(this._maxLength);
    }
    ShapePath.prototype.setPathData = function(closed, len) {
      this.c = closed;
      this.setLength(len);
      var i = 0;
      while (i < len) {
        this.v[i] = pointPool.newElement();
        this.o[i] = pointPool.newElement();
        this.i[i] = pointPool.newElement();
        i += 1;
      }
    };
    ShapePath.prototype.setLength = function(len) {
      while (this._maxLength < len) {
        this.doubleArrayLength();
      }
      this._length = len;
    };
    ShapePath.prototype.doubleArrayLength = function() {
      this.v = this.v.concat(createSizedArray(this._maxLength));
      this.i = this.i.concat(createSizedArray(this._maxLength));
      this.o = this.o.concat(createSizedArray(this._maxLength));
      this._maxLength *= 2;
    };
    ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
      var arr;
      this._length = Math.max(this._length, pos + 1);
      if (this._length >= this._maxLength) {
        this.doubleArrayLength();
      }
      switch (type) {
        case "v":
          arr = this.v;
          break;
        case "i":
          arr = this.i;
          break;
        case "o":
          arr = this.o;
          break;
        default:
          arr = [];
          break;
      }
      if (!arr[pos] || arr[pos] && !replace) {
        arr[pos] = pointPool.newElement();
      }
      arr[pos][0] = x;
      arr[pos][1] = y;
    };
    ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
      this.setXYAt(vX, vY, "v", pos, replace);
      this.setXYAt(oX, oY, "o", pos, replace);
      this.setXYAt(iX, iY, "i", pos, replace);
    };
    ShapePath.prototype.reverse = function() {
      var newPath = new ShapePath();
      newPath.setPathData(this.c, this._length);
      var vertices = this.v;
      var outPoints = this.o;
      var inPoints = this.i;
      var init = 0;
      if (this.c) {
        newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
        init = 1;
      }
      var cnt = this._length - 1;
      var len = this._length;
      var i;
      for (i = init; i < len; i += 1) {
        newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
        cnt -= 1;
      }
      return newPath;
    };
    ShapePath.prototype.length = function() {
      return this._length;
    };
    var shapePool = function() {
      function create() {
        return new ShapePath();
      }
      function release(shapePath) {
        var len = shapePath._length;
        var i;
        for (i = 0; i < len; i += 1) {
          pointPool.release(shapePath.v[i]);
          pointPool.release(shapePath.i[i]);
          pointPool.release(shapePath.o[i]);
          shapePath.v[i] = null;
          shapePath.i[i] = null;
          shapePath.o[i] = null;
        }
        shapePath._length = 0;
        shapePath.c = false;
      }
      function clone2(shape) {
        var cloned = factory.newElement();
        var i;
        var len = shape._length === void 0 ? shape.v.length : shape._length;
        cloned.setLength(len);
        cloned.c = shape.c;
        for (i = 0; i < len; i += 1) {
          cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
        }
        return cloned;
      }
      var factory = poolFactory(4, create, release);
      factory.clone = clone2;
      return factory;
    }();
    function ShapeCollection() {
      this._length = 0;
      this._maxLength = 4;
      this.shapes = createSizedArray(this._maxLength);
    }
    ShapeCollection.prototype.addShape = function(shapeData) {
      if (this._length === this._maxLength) {
        this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      }
      this.shapes[this._length] = shapeData;
      this._length += 1;
    };
    ShapeCollection.prototype.releaseShapes = function() {
      var i;
      for (i = 0; i < this._length; i += 1) {
        shapePool.release(this.shapes[i]);
      }
      this._length = 0;
    };
    var shapeCollectionPool = function() {
      var ob2 = {
        newShapeCollection,
        release
      };
      var _length = 0;
      var _maxLength = 4;
      var pool = createSizedArray(_maxLength);
      function newShapeCollection() {
        var shapeCollection;
        if (_length) {
          _length -= 1;
          shapeCollection = pool[_length];
        } else {
          shapeCollection = new ShapeCollection();
        }
        return shapeCollection;
      }
      function release(shapeCollection) {
        var i;
        var len = shapeCollection._length;
        for (i = 0; i < len; i += 1) {
          shapePool.release(shapeCollection.shapes[i]);
        }
        shapeCollection._length = 0;
        if (_length === _maxLength) {
          pool = pooling["double"](pool);
          _maxLength *= 2;
        }
        pool[_length] = shapeCollection;
        _length += 1;
      }
      return ob2;
    }();
    var ShapePropertyFactory = function() {
      var initFrame2 = -999999;
      function interpolateShape(frameNum, previousValue, caching) {
        var iterationIndex = caching.lastIndex;
        var keyPropS;
        var keyPropE;
        var isHold;
        var j;
        var k;
        var jLen;
        var kLen;
        var perc;
        var vertexValue;
        var kf = this.keyframes;
        if (frameNum < kf[0].t - this.offsetTime) {
          keyPropS = kf[0].s[0];
          isHold = true;
          iterationIndex = 0;
        } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
          keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
          isHold = true;
        } else {
          var i = iterationIndex;
          var len = kf.length - 1;
          var flag = true;
          var keyData;
          var nextKeyData;
          var keyframeMetadata;
          while (flag) {
            keyData = kf[i];
            nextKeyData = kf[i + 1];
            if (nextKeyData.t - this.offsetTime > frameNum) {
              break;
            }
            if (i < len - 1) {
              i += 1;
            } else {
              flag = false;
            }
          }
          keyframeMetadata = this.keyframesMetadata[i] || {};
          isHold = keyData.h === 1;
          iterationIndex = i;
          if (!isHold) {
            if (frameNum >= nextKeyData.t - this.offsetTime) {
              perc = 1;
            } else if (frameNum < keyData.t - this.offsetTime) {
              perc = 0;
            } else {
              var fnc;
              if (keyframeMetadata.__fnct) {
                fnc = keyframeMetadata.__fnct;
              } else {
                fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                keyframeMetadata.__fnct = fnc;
              }
              perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
            }
            keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
          }
          keyPropS = keyData.s[0];
        }
        jLen = previousValue._length;
        kLen = keyPropS.i[0].length;
        caching.lastIndex = iterationIndex;
        for (j = 0; j < jLen; j += 1) {
          for (k = 0; k < kLen; k += 1) {
            vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
            previousValue.i[j][k] = vertexValue;
            vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
            previousValue.o[j][k] = vertexValue;
            vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
            previousValue.v[j][k] = vertexValue;
          }
        }
      }
      function interpolateShapeCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        var lastFrame = this._caching.lastFrame;
        if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
          this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
          this.interpolateShape(frameNum, this.pv, this._caching);
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }
      function resetShape() {
        this.paths = this.localShapeCollection;
      }
      function shapesEqual(shape1, shape2) {
        if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
          return false;
        }
        var i;
        var len = shape1._length;
        for (i = 0; i < len; i += 1) {
          if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
            return false;
          }
        }
        return true;
      }
      function setVValue2(newPath) {
        if (!shapesEqual(this.v, newPath)) {
          this.v = shapePool.clone(newPath);
          this.localShapeCollection.releaseShapes();
          this.localShapeCollection.addShape(this.v);
          this._mdf = true;
          this.paths = this.localShapeCollection;
        }
      }
      function processEffectsSequence2() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        if (!this.effectsSequence.length) {
          this._mdf = false;
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var finalValue;
        if (this.kf) {
          finalValue = this.pv;
        } else if (this.data.ks) {
          finalValue = this.data.ks.k;
        } else {
          finalValue = this.data.pt.k;
        }
        var i;
        var len = this.effectsSequence.length;
        for (i = 0; i < len; i += 1) {
          finalValue = this.effectsSequence[i](finalValue);
        }
        this.setVValue(finalValue);
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }
      function ShapeProperty(elem2, data2, type) {
        this.propType = "shape";
        this.comp = elem2.comp;
        this.container = elem2;
        this.elem = elem2;
        this.data = data2;
        this.k = false;
        this.kf = false;
        this._mdf = false;
        var pathData = type === 3 ? data2.pt.k : data2.ks.k;
        this.v = shapePool.clone(pathData);
        this.pv = shapePool.clone(this.v);
        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.paths.addShape(this.v);
        this.reset = resetShape;
        this.effectsSequence = [];
      }
      function addEffect2(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }
      ShapeProperty.prototype.interpolateShape = interpolateShape;
      ShapeProperty.prototype.getValue = processEffectsSequence2;
      ShapeProperty.prototype.setVValue = setVValue2;
      ShapeProperty.prototype.addEffect = addEffect2;
      function KeyframedShapeProperty(elem2, data2, type) {
        this.propType = "shape";
        this.comp = elem2.comp;
        this.elem = elem2;
        this.container = elem2;
        this.offsetTime = elem2.data.st;
        this.keyframes = type === 3 ? data2.pt.k : data2.ks.k;
        this.keyframesMetadata = [];
        this.k = true;
        this.kf = true;
        var len = this.keyframes[0].s[0].i.length;
        this.v = shapePool.newElement();
        this.v.setPathData(this.keyframes[0].s[0].c, len);
        this.pv = shapePool.clone(this.v);
        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.paths.addShape(this.v);
        this.lastFrame = initFrame2;
        this.reset = resetShape;
        this._caching = {
          lastFrame: initFrame2,
          lastIndex: 0
        };
        this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
      }
      KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
      KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
      KeyframedShapeProperty.prototype.setVValue = setVValue2;
      KeyframedShapeProperty.prototype.addEffect = addEffect2;
      var EllShapeProperty = function() {
        var cPoint = roundCorner;
        function EllShapePropertyFactory(elem2, data2) {
          this.v = shapePool.newElement();
          this.v.setPathData(true, 4);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.localShapeCollection.addShape(this.v);
          this.d = data2.d;
          this.elem = elem2;
          this.comp = elem2.comp;
          this.frameId = -1;
          this.initDynamicPropertyContainer(elem2);
          this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
          this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertEllToPath();
          }
        }
        EllShapePropertyFactory.prototype = {
          reset: resetShape,
          getValue: function getValue() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertEllToPath();
            }
          },
          convertEllToPath: function convertEllToPath() {
            var p0 = this.p.v[0];
            var p1 = this.p.v[1];
            var s0 = this.s.v[0] / 2;
            var s1 = this.s.v[1] / 2;
            var _cw = this.d !== 3;
            var _v = this.v;
            _v.v[0][0] = p0;
            _v.v[0][1] = p1 - s1;
            _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.v[1][1] = p1;
            _v.v[2][0] = p0;
            _v.v[2][1] = p1 + s1;
            _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.v[3][1] = p1;
            _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
            _v.i[0][1] = p1 - s1;
            _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.i[1][1] = p1 - s1 * cPoint;
            _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
            _v.i[2][1] = p1 + s1;
            _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.i[3][1] = p1 + s1 * cPoint;
            _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
            _v.o[0][1] = p1 - s1;
            _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.o[1][1] = p1 + s1 * cPoint;
            _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
            _v.o[2][1] = p1 + s1;
            _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.o[3][1] = p1 - s1 * cPoint;
          }
        };
        extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
        return EllShapePropertyFactory;
      }();
      var StarShapeProperty = function() {
        function StarShapePropertyFactory(elem2, data2) {
          this.v = shapePool.newElement();
          this.v.setPathData(true, 0);
          this.elem = elem2;
          this.comp = elem2.comp;
          this.data = data2;
          this.frameId = -1;
          this.d = data2.d;
          this.initDynamicPropertyContainer(elem2);
          if (data2.sy === 1) {
            this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
            this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
            this.convertToPath = this.convertStarToPath;
          } else {
            this.convertToPath = this.convertPolygonToPath;
          }
          this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
          this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
          this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
          this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
          this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.localShapeCollection.addShape(this.v);
          this.paths = this.localShapeCollection;
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertToPath();
          }
        }
        StarShapePropertyFactory.prototype = {
          reset: resetShape,
          getValue: function getValue() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertToPath();
            }
          },
          convertStarToPath: function convertStarToPath() {
            var numPts = Math.floor(this.pt.v) * 2;
            var angle = Math.PI * 2 / numPts;
            var longFlag = true;
            var longRad = this.or.v;
            var shortRad = this.ir.v;
            var longRound = this.os.v;
            var shortRound = this.is.v;
            var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
            var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
            var i;
            var rad;
            var roundness;
            var perimSegment;
            var currentAng = -Math.PI / 2;
            currentAng += this.r.v;
            var dir = this.data.d === 3 ? -1 : 1;
            this.v._length = 0;
            for (i = 0; i < numPts; i += 1) {
              rad = longFlag ? longRad : shortRad;
              roundness = longFlag ? longRound : shortRound;
              perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
              var x = rad * Math.cos(currentAng);
              var y = rad * Math.sin(currentAng);
              var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
              var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
              x += +this.p.v[0];
              y += +this.p.v[1];
              this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
              longFlag = !longFlag;
              currentAng += angle * dir;
            }
          },
          convertPolygonToPath: function convertPolygonToPath() {
            var numPts = Math.floor(this.pt.v);
            var angle = Math.PI * 2 / numPts;
            var rad = this.or.v;
            var roundness = this.os.v;
            var perimSegment = 2 * Math.PI * rad / (numPts * 4);
            var i;
            var currentAng = -Math.PI * 0.5;
            var dir = this.data.d === 3 ? -1 : 1;
            currentAng += this.r.v;
            this.v._length = 0;
            for (i = 0; i < numPts; i += 1) {
              var x = rad * Math.cos(currentAng);
              var y = rad * Math.sin(currentAng);
              var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
              var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
              x += +this.p.v[0];
              y += +this.p.v[1];
              this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
              currentAng += angle * dir;
            }
            this.paths.length = 0;
            this.paths[0] = this.v;
          }
        };
        extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
        return StarShapePropertyFactory;
      }();
      var RectShapeProperty = function() {
        function RectShapePropertyFactory(elem2, data2) {
          this.v = shapePool.newElement();
          this.v.c = true;
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.localShapeCollection.addShape(this.v);
          this.paths = this.localShapeCollection;
          this.elem = elem2;
          this.comp = elem2.comp;
          this.frameId = -1;
          this.d = data2.d;
          this.initDynamicPropertyContainer(elem2);
          this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
          this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
          this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertRectToPath();
          }
        }
        RectShapePropertyFactory.prototype = {
          convertRectToPath: function convertRectToPath() {
            var p0 = this.p.v[0];
            var p1 = this.p.v[1];
            var v0 = this.s.v[0] / 2;
            var v1 = this.s.v[1] / 2;
            var round2 = bmMin(v0, v1, this.r.v);
            var cPoint = round2 * (1 - roundCorner);
            this.v._length = 0;
            if (this.d === 2 || this.d === 1) {
              this.v.setTripleAt(p0 + v0, p1 - v1 + round2, p0 + v0, p1 - v1 + round2, p0 + v0, p1 - v1 + cPoint, 0, true);
              this.v.setTripleAt(p0 + v0, p1 + v1 - round2, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round2, 1, true);
              if (round2 !== 0) {
                this.v.setTripleAt(p0 + v0 - round2, p1 + v1, p0 + v0 - round2, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                this.v.setTripleAt(p0 - v0 + round2, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round2, p1 + v1, 3, true);
                this.v.setTripleAt(p0 - v0, p1 + v1 - round2, p0 - v0, p1 + v1 - round2, p0 - v0, p1 + v1 - cPoint, 4, true);
                this.v.setTripleAt(p0 - v0, p1 - v1 + round2, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round2, 5, true);
                this.v.setTripleAt(p0 - v0 + round2, p1 - v1, p0 - v0 + round2, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                this.v.setTripleAt(p0 + v0 - round2, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round2, p1 - v1, 7, true);
              } else {
                this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
              }
            } else {
              this.v.setTripleAt(p0 + v0, p1 - v1 + round2, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round2, 0, true);
              if (round2 !== 0) {
                this.v.setTripleAt(p0 + v0 - round2, p1 - v1, p0 + v0 - round2, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                this.v.setTripleAt(p0 - v0 + round2, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round2, p1 - v1, 2, true);
                this.v.setTripleAt(p0 - v0, p1 - v1 + round2, p0 - v0, p1 - v1 + round2, p0 - v0, p1 - v1 + cPoint, 3, true);
                this.v.setTripleAt(p0 - v0, p1 + v1 - round2, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round2, 4, true);
                this.v.setTripleAt(p0 - v0 + round2, p1 + v1, p0 - v0 + round2, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                this.v.setTripleAt(p0 + v0 - round2, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round2, p1 + v1, 6, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round2, p0 + v0, p1 + v1 - round2, p0 + v0, p1 + v1 - cPoint, 7, true);
              } else {
                this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
              }
            }
          },
          getValue: function getValue() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertRectToPath();
            }
          },
          reset: resetShape
        };
        extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
        return RectShapePropertyFactory;
      }();
      function getShapeProp(elem2, data2, type) {
        var prop;
        if (type === 3 || type === 4) {
          var dataProp = type === 3 ? data2.pt : data2.ks;
          var keys = dataProp.k;
          if (keys.length) {
            prop = new KeyframedShapeProperty(elem2, data2, type);
          } else {
            prop = new ShapeProperty(elem2, data2, type);
          }
        } else if (type === 5) {
          prop = new RectShapeProperty(elem2, data2);
        } else if (type === 6) {
          prop = new EllShapeProperty(elem2, data2);
        } else if (type === 7) {
          prop = new StarShapeProperty(elem2, data2);
        }
        if (prop.k) {
          elem2.addDynamicProperty(prop);
        }
        return prop;
      }
      function getConstructorFunction() {
        return ShapeProperty;
      }
      function getKeyframedConstructorFunction() {
        return KeyframedShapeProperty;
      }
      var ob2 = {};
      ob2.getShapeProp = getShapeProp;
      ob2.getConstructorFunction = getConstructorFunction;
      ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
      return ob2;
    }();
    var Matrix = /* @__PURE__ */ function() {
      var _cos = Math.cos;
      var _sin = Math.sin;
      var _tan = Math.tan;
      var _rnd = Math.round;
      function reset() {
        this.props[0] = 1;
        this.props[1] = 0;
        this.props[2] = 0;
        this.props[3] = 0;
        this.props[4] = 0;
        this.props[5] = 1;
        this.props[6] = 0;
        this.props[7] = 0;
        this.props[8] = 0;
        this.props[9] = 0;
        this.props[10] = 1;
        this.props[11] = 0;
        this.props[12] = 0;
        this.props[13] = 0;
        this.props[14] = 0;
        this.props[15] = 1;
        return this;
      }
      function rotate2(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function rotateX(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
      }
      function rotateY(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
      }
      function rotateZ(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function shear(sx, sy) {
        return this._t(1, sy, sx, 1, 0, 0);
      }
      function skew(ax, ay) {
        return this.shear(_tan(ax), _tan(ay));
      }
      function skewFromAxis(ax, angle) {
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function scale2(sx, sy, sz) {
        if (!sz && sz !== 0) {
          sz = 1;
        }
        if (sx === 1 && sy === 1 && sz === 1) {
          return this;
        }
        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
      }
      function setTransform(a, b, c, d, e, f, g, h3, i, j, k, l, m, n, o, p) {
        this.props[0] = a;
        this.props[1] = b;
        this.props[2] = c;
        this.props[3] = d;
        this.props[4] = e;
        this.props[5] = f;
        this.props[6] = g;
        this.props[7] = h3;
        this.props[8] = i;
        this.props[9] = j;
        this.props[10] = k;
        this.props[11] = l;
        this.props[12] = m;
        this.props[13] = n;
        this.props[14] = o;
        this.props[15] = p;
        return this;
      }
      function translate(tx, ty, tz) {
        tz = tz || 0;
        if (tx !== 0 || ty !== 0 || tz !== 0) {
          return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
        }
        return this;
      }
      function transform2(a2, b2, c2, d2, e2, f2, g2, h22, i2, j2, k2, l2, m2, n2, o2, p2) {
        var _p = this.props;
        if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h22 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
          _p[12] = _p[12] * a2 + _p[15] * m2;
          _p[13] = _p[13] * f2 + _p[15] * n2;
          _p[14] = _p[14] * k2 + _p[15] * o2;
          _p[15] *= p2;
          this._identityCalculated = false;
          return this;
        }
        var a1 = _p[0];
        var b1 = _p[1];
        var c1 = _p[2];
        var d1 = _p[3];
        var e1 = _p[4];
        var f1 = _p[5];
        var g1 = _p[6];
        var h12 = _p[7];
        var i1 = _p[8];
        var j1 = _p[9];
        var k1 = _p[10];
        var l1 = _p[11];
        var m1 = _p[12];
        var n1 = _p[13];
        var o1 = _p[14];
        var p1 = _p[15];
        _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
        _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
        _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
        _p[3] = a1 * d2 + b1 * h22 + c1 * l2 + d1 * p2;
        _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h12 * m2;
        _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h12 * n2;
        _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h12 * o2;
        _p[7] = e1 * d2 + f1 * h22 + g1 * l2 + h12 * p2;
        _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
        _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
        _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
        _p[11] = i1 * d2 + j1 * h22 + k1 * l2 + l1 * p2;
        _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
        _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
        _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
        _p[15] = m1 * d2 + n1 * h22 + o1 * l2 + p1 * p2;
        this._identityCalculated = false;
        return this;
      }
      function multiply(matrix) {
        var matrixProps = matrix.props;
        return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
      }
      function isIdentity() {
        if (!this._identityCalculated) {
          this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
          this._identityCalculated = true;
        }
        return this._identity;
      }
      function equals(matr) {
        var i = 0;
        while (i < 16) {
          if (matr.props[i] !== this.props[i]) {
            return false;
          }
          i += 1;
        }
        return true;
      }
      function clone2(matr) {
        var i;
        for (i = 0; i < 16; i += 1) {
          matr.props[i] = this.props[i];
        }
        return matr;
      }
      function cloneFromProps(props) {
        var i;
        for (i = 0; i < 16; i += 1) {
          this.props[i] = props[i];
        }
      }
      function applyToPoint(x, y, z) {
        return {
          x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
          y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
          z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
        };
      }
      function applyToX(x, y, z) {
        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
      }
      function applyToY(x, y, z) {
        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
      }
      function applyToZ(x, y, z) {
        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
      }
      function getInverseMatrix() {
        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
        var a = this.props[5] / determinant;
        var b = -this.props[1] / determinant;
        var c = -this.props[4] / determinant;
        var d = this.props[0] / determinant;
        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
        var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
        var inverseMatrix = new Matrix();
        inverseMatrix.props[0] = a;
        inverseMatrix.props[1] = b;
        inverseMatrix.props[4] = c;
        inverseMatrix.props[5] = d;
        inverseMatrix.props[12] = e;
        inverseMatrix.props[13] = f;
        return inverseMatrix;
      }
      function inversePoint(pt) {
        var inverseMatrix = this.getInverseMatrix();
        return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
      }
      function inversePoints(pts) {
        var i;
        var len = pts.length;
        var retPts = [];
        for (i = 0; i < len; i += 1) {
          retPts[i] = inversePoint(pts[i]);
        }
        return retPts;
      }
      function applyToTriplePoints(pt1, pt2, pt3) {
        var arr = createTypedArray("float32", 6);
        if (this.isIdentity()) {
          arr[0] = pt1[0];
          arr[1] = pt1[1];
          arr[2] = pt2[0];
          arr[3] = pt2[1];
          arr[4] = pt3[0];
          arr[5] = pt3[1];
        } else {
          var p0 = this.props[0];
          var p1 = this.props[1];
          var p4 = this.props[4];
          var p5 = this.props[5];
          var p12 = this.props[12];
          var p13 = this.props[13];
          arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
          arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
          arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
          arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
          arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
          arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
        }
        return arr;
      }
      function applyToPointArray(x, y, z) {
        var arr;
        if (this.isIdentity()) {
          arr = [x, y, z];
        } else {
          arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
        }
        return arr;
      }
      function applyToPointStringified(x, y) {
        if (this.isIdentity()) {
          return x + "," + y;
        }
        var _p = this.props;
        return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
      }
      function toCSS() {
        var i = 0;
        var props = this.props;
        var cssValue = "matrix3d(";
        var v = 1e4;
        while (i < 16) {
          cssValue += _rnd(props[i] * v) / v;
          cssValue += i === 15 ? ")" : ",";
          i += 1;
        }
        return cssValue;
      }
      function roundMatrixProperty(val2) {
        var v = 1e4;
        if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
          return _rnd(val2 * v) / v;
        }
        return val2;
      }
      function to2dCSS() {
        var props = this.props;
        var _a = roundMatrixProperty(props[0]);
        var _b = roundMatrixProperty(props[1]);
        var _c = roundMatrixProperty(props[4]);
        var _d = roundMatrixProperty(props[5]);
        var _e = roundMatrixProperty(props[12]);
        var _f = roundMatrixProperty(props[13]);
        return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
      }
      return function() {
        this.reset = reset;
        this.rotate = rotate2;
        this.rotateX = rotateX;
        this.rotateY = rotateY;
        this.rotateZ = rotateZ;
        this.skew = skew;
        this.skewFromAxis = skewFromAxis;
        this.shear = shear;
        this.scale = scale2;
        this.setTransform = setTransform;
        this.translate = translate;
        this.transform = transform2;
        this.multiply = multiply;
        this.applyToPoint = applyToPoint;
        this.applyToX = applyToX;
        this.applyToY = applyToY;
        this.applyToZ = applyToZ;
        this.applyToPointArray = applyToPointArray;
        this.applyToTriplePoints = applyToTriplePoints;
        this.applyToPointStringified = applyToPointStringified;
        this.toCSS = toCSS;
        this.to2dCSS = to2dCSS;
        this.clone = clone2;
        this.cloneFromProps = cloneFromProps;
        this.equals = equals;
        this.inversePoints = inversePoints;
        this.inversePoint = inversePoint;
        this.getInverseMatrix = getInverseMatrix;
        this._t = this.transform;
        this.isIdentity = isIdentity;
        this._identity = true;
        this._identityCalculated = false;
        this.props = createTypedArray("float32", 16);
        this.reset();
      };
    }();
    function _typeof$3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$3 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$3 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$3(obj);
    }
    var lottie = {};
    function setLocation(href) {
      setLocationHref(href);
    }
    function searchAnimations() {
      {
        animationManager.searchAnimations();
      }
    }
    function setSubframeRendering(flag) {
      setSubframeEnabled(flag);
    }
    function setPrefix(prefix) {
      setIdPrefix(prefix);
    }
    function loadAnimation(params) {
      return animationManager.loadAnimation(params);
    }
    function setQuality(value2) {
      if (typeof value2 === "string") {
        switch (value2) {
          case "high":
            setDefaultCurveSegments(200);
            break;
          default:
          case "medium":
            setDefaultCurveSegments(50);
            break;
          case "low":
            setDefaultCurveSegments(10);
            break;
        }
      } else if (!isNaN(value2) && value2 > 1) {
        setDefaultCurveSegments(value2);
      }
    }
    function inBrowser() {
      return typeof navigator !== "undefined";
    }
    function installPlugin(type, plugin) {
      if (type === "expressions") {
        setExpressionsPlugin(plugin);
      }
    }
    function getFactory(name2) {
      switch (name2) {
        case "propertyFactory":
          return PropertyFactory;
        case "shapePropertyFactory":
          return ShapePropertyFactory;
        case "matrix":
          return Matrix;
        default:
          return null;
      }
    }
    lottie.play = animationManager.play;
    lottie.pause = animationManager.pause;
    lottie.setLocationHref = setLocation;
    lottie.togglePause = animationManager.togglePause;
    lottie.setSpeed = animationManager.setSpeed;
    lottie.setDirection = animationManager.setDirection;
    lottie.stop = animationManager.stop;
    lottie.searchAnimations = searchAnimations;
    lottie.registerAnimation = animationManager.registerAnimation;
    lottie.loadAnimation = loadAnimation;
    lottie.setSubframeRendering = setSubframeRendering;
    lottie.resize = animationManager.resize;
    lottie.goToAndStop = animationManager.goToAndStop;
    lottie.destroy = animationManager.destroy;
    lottie.setQuality = setQuality;
    lottie.inBrowser = inBrowser;
    lottie.installPlugin = installPlugin;
    lottie.freeze = animationManager.freeze;
    lottie.unfreeze = animationManager.unfreeze;
    lottie.setVolume = animationManager.setVolume;
    lottie.mute = animationManager.mute;
    lottie.unmute = animationManager.unmute;
    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
    lottie.useWebWorker = setWebWorker;
    lottie.setIDPrefix = setPrefix;
    lottie.__getFactory = getFactory;
    lottie.version = "5.12.2";
    function checkReady() {
      if (document.readyState === "complete") {
        clearInterval(readyStateCheckInterval);
        searchAnimations();
      }
    }
    function getQueryVariable(variable) {
      var vars = queryString.split("&");
      for (var i = 0; i < vars.length; i += 1) {
        var pair = vars[i].split("=");
        if (decodeURIComponent(pair[0]) == variable) {
          return decodeURIComponent(pair[1]);
        }
      }
      return null;
    }
    var queryString = "";
    {
      var scripts = document.getElementsByTagName("script");
      var index = scripts.length - 1;
      var myScript = scripts[index] || {
        src: ""
      };
      queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
      getQueryVariable("renderer");
    }
    var readyStateCheckInterval = setInterval(checkReady, 100);
    try {
      if (!((false ? "undefined" : _typeof$3(exports)) === "object" && true) && true) {
        window.bodymovin = lottie;
      }
    } catch (err) {
    }
    var ShapeModifiers = function() {
      var ob2 = {};
      var modifiers = {};
      ob2.registerModifier = registerModifier;
      ob2.getModifier = getModifier;
      function registerModifier(nm, factory) {
        if (!modifiers[nm]) {
          modifiers[nm] = factory;
        }
      }
      function getModifier(nm, elem2, data2) {
        return new modifiers[nm](elem2, data2);
      }
      return ob2;
    }();
    function ShapeModifier() {
    }
    ShapeModifier.prototype.initModifierProperties = function() {
    };
    ShapeModifier.prototype.addShapeToModifier = function() {
    };
    ShapeModifier.prototype.addShape = function(data2) {
      if (!this.closed) {
        data2.sh.container.addDynamicProperty(data2.sh);
        var shapeData = {
          shape: data2.sh,
          data: data2,
          localShapeCollection: shapeCollectionPool.newShapeCollection()
        };
        this.shapes.push(shapeData);
        this.addShapeToModifier(shapeData);
        if (this._isAnimated) {
          data2.setAsAnimated();
        }
      }
    };
    ShapeModifier.prototype.init = function(elem2, data2) {
      this.shapes = [];
      this.elem = elem2;
      this.initDynamicPropertyContainer(elem2);
      this.initModifierProperties(elem2, data2);
      this.frameId = initialDefaultFrame;
      this.closed = false;
      this.k = false;
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.getValue(true);
      }
    };
    ShapeModifier.prototype.processKeys = function() {
      if (this.elem.globalData.frameId === this.frameId) {
        return;
      }
      this.frameId = this.elem.globalData.frameId;
      this.iterateDynamicProperties();
    };
    extendPrototype([DynamicPropertyContainer], ShapeModifier);
    function TrimModifier() {
    }
    extendPrototype([ShapeModifier], TrimModifier);
    TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
      this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
      this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
      this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
      this.sValue = 0;
      this.eValue = 0;
      this.getValue = this.processKeys;
      this.m = data2.m;
      this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    };
    TrimModifier.prototype.addShapeToModifier = function(shapeData) {
      shapeData.pathsData = [];
    };
    TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
      var segments = [];
      if (e <= 1) {
        segments.push({
          s,
          e
        });
      } else if (s >= 1) {
        segments.push({
          s: s - 1,
          e: e - 1
        });
      } else {
        segments.push({
          s,
          e: 1
        });
        segments.push({
          s: 0,
          e: e - 1
        });
      }
      var shapeSegments = [];
      var i;
      var len = segments.length;
      var segmentOb;
      for (i = 0; i < len; i += 1) {
        segmentOb = segments[i];
        if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
          var shapeS;
          var shapeE;
          if (segmentOb.s * totalModifierLength <= addedLength) {
            shapeS = 0;
          } else {
            shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
          }
          if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
            shapeE = 1;
          } else {
            shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
          }
          shapeSegments.push([shapeS, shapeE]);
        }
      }
      if (!shapeSegments.length) {
        shapeSegments.push([0, 0]);
      }
      return shapeSegments;
    };
    TrimModifier.prototype.releasePathsData = function(pathsData) {
      var i;
      var len = pathsData.length;
      for (i = 0; i < len; i += 1) {
        segmentsLengthPool.release(pathsData[i]);
      }
      pathsData.length = 0;
      return pathsData;
    };
    TrimModifier.prototype.processShapes = function(_isFirstFrame) {
      var s;
      var e;
      if (this._mdf || _isFirstFrame) {
        var o = this.o.v % 360 / 360;
        if (o < 0) {
          o += 1;
        }
        if (this.s.v > 1) {
          s = 1 + o;
        } else if (this.s.v < 0) {
          s = 0 + o;
        } else {
          s = this.s.v + o;
        }
        if (this.e.v > 1) {
          e = 1 + o;
        } else if (this.e.v < 0) {
          e = 0 + o;
        } else {
          e = this.e.v + o;
        }
        if (s > e) {
          var _s = s;
          s = e;
          e = _s;
        }
        s = Math.round(s * 1e4) * 1e-4;
        e = Math.round(e * 1e4) * 1e-4;
        this.sValue = s;
        this.eValue = e;
      } else {
        s = this.sValue;
        e = this.eValue;
      }
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var pathsData;
      var pathData;
      var totalShapeLength;
      var totalModifierLength = 0;
      if (e === s) {
        for (i = 0; i < len; i += 1) {
          this.shapes[i].localShapeCollection.releaseShapes();
          this.shapes[i].shape._mdf = true;
          this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
          if (this._mdf) {
            this.shapes[i].pathsData.length = 0;
          }
        }
      } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
        var segments = [];
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
            shapeData.shape.paths = shapeData.localShapeCollection;
          } else {
            shapePaths = shapeData.shape.paths;
            jLen = shapePaths._length;
            totalShapeLength = 0;
            if (!shapeData.shape._mdf && shapeData.pathsData.length) {
              totalShapeLength = shapeData.totalShapeLength;
            } else {
              pathsData = this.releasePathsData(shapeData.pathsData);
              for (j = 0; j < jLen; j += 1) {
                pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                pathsData.push(pathData);
                totalShapeLength += pathData.totalLength;
              }
              shapeData.totalShapeLength = totalShapeLength;
              shapeData.pathsData = pathsData;
            }
            totalModifierLength += totalShapeLength;
            shapeData.shape._mdf = true;
          }
        }
        var shapeS = s;
        var shapeE = e;
        var addedLength = 0;
        var edges;
        for (i = len - 1; i >= 0; i -= 1) {
          shapeData = this.shapes[i];
          if (shapeData.shape._mdf) {
            localShapeCollection = shapeData.localShapeCollection;
            localShapeCollection.releaseShapes();
            if (this.m === 2 && len > 1) {
              edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
              addedLength += shapeData.totalShapeLength;
            } else {
              edges = [[shapeS, shapeE]];
            }
            jLen = edges.length;
            for (j = 0; j < jLen; j += 1) {
              shapeS = edges[j][0];
              shapeE = edges[j][1];
              segments.length = 0;
              if (shapeE <= 1) {
                segments.push({
                  s: shapeData.totalShapeLength * shapeS,
                  e: shapeData.totalShapeLength * shapeE
                });
              } else if (shapeS >= 1) {
                segments.push({
                  s: shapeData.totalShapeLength * (shapeS - 1),
                  e: shapeData.totalShapeLength * (shapeE - 1)
                });
              } else {
                segments.push({
                  s: shapeData.totalShapeLength * shapeS,
                  e: shapeData.totalShapeLength
                });
                segments.push({
                  s: 0,
                  e: shapeData.totalShapeLength * (shapeE - 1)
                });
              }
              var newShapesData = this.addShapes(shapeData, segments[0]);
              if (segments[0].s !== segments[0].e) {
                if (segments.length > 1) {
                  var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                  if (lastShapeInCollection.c) {
                    var lastShape = newShapesData.pop();
                    this.addPaths(newShapesData, localShapeCollection);
                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                  } else {
                    this.addPaths(newShapesData, localShapeCollection);
                    newShapesData = this.addShapes(shapeData, segments[1]);
                  }
                }
                this.addPaths(newShapesData, localShapeCollection);
              }
            }
            shapeData.shape.paths = localShapeCollection;
          }
        }
      } else if (this._mdf) {
        for (i = 0; i < len; i += 1) {
          this.shapes[i].pathsData.length = 0;
          this.shapes[i].shape._mdf = true;
        }
      }
    };
    TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
      var i;
      var len = newPaths.length;
      for (i = 0; i < len; i += 1) {
        localShapeCollection.addShape(newPaths[i]);
      }
    };
    TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
      shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
      shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
      if (newShape) {
        shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
      }
      shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
    };
    TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
      shapePath.setXYAt(points[1], points[5], "o", pos);
      shapePath.setXYAt(points[2], points[6], "i", pos + 1);
      if (newShape) {
        shapePath.setXYAt(points[0], points[4], "v", pos);
      }
      shapePath.setXYAt(points[3], points[7], "v", pos + 1);
    };
    TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
      var pathsData = shapeData.pathsData;
      var shapePaths = shapeData.shape.paths.shapes;
      var i;
      var len = shapeData.shape.paths._length;
      var j;
      var jLen;
      var addedLength = 0;
      var currentLengthData;
      var segmentCount;
      var lengths;
      var segment;
      var shapes = [];
      var initPos;
      var newShape = true;
      if (!shapePath) {
        shapePath = shapePool.newElement();
        segmentCount = 0;
        initPos = 0;
      } else {
        segmentCount = shapePath._length;
        initPos = shapePath._length;
      }
      shapes.push(shapePath);
      for (i = 0; i < len; i += 1) {
        lengths = pathsData[i].lengths;
        shapePath.c = shapePaths[i].c;
        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
        for (j = 1; j < jLen; j += 1) {
          currentLengthData = lengths[j - 1];
          if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
            addedLength += currentLengthData.addedLength;
            shapePath.c = false;
          } else if (addedLength > shapeSegment.e) {
            shapePath.c = false;
            break;
          } else {
            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
              this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
              newShape = false;
            } else {
              segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
              this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
              newShape = false;
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
        }
        if (shapePaths[i].c && lengths.length) {
          currentLengthData = lengths[j - 1];
          if (addedLength <= shapeSegment.e) {
            var segmentLength = lengths[j - 1].addedLength;
            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
              this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
              newShape = false;
            } else {
              segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
              this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
              newShape = false;
              shapePath.c = false;
            }
          } else {
            shapePath.c = false;
          }
          addedLength += currentLengthData.addedLength;
          segmentCount += 1;
        }
        if (shapePath._length) {
          shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
          shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
        }
        if (addedLength > shapeSegment.e) {
          break;
        }
        if (i < len - 1) {
          shapePath = shapePool.newElement();
          newShape = true;
          shapes.push(shapePath);
          segmentCount = 0;
        }
      }
      return shapes;
    };
    function PuckerAndBloatModifier() {
    }
    extendPrototype([ShapeModifier], PuckerAndBloatModifier);
    PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
      this.getValue = this.processKeys;
      this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
      this._isAnimated = !!this.amount.effectsSequence.length;
    };
    PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
      var percent = amount / 100;
      var centerPoint = [0, 0];
      var pathLength = path._length;
      var i = 0;
      for (i = 0; i < pathLength; i += 1) {
        centerPoint[0] += path.v[i][0];
        centerPoint[1] += path.v[i][1];
      }
      centerPoint[0] /= pathLength;
      centerPoint[1] /= pathLength;
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      var vX;
      var vY;
      var oX;
      var oY;
      var iX;
      var iY;
      for (i = 0; i < pathLength; i += 1) {
        vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
        vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
        oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
        oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
        iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
        iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
      }
      return clonedPath;
    };
    PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amount = this.amount.v;
      if (amount !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    var TransformPropertyFactory = function() {
      var defaultVector = [0, 0];
      function applyToMatrix(mat) {
        var _mdf = this._mdf;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || _mdf;
        if (this.a) {
          mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
        }
        if (this.s) {
          mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
        }
        if (this.sk) {
          mat.skewFromAxis(-this.sk.v, this.sa.v);
        }
        if (this.r) {
          mat.rotate(-this.r.v);
        } else {
          mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
        }
        if (this.data.p.s) {
          if (this.data.p.z) {
            mat.translate(this.px.v, this.py.v, -this.pz.v);
          } else {
            mat.translate(this.px.v, this.py.v, 0);
          }
        } else {
          mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
      }
      function processKeys(forceRender) {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        if (this._isDirty) {
          this.precalculateMatrix();
          this._isDirty = false;
        }
        this.iterateDynamicProperties();
        if (this._mdf || forceRender) {
          var frameRate;
          this.v.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.appliedTransformations < 2) {
            this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk && this.appliedTransformations < 3) {
            this.v.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r && this.appliedTransformations < 4) {
            this.v.rotate(-this.r.v);
          } else if (!this.r && this.appliedTransformations < 4) {
            this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }
          if (this.autoOriented) {
            var v1;
            var v2;
            frameRate = this.elem.globalData.frameRate;
            if (this.p && this.p.keyframes && this.p.getValueAtTime) {
              if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
              } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
              } else {
                v1 = this.p.pv;
                v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
              }
            } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
              v1 = [];
              v2 = [];
              var px = this.px;
              var py = this.py;
              if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
              } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
              } else {
                v1 = [px.pv, py.pv];
                v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
              }
            } else {
              v2 = defaultVector;
              v1 = v2;
            }
            this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
          }
          if (this.data.p && this.data.p.s) {
            if (this.data.p.z) {
              this.v.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              this.v.translate(this.px.v, this.py.v, 0);
            }
          } else {
            this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        this.frameId = this.elem.globalData.frameId;
      }
      function precalculateMatrix() {
        this.appliedTransformations = 0;
        this.pre.reset();
        if (!this.a.effectsSequence.length) {
          this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          this.appliedTransformations = 1;
        } else {
          return;
        }
        if (!this.s.effectsSequence.length) {
          this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          this.appliedTransformations = 2;
        } else {
          return;
        }
        if (this.sk) {
          if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
            this.pre.skewFromAxis(-this.sk.v, this.sa.v);
            this.appliedTransformations = 3;
          } else {
            return;
          }
        }
        if (this.r) {
          if (!this.r.effectsSequence.length) {
            this.pre.rotate(-this.r.v);
            this.appliedTransformations = 4;
          }
        } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
          this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          this.appliedTransformations = 4;
        }
      }
      function autoOrient() {
      }
      function addDynamicProperty(prop) {
        this._addDynamicProperty(prop);
        this.elem.addDynamicProperty(prop);
        this._isDirty = true;
      }
      function TransformProperty(elem2, data2, container) {
        this.elem = elem2;
        this.frameId = -1;
        this.propType = "transform";
        this.data = data2;
        this.v = new Matrix();
        this.pre = new Matrix();
        this.appliedTransformations = 0;
        this.initDynamicPropertyContainer(container || elem2);
        if (data2.p && data2.p.s) {
          this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
          this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
          if (data2.p.z) {
            this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
          }
        } else {
          this.p = PropertyFactory.getProp(elem2, data2.p || {
            k: [0, 0, 0]
          }, 1, 0, this);
        }
        if (data2.rx) {
          this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
          this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
          this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
          if (data2.or.k[0].ti) {
            var i;
            var len = data2.or.k.length;
            for (i = 0; i < len; i += 1) {
              data2.or.k[i].to = null;
              data2.or.k[i].ti = null;
            }
          }
          this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
          this.or.sh = true;
        } else {
          this.r = PropertyFactory.getProp(elem2, data2.r || {
            k: 0
          }, 0, degToRads, this);
        }
        if (data2.sk) {
          this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
          this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
        }
        this.a = PropertyFactory.getProp(elem2, data2.a || {
          k: [0, 0, 0]
        }, 1, 0, this);
        this.s = PropertyFactory.getProp(elem2, data2.s || {
          k: [100, 100, 100]
        }, 1, 0.01, this);
        if (data2.o) {
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
        } else {
          this.o = {
            _mdf: false,
            v: 1
          };
        }
        this._isDirty = true;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
      }
      TransformProperty.prototype = {
        applyToMatrix,
        getValue: processKeys,
        precalculateMatrix,
        autoOrient
      };
      extendPrototype([DynamicPropertyContainer], TransformProperty);
      TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
      TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
      function getTransformProperty(elem2, data2, container) {
        return new TransformProperty(elem2, data2, container);
      }
      return {
        getTransformProperty
      };
    }();
    function RepeaterModifier() {
    }
    extendPrototype([ShapeModifier], RepeaterModifier);
    RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
      this.getValue = this.processKeys;
      this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
      this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
      this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
      this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
      this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
      this.data = data2;
      if (!this.dynamicProperties.length) {
        this.getValue(true);
      }
      this._isAnimated = !!this.dynamicProperties.length;
      this.pMatrix = new Matrix();
      this.rMatrix = new Matrix();
      this.sMatrix = new Matrix();
      this.tMatrix = new Matrix();
      this.matrix = new Matrix();
    };
    RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
      var dir = inv ? -1 : 1;
      var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
      var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
      pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
      rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
      rMatrix.rotate(-transform2.r.v * dir * perc);
      rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
      sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
      sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
      sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
    };
    RepeaterModifier.prototype.init = function(elem2, arr, pos, elemsData) {
      this.elem = elem2;
      this.arr = arr;
      this.pos = pos;
      this.elemsData = elemsData;
      this._currentCopies = 0;
      this._elements = [];
      this._groups = [];
      this.frameId = -1;
      this.initDynamicPropertyContainer(elem2);
      this.initModifierProperties(elem2, arr[pos]);
      while (pos > 0) {
        pos -= 1;
        this._elements.unshift(arr[pos]);
      }
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.getValue(true);
      }
    };
    RepeaterModifier.prototype.resetElements = function(elements2) {
      var i;
      var len = elements2.length;
      for (i = 0; i < len; i += 1) {
        elements2[i]._processed = false;
        if (elements2[i].ty === "gr") {
          this.resetElements(elements2[i].it);
        }
      }
    };
    RepeaterModifier.prototype.cloneElements = function(elements2) {
      var newElements = JSON.parse(JSON.stringify(elements2));
      this.resetElements(newElements);
      return newElements;
    };
    RepeaterModifier.prototype.changeGroupRender = function(elements2, renderFlag) {
      var i;
      var len = elements2.length;
      for (i = 0; i < len; i += 1) {
        elements2[i]._render = renderFlag;
        if (elements2[i].ty === "gr") {
          this.changeGroupRender(elements2[i].it, renderFlag);
        }
      }
    };
    RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
      var items;
      var itemsTransform;
      var i;
      var dir;
      var cont;
      var hasReloaded = false;
      if (this._mdf || _isFirstFrame) {
        var copies = Math.ceil(this.c.v);
        if (this._groups.length < copies) {
          while (this._groups.length < copies) {
            var group = {
              it: this.cloneElements(this._elements),
              ty: "gr"
            };
            group.it.push({
              a: {
                a: 0,
                ix: 1,
                k: [0, 0]
              },
              nm: "Transform",
              o: {
                a: 0,
                ix: 7,
                k: 100
              },
              p: {
                a: 0,
                ix: 2,
                k: [0, 0]
              },
              r: {
                a: 1,
                ix: 6,
                k: [{
                  s: 0,
                  e: 0,
                  t: 0
                }, {
                  s: 0,
                  e: 0,
                  t: 1
                }]
              },
              s: {
                a: 0,
                ix: 3,
                k: [100, 100]
              },
              sa: {
                a: 0,
                ix: 5,
                k: 0
              },
              sk: {
                a: 0,
                ix: 4,
                k: 0
              },
              ty: "tr"
            });
            this.arr.splice(0, 0, group);
            this._groups.splice(0, 0, group);
            this._currentCopies += 1;
          }
          this.elem.reloadShapes();
          hasReloaded = true;
        }
        cont = 0;
        var renderFlag;
        for (i = 0; i <= this._groups.length - 1; i += 1) {
          renderFlag = cont < copies;
          this._groups[i]._render = renderFlag;
          this.changeGroupRender(this._groups[i].it, renderFlag);
          if (!renderFlag) {
            var elems = this.elemsData[i].it;
            var transformData2 = elems[elems.length - 1];
            if (transformData2.transform.op.v !== 0) {
              transformData2.transform.op._mdf = true;
              transformData2.transform.op.v = 0;
            } else {
              transformData2.transform.op._mdf = false;
            }
          }
          cont += 1;
        }
        this._currentCopies = copies;
        var offset = this.o.v;
        var offsetModulo = offset % 1;
        var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
        var pProps = this.pMatrix.props;
        var rProps = this.rMatrix.props;
        var sProps = this.sMatrix.props;
        this.pMatrix.reset();
        this.rMatrix.reset();
        this.sMatrix.reset();
        this.tMatrix.reset();
        this.matrix.reset();
        var iteration = 0;
        if (offset > 0) {
          while (iteration < roundOffset) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
            iteration += 1;
          }
          if (offsetModulo) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
            iteration += offsetModulo;
          }
        } else if (offset < 0) {
          while (iteration > roundOffset) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
            iteration -= 1;
          }
          if (offsetModulo) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
            iteration -= offsetModulo;
          }
        }
        i = this.data.m === 1 ? 0 : this._currentCopies - 1;
        dir = this.data.m === 1 ? 1 : -1;
        cont = this._currentCopies;
        var j;
        var jLen;
        while (cont) {
          items = this.elemsData[i].it;
          itemsTransform = items[items.length - 1].transform.mProps.v.props;
          jLen = itemsTransform.length;
          items[items.length - 1].transform.mProps._mdf = true;
          items[items.length - 1].transform.op._mdf = true;
          items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
          if (iteration !== 0) {
            if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
            }
            this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
            this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
            this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
            for (j = 0; j < jLen; j += 1) {
              itemsTransform[j] = this.matrix.props[j];
            }
            this.matrix.reset();
          } else {
            this.matrix.reset();
            for (j = 0; j < jLen; j += 1) {
              itemsTransform[j] = this.matrix.props[j];
            }
          }
          iteration += 1;
          cont -= 1;
          i += dir;
        }
      } else {
        cont = this._currentCopies;
        i = 0;
        dir = 1;
        while (cont) {
          items = this.elemsData[i].it;
          itemsTransform = items[items.length - 1].transform.mProps.v.props;
          items[items.length - 1].transform.mProps._mdf = false;
          items[items.length - 1].transform.op._mdf = false;
          cont -= 1;
          i += dir;
        }
      }
      return hasReloaded;
    };
    RepeaterModifier.prototype.addShape = function() {
    };
    function RoundCornersModifier() {
    }
    extendPrototype([ShapeModifier], RoundCornersModifier);
    RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
      this.getValue = this.processKeys;
      this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
      this._isAnimated = !!this.rd.effectsSequence.length;
    };
    RoundCornersModifier.prototype.processPath = function(path, round2) {
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      var i;
      var len = path._length;
      var currentV;
      var currentI;
      var currentO;
      var closerV;
      var distance;
      var newPosPerc;
      var index2 = 0;
      var vX;
      var vY;
      var oX;
      var oY;
      var iX;
      var iY;
      for (i = 0; i < len; i += 1) {
        currentV = path.v[i];
        currentO = path.o[i];
        currentI = path.i[i];
        if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
          if ((i === 0 || i === len - 1) && !path.c) {
            clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
            index2 += 1;
          } else {
            if (i === 0) {
              closerV = path.v[len - 1];
            } else {
              closerV = path.v[i - 1];
            }
            distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
            newPosPerc = distance ? Math.min(distance / 2, round2) / distance : 0;
            iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
            vX = iX;
            iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
            vY = iY;
            oX = vX - (vX - currentV[0]) * roundCorner;
            oY = vY - (vY - currentV[1]) * roundCorner;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
            index2 += 1;
            if (i === len - 1) {
              closerV = path.v[0];
            } else {
              closerV = path.v[i + 1];
            }
            distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
            newPosPerc = distance ? Math.min(distance / 2, round2) / distance : 0;
            oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
            vX = oX;
            oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
            vY = oY;
            iX = vX - (vX - currentV[0]) * roundCorner;
            iY = vY - (vY - currentV[1]) * roundCorner;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
            index2 += 1;
          }
        } else {
          clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index2);
          index2 += 1;
        }
      }
      return clonedPath;
    };
    RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var rd = this.rd.v;
      if (rd !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    function floatEqual(a, b) {
      return Math.abs(a - b) * 1e5 <= Math.min(Math.abs(a), Math.abs(b));
    }
    function floatZero(f) {
      return Math.abs(f) <= 1e-5;
    }
    function lerp(p0, p1, amount) {
      return p0 * (1 - amount) + p1 * amount;
    }
    function lerpPoint(p0, p1, amount) {
      return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
    }
    function quadRoots(a, b, c) {
      if (a === 0)
        return [];
      var s = b * b - 4 * a * c;
      if (s < 0)
        return [];
      var singleRoot = -b / (2 * a);
      if (s === 0)
        return [singleRoot];
      var delta = Math.sqrt(s) / (2 * a);
      return [singleRoot - delta, singleRoot + delta];
    }
    function polynomialCoefficients(p0, p1, p2, p3) {
      return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
    }
    function singlePoint(p) {
      return new PolynomialBezier(p, p, p, p, false);
    }
    function PolynomialBezier(p0, p1, p2, p3, linearize) {
      if (linearize && pointEqual(p0, p1)) {
        p1 = lerpPoint(p0, p3, 1 / 3);
      }
      if (linearize && pointEqual(p2, p3)) {
        p2 = lerpPoint(p0, p3, 2 / 3);
      }
      var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
      var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
      this.a = [coeffx[0], coeffy[0]];
      this.b = [coeffx[1], coeffy[1]];
      this.c = [coeffx[2], coeffy[2]];
      this.d = [coeffx[3], coeffy[3]];
      this.points = [p0, p1, p2, p3];
    }
    PolynomialBezier.prototype.point = function(t) {
      return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
    };
    PolynomialBezier.prototype.derivative = function(t) {
      return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
    };
    PolynomialBezier.prototype.tangentAngle = function(t) {
      var p = this.derivative(t);
      return Math.atan2(p[1], p[0]);
    };
    PolynomialBezier.prototype.normalAngle = function(t) {
      var p = this.derivative(t);
      return Math.atan2(p[0], p[1]);
    };
    PolynomialBezier.prototype.inflectionPoints = function() {
      var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
      if (floatZero(denom))
        return [];
      var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
      var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
      if (square < 0)
        return [];
      var root = Math.sqrt(square);
      if (floatZero(root)) {
        if (root > 0 && root < 1)
          return [tcusp];
        return [];
      }
      return [tcusp - root, tcusp + root].filter(function(r) {
        return r > 0 && r < 1;
      });
    };
    PolynomialBezier.prototype.split = function(t) {
      if (t <= 0)
        return [singlePoint(this.points[0]), this];
      if (t >= 1)
        return [this, singlePoint(this.points[this.points.length - 1])];
      var p10 = lerpPoint(this.points[0], this.points[1], t);
      var p11 = lerpPoint(this.points[1], this.points[2], t);
      var p12 = lerpPoint(this.points[2], this.points[3], t);
      var p20 = lerpPoint(p10, p11, t);
      var p21 = lerpPoint(p11, p12, t);
      var p3 = lerpPoint(p20, p21, t);
      return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
    };
    function extrema(bez2, comp2) {
      var min = bez2.points[0][comp2];
      var max = bez2.points[bez2.points.length - 1][comp2];
      if (min > max) {
        var e = max;
        max = min;
        min = e;
      }
      var f = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
      for (var i = 0; i < f.length; i += 1) {
        if (f[i] > 0 && f[i] < 1) {
          var val2 = bez2.point(f[i])[comp2];
          if (val2 < min)
            min = val2;
          else if (val2 > max)
            max = val2;
        }
      }
      return {
        min,
        max
      };
    }
    PolynomialBezier.prototype.bounds = function() {
      return {
        x: extrema(this, 0),
        y: extrema(this, 1)
      };
    };
    PolynomialBezier.prototype.boundingBox = function() {
      var bounds = this.bounds();
      return {
        left: bounds.x.min,
        right: bounds.x.max,
        top: bounds.y.min,
        bottom: bounds.y.max,
        width: bounds.x.max - bounds.x.min,
        height: bounds.y.max - bounds.y.min,
        cx: (bounds.x.max + bounds.x.min) / 2,
        cy: (bounds.y.max + bounds.y.min) / 2
      };
    };
    function intersectData(bez2, t1, t2) {
      var box = bez2.boundingBox();
      return {
        cx: box.cx,
        cy: box.cy,
        width: box.width,
        height: box.height,
        bez: bez2,
        t: (t1 + t2) / 2,
        t1,
        t2
      };
    }
    function splitData(data2) {
      var split = data2.bez.split(0.5);
      return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
    }
    function boxIntersect(b1, b2) {
      return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
    }
    function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
      if (!boxIntersect(d1, d2))
        return;
      if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
        intersections.push([d1.t, d2.t]);
        return;
      }
      var d1s = splitData(d1);
      var d2s = splitData(d2);
      intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
      intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
      intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
      intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
    }
    PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
      if (tolerance === void 0)
        tolerance = 2;
      if (maxRecursion === void 0)
        maxRecursion = 7;
      var intersections = [];
      intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
      return intersections;
    };
    PolynomialBezier.shapeSegment = function(shapePath, index2) {
      var nextIndex = (index2 + 1) % shapePath.length();
      return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
    };
    PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
      var nextIndex = (index2 + 1) % shapePath.length();
      return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
    };
    function crossProduct(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }
    function lineIntersection(start1, end1, start2, end2) {
      var v1 = [start1[0], start1[1], 1];
      var v2 = [end1[0], end1[1], 1];
      var v3 = [start2[0], start2[1], 1];
      var v4 = [end2[0], end2[1], 1];
      var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
      if (floatZero(r[2]))
        return null;
      return [r[0] / r[2], r[1] / r[2]];
    }
    function polarOffset(p, angle, length2) {
      return [p[0] + Math.cos(angle) * length2, p[1] - Math.sin(angle) * length2];
    }
    function pointDistance(p1, p2) {
      return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
    }
    function pointEqual(p1, p2) {
      return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
    }
    function ZigZagModifier() {
    }
    extendPrototype([ShapeModifier], ZigZagModifier);
    ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
      this.getValue = this.processKeys;
      this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
      this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
      this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
      this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
    };
    function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
      var angO = angle - Math.PI / 2;
      var angI = angle + Math.PI / 2;
      var px = point[0] + Math.cos(angle) * direction * amplitude;
      var py = point[1] - Math.sin(angle) * direction * amplitude;
      outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
    }
    function getPerpendicularVector(pt1, pt2) {
      var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
      var rot = -Math.PI * 0.5;
      var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
      return rotatedVector;
    }
    function getProjectingAngle(path, cur) {
      var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
      var nextIndex = (cur + 1) % path.length();
      var prevPoint = path.v[prevIndex];
      var nextPoint = path.v[nextIndex];
      var pVector = getPerpendicularVector(prevPoint, nextPoint);
      return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
    }
    function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
      var angle = getProjectingAngle(path, cur);
      var point = path.v[cur % path._length];
      var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
      var nextPoint = path.v[(cur + 1) % path._length];
      var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
      var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
      setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
    }
    function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
      for (var i = 0; i < frequency; i += 1) {
        var t = (i + 1) / (frequency + 1);
        var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
        var angle = segment.normalAngle(t);
        var point = segment.point(t);
        setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
        direction = -direction;
      }
      return direction;
    }
    ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
      var count = path._length;
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      if (!path.c) {
        count -= 1;
      }
      if (count === 0)
        return clonedPath;
      var direction = -1;
      var segment = PolynomialBezier.shapeSegment(path, 0);
      zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
      for (var i = 0; i < count; i += 1) {
        direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
        if (i === count - 1 && !path.c) {
          segment = null;
        } else {
          segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
        }
        zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
      }
      return clonedPath;
    };
    ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amplitude = this.amplitude.v;
      var frequency = Math.max(0, Math.round(this.frequency.v));
      var pointType = this.pointsType.v;
      if (amplitude !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    function linearOffset(p1, p2, amount) {
      var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
      return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
    }
    function offsetSegment(segment, amount) {
      var p0;
      var p1a;
      var p1b;
      var p2b2;
      var p2a;
      var p3;
      var e;
      e = linearOffset(segment.points[0], segment.points[1], amount);
      p0 = e[0];
      p1a = e[1];
      e = linearOffset(segment.points[1], segment.points[2], amount);
      p1b = e[0];
      p2b2 = e[1];
      e = linearOffset(segment.points[2], segment.points[3], amount);
      p2a = e[0];
      p3 = e[1];
      var p1 = lineIntersection(p0, p1a, p1b, p2b2);
      if (p1 === null)
        p1 = p1a;
      var p2 = lineIntersection(p2a, p3, p1b, p2b2);
      if (p2 === null)
        p2 = p2a;
      return new PolynomialBezier(p0, p1, p2, p3);
    }
    function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
      var p0 = seg1.points[3];
      var p1 = seg2.points[0];
      if (lineJoin === 3)
        return p0;
      if (pointEqual(p0, p1))
        return p0;
      if (lineJoin === 2) {
        var angleOut = -seg1.tangentAngle(1);
        var angleIn = -seg2.tangentAngle(0) + Math.PI;
        var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
        var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
        var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
        outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
        tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
        outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
        return p1;
      }
      var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
      var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
      var intersection = lineIntersection(t0, p0, p1, t1);
      if (intersection && pointDistance(intersection, p0) < miterLimit) {
        outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
        return intersection;
      }
      return p0;
    }
    function getIntersection(a, b) {
      var intersect = a.intersections(b);
      if (intersect.length && floatEqual(intersect[0][0], 1))
        intersect.shift();
      if (intersect.length)
        return intersect[0];
      return null;
    }
    function pruneSegmentIntersection(a, b) {
      var outa = a.slice();
      var outb = b.slice();
      var intersect = getIntersection(a[a.length - 1], b[0]);
      if (intersect) {
        outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
        outb[0] = b[0].split(intersect[1])[1];
      }
      if (a.length > 1 && b.length > 1) {
        intersect = getIntersection(a[0], b[b.length - 1]);
        if (intersect) {
          return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
        }
      }
      return [outa, outb];
    }
    function pruneIntersections(segments) {
      var e;
      for (var i = 1; i < segments.length; i += 1) {
        e = pruneSegmentIntersection(segments[i - 1], segments[i]);
        segments[i - 1] = e[0];
        segments[i] = e[1];
      }
      if (segments.length > 1) {
        e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
        segments[segments.length - 1] = e[0];
        segments[0] = e[1];
      }
      return segments;
    }
    function offsetSegmentSplit(segment, amount) {
      var flex = segment.inflectionPoints();
      var left;
      var right;
      var split;
      var mid;
      if (flex.length === 0) {
        return [offsetSegment(segment, amount)];
      }
      if (flex.length === 1 || floatEqual(flex[1], 1)) {
        split = segment.split(flex[0]);
        left = split[0];
        right = split[1];
        return [offsetSegment(left, amount), offsetSegment(right, amount)];
      }
      split = segment.split(flex[0]);
      left = split[0];
      var t = (flex[1] - flex[0]) / (1 - flex[0]);
      split = split[1].split(t);
      mid = split[0];
      right = split[1];
      return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
    }
    function OffsetPathModifier() {
    }
    extendPrototype([ShapeModifier], OffsetPathModifier);
    OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
      this.getValue = this.processKeys;
      this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
      this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
      this.lineJoin = data2.lj;
      this._isAnimated = this.amount.effectsSequence.length !== 0;
    };
    OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
      var outputBezier = shapePool.newElement();
      outputBezier.c = inputBezier.c;
      var count = inputBezier.length();
      if (!inputBezier.c) {
        count -= 1;
      }
      var i;
      var j;
      var segment;
      var multiSegments = [];
      for (i = 0; i < count; i += 1) {
        segment = PolynomialBezier.shapeSegment(inputBezier, i);
        multiSegments.push(offsetSegmentSplit(segment, amount));
      }
      if (!inputBezier.c) {
        for (i = count - 1; i >= 0; i -= 1) {
          segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
          multiSegments.push(offsetSegmentSplit(segment, amount));
        }
      }
      multiSegments = pruneIntersections(multiSegments);
      var lastPoint = null;
      var lastSeg = null;
      for (i = 0; i < multiSegments.length; i += 1) {
        var multiSegment = multiSegments[i];
        if (lastSeg)
          lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
        lastSeg = multiSegment[multiSegment.length - 1];
        for (j = 0; j < multiSegment.length; j += 1) {
          segment = multiSegment[j];
          if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
            outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
          } else {
            outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
          }
          outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
          lastPoint = segment.points[3];
        }
      }
      if (multiSegments.length)
        joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
      return outputBezier;
    };
    OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amount = this.amount.v;
      var miterLimit = this.miterLimit.v;
      var lineJoin = this.lineJoin;
      if (amount !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    function getFontProperties(fontData) {
      var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
      var fWeight = "normal";
      var fStyle = "normal";
      var len = styles.length;
      var styleName;
      for (var i = 0; i < len; i += 1) {
        styleName = styles[i].toLowerCase();
        switch (styleName) {
          case "italic":
            fStyle = "italic";
            break;
          case "bold":
            fWeight = "700";
            break;
          case "black":
            fWeight = "900";
            break;
          case "medium":
            fWeight = "500";
            break;
          case "regular":
          case "normal":
            fWeight = "400";
            break;
          case "light":
          case "thin":
            fWeight = "200";
            break;
        }
      }
      return {
        style: fStyle,
        weight: fontData.fWeight || fWeight
      };
    }
    var FontManager = function() {
      var maxWaitingTime = 5e3;
      var emptyChar = {
        w: 0,
        size: 0,
        shapes: [],
        data: {
          shapes: []
        }
      };
      var combinedCharacters = [];
      combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
      var BLACK_FLAG_CODE_POINT = 127988;
      var CANCEL_TAG_CODE_POINT = 917631;
      var A_TAG_CODE_POINT = 917601;
      var Z_TAG_CODE_POINT = 917626;
      var VARIATION_SELECTOR_16_CODE_POINT = 65039;
      var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
      var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
      var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
      var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
      function trimFontOptions(font) {
        var familyArray = font.split(",");
        var i;
        var len = familyArray.length;
        var enabledFamilies = [];
        for (i = 0; i < len; i += 1) {
          if (familyArray[i] !== "sans-serif" && familyArray[i] !== "monospace") {
            enabledFamilies.push(familyArray[i]);
          }
        }
        return enabledFamilies.join(",");
      }
      function setUpNode(font, family) {
        var parentNode = createTag("span");
        parentNode.setAttribute("aria-hidden", true);
        parentNode.style.fontFamily = family;
        var node = createTag("span");
        node.innerText = "giItT1WQy@!-/#";
        parentNode.style.position = "absolute";
        parentNode.style.left = "-10000px";
        parentNode.style.top = "-10000px";
        parentNode.style.fontSize = "300px";
        parentNode.style.fontVariant = "normal";
        parentNode.style.fontStyle = "normal";
        parentNode.style.fontWeight = "normal";
        parentNode.style.letterSpacing = "0";
        parentNode.appendChild(node);
        document.body.appendChild(parentNode);
        var width2 = node.offsetWidth;
        node.style.fontFamily = trimFontOptions(font) + ", " + family;
        return {
          node,
          w: width2,
          parent: parentNode
        };
      }
      function checkLoadedFonts() {
        var i;
        var len = this.fonts.length;
        var node;
        var w;
        var loadedCount = len;
        for (i = 0; i < len; i += 1) {
          if (this.fonts[i].loaded) {
            loadedCount -= 1;
          } else if (this.fonts[i].fOrigin === "n" || this.fonts[i].origin === 0) {
            this.fonts[i].loaded = true;
          } else {
            node = this.fonts[i].monoCase.node;
            w = this.fonts[i].monoCase.w;
            if (node.offsetWidth !== w) {
              loadedCount -= 1;
              this.fonts[i].loaded = true;
            } else {
              node = this.fonts[i].sansCase.node;
              w = this.fonts[i].sansCase.w;
              if (node.offsetWidth !== w) {
                loadedCount -= 1;
                this.fonts[i].loaded = true;
              }
            }
            if (this.fonts[i].loaded) {
              this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
              this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
            }
          }
        }
        if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
          setTimeout(this.checkLoadedFontsBinded, 20);
        } else {
          setTimeout(this.setIsLoadedBinded, 10);
        }
      }
      function createHelper(fontData, def) {
        var engine = document.body && def ? "svg" : "canvas";
        var helper;
        var fontProps = getFontProperties(fontData);
        if (engine === "svg") {
          var tHelper = createNS("text");
          tHelper.style.fontSize = "100px";
          tHelper.setAttribute("font-family", fontData.fFamily);
          tHelper.setAttribute("font-style", fontProps.style);
          tHelper.setAttribute("font-weight", fontProps.weight);
          tHelper.textContent = "1";
          if (fontData.fClass) {
            tHelper.style.fontFamily = "inherit";
            tHelper.setAttribute("class", fontData.fClass);
          } else {
            tHelper.style.fontFamily = fontData.fFamily;
          }
          def.appendChild(tHelper);
          helper = tHelper;
        } else {
          var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
          tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
          helper = tCanvasHelper;
        }
        function measure(text2) {
          if (engine === "svg") {
            helper.textContent = text2;
            return helper.getComputedTextLength();
          }
          return helper.measureText(text2).width;
        }
        return {
          measureText: measure
        };
      }
      function addFonts(fontData, defs) {
        if (!fontData) {
          this.isLoaded = true;
          return;
        }
        if (this.chars) {
          this.isLoaded = true;
          this.fonts = fontData.list;
          return;
        }
        if (!document.body) {
          this.isLoaded = true;
          fontData.list.forEach(function(data2) {
            data2.helper = createHelper(data2);
            data2.cache = {};
          });
          this.fonts = fontData.list;
          return;
        }
        var fontArr = fontData.list;
        var i;
        var len = fontArr.length;
        var _pendingFonts = len;
        for (i = 0; i < len; i += 1) {
          var shouldLoadFont = true;
          var loadedSelector;
          var j;
          fontArr[i].loaded = false;
          fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, "monospace");
          fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, "sans-serif");
          if (!fontArr[i].fPath) {
            fontArr[i].loaded = true;
            _pendingFonts -= 1;
          } else if (fontArr[i].fOrigin === "p" || fontArr[i].origin === 3) {
            loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
            if (loadedSelector.length > 0) {
              shouldLoadFont = false;
            }
            if (shouldLoadFont) {
              var s = createTag("style");
              s.setAttribute("f-forigin", fontArr[i].fOrigin);
              s.setAttribute("f-origin", fontArr[i].origin);
              s.setAttribute("f-family", fontArr[i].fFamily);
              s.type = "text/css";
              s.innerText = "@font-face {font-family: " + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
              defs.appendChild(s);
            }
          } else if (fontArr[i].fOrigin === "g" || fontArr[i].origin === 1) {
            loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
            for (j = 0; j < loadedSelector.length; j += 1) {
              if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                shouldLoadFont = false;
              }
            }
            if (shouldLoadFont) {
              var l = createTag("link");
              l.setAttribute("f-forigin", fontArr[i].fOrigin);
              l.setAttribute("f-origin", fontArr[i].origin);
              l.type = "text/css";
              l.rel = "stylesheet";
              l.href = fontArr[i].fPath;
              document.body.appendChild(l);
            }
          } else if (fontArr[i].fOrigin === "t" || fontArr[i].origin === 2) {
            loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
            for (j = 0; j < loadedSelector.length; j += 1) {
              if (fontArr[i].fPath === loadedSelector[j].src) {
                shouldLoadFont = false;
              }
            }
            if (shouldLoadFont) {
              var sc = createTag("link");
              sc.setAttribute("f-forigin", fontArr[i].fOrigin);
              sc.setAttribute("f-origin", fontArr[i].origin);
              sc.setAttribute("rel", "stylesheet");
              sc.setAttribute("href", fontArr[i].fPath);
              defs.appendChild(sc);
            }
          }
          fontArr[i].helper = createHelper(fontArr[i], defs);
          fontArr[i].cache = {};
          this.fonts.push(fontArr[i]);
        }
        if (_pendingFonts === 0) {
          this.isLoaded = true;
        } else {
          setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
      }
      function addChars(chars) {
        if (!chars) {
          return;
        }
        if (!this.chars) {
          this.chars = [];
        }
        var i;
        var len = chars.length;
        var j;
        var jLen = this.chars.length;
        var found;
        for (i = 0; i < len; i += 1) {
          j = 0;
          found = false;
          while (j < jLen) {
            if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
              found = true;
            }
            j += 1;
          }
          if (!found) {
            this.chars.push(chars[i]);
            jLen += 1;
          }
        }
      }
      function getCharData(_char, style, font) {
        var i = 0;
        var len = this.chars.length;
        while (i < len) {
          if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
            return this.chars[i];
          }
          i += 1;
        }
        if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
          this._warned = true;
          console.warn("Missing character from exported characters list: ", _char, style, font);
        }
        return emptyChar;
      }
      function measureText(_char2, fontName, size) {
        var fontData = this.getFontByName(fontName);
        var index2 = _char2;
        if (!fontData.cache[index2]) {
          var tHelper = fontData.helper;
          if (_char2 === " ") {
            var doubleSize = tHelper.measureText("|" + _char2 + "|");
            var singleSize = tHelper.measureText("||");
            fontData.cache[index2] = (doubleSize - singleSize) / 100;
          } else {
            fontData.cache[index2] = tHelper.measureText(_char2) / 100;
          }
        }
        return fontData.cache[index2] * size;
      }
      function getFontByName(name2) {
        var i = 0;
        var len = this.fonts.length;
        while (i < len) {
          if (this.fonts[i].fName === name2) {
            return this.fonts[i];
          }
          i += 1;
        }
        return this.fonts[0];
      }
      function getCodePoint(string) {
        var codePoint = 0;
        var first = string.charCodeAt(0);
        if (first >= 55296 && first <= 56319) {
          var second = string.charCodeAt(1);
          if (second >= 56320 && second <= 57343) {
            codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
          }
        }
        return codePoint;
      }
      function isModifier(firstCharCode, secondCharCode) {
        var sum2 = firstCharCode.toString(16) + secondCharCode.toString(16);
        return surrogateModifiers.indexOf(sum2) !== -1;
      }
      function isZeroWidthJoiner(charCode) {
        return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
      }
      function isVariationSelector(charCode) {
        return charCode === VARIATION_SELECTOR_16_CODE_POINT;
      }
      function isRegionalCode(string) {
        var codePoint = getCodePoint(string);
        if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
          return true;
        }
        return false;
      }
      function isFlagEmoji(string) {
        return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
      }
      function isCombinedCharacter(_char3) {
        return combinedCharacters.indexOf(_char3) !== -1;
      }
      function isRegionalFlag(text2, index2) {
        var codePoint = getCodePoint(text2.substr(index2, 2));
        if (codePoint !== BLACK_FLAG_CODE_POINT) {
          return false;
        }
        var count = 0;
        index2 += 2;
        while (count < 5) {
          codePoint = getCodePoint(text2.substr(index2, 2));
          if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
            return false;
          }
          count += 1;
          index2 += 2;
        }
        return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
      }
      function setIsLoaded() {
        this.isLoaded = true;
      }
      var Font = function Font2() {
        this.fonts = [];
        this.chars = null;
        this.typekitLoaded = 0;
        this.isLoaded = false;
        this._warned = false;
        this.initTime = Date.now();
        this.setIsLoadedBinded = this.setIsLoaded.bind(this);
        this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
      };
      Font.isModifier = isModifier;
      Font.isZeroWidthJoiner = isZeroWidthJoiner;
      Font.isFlagEmoji = isFlagEmoji;
      Font.isRegionalCode = isRegionalCode;
      Font.isCombinedCharacter = isCombinedCharacter;
      Font.isRegionalFlag = isRegionalFlag;
      Font.isVariationSelector = isVariationSelector;
      Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
      var fontPrototype = {
        addChars,
        addFonts,
        getCharData,
        getFontByName,
        measureText,
        checkLoadedFonts,
        setIsLoaded
      };
      Font.prototype = fontPrototype;
      return Font;
    }();
    function SlotManager(animationData) {
      this.animationData = animationData;
    }
    SlotManager.prototype.getProp = function(data2) {
      if (this.animationData.slots && this.animationData.slots[data2.sid]) {
        return Object.assign(data2, this.animationData.slots[data2.sid].p);
      }
      return data2;
    };
    function slotFactory(animationData) {
      return new SlotManager(animationData);
    }
    function RenderableElement() {
    }
    RenderableElement.prototype = {
      initRenderable: function initRenderable() {
        this.isInRange = false;
        this.hidden = false;
        this.isTransparent = false;
        this.renderableComponents = [];
      },
      addRenderableComponent: function addRenderableComponent(component) {
        if (this.renderableComponents.indexOf(component) === -1) {
          this.renderableComponents.push(component);
        }
      },
      removeRenderableComponent: function removeRenderableComponent(component) {
        if (this.renderableComponents.indexOf(component) !== -1) {
          this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
        }
      },
      prepareRenderableFrame: function prepareRenderableFrame(num) {
        this.checkLayerLimits(num);
      },
      checkTransparency: function checkTransparency() {
        if (this.finalTransform.mProp.o.v <= 0) {
          if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
            this.isTransparent = true;
            this.hide();
          }
        } else if (this.isTransparent) {
          this.isTransparent = false;
          this.show();
        }
      },
      /**
         * @function
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         *
         */
      checkLayerLimits: function checkLayerLimits(num) {
        if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
          if (this.isInRange !== true) {
            this.globalData._mdf = true;
            this._mdf = true;
            this.isInRange = true;
            this.show();
          }
        } else if (this.isInRange !== false) {
          this.globalData._mdf = true;
          this.isInRange = false;
          this.hide();
        }
      },
      renderRenderable: function renderRenderable() {
        var i;
        var len = this.renderableComponents.length;
        for (i = 0; i < len; i += 1) {
          this.renderableComponents[i].renderFrame(this._isFirstFrame);
        }
      },
      sourceRectAtTime: function sourceRectAtTime2() {
        return {
          top: 0,
          left: 0,
          width: 100,
          height: 100
        };
      },
      getLayerSize: function getLayerSize() {
        if (this.data.ty === 5) {
          return {
            w: this.data.textData.width,
            h: this.data.textData.height
          };
        }
        return {
          w: this.data.width,
          h: this.data.height
        };
      }
    };
    var getBlendMode = /* @__PURE__ */ function() {
      var blendModeEnums = {
        0: "source-over",
        1: "multiply",
        2: "screen",
        3: "overlay",
        4: "darken",
        5: "lighten",
        6: "color-dodge",
        7: "color-burn",
        8: "hard-light",
        9: "soft-light",
        10: "difference",
        11: "exclusion",
        12: "hue",
        13: "saturation",
        14: "color",
        15: "luminosity"
      };
      return function(mode) {
        return blendModeEnums[mode] || "";
      };
    }();
    function SliderEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
    }
    function AngleEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
    }
    function ColorEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
    }
    function PointEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
    }
    function LayerIndexEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
    }
    function MaskIndexEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
    }
    function CheckboxEffect(data2, elem2, container) {
      this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
    }
    function NoValueEffect() {
      this.p = {};
    }
    function EffectsManager(data2, element) {
      var effects2 = data2.ef || [];
      this.effectElements = [];
      var i;
      var len = effects2.length;
      var effectItem;
      for (i = 0; i < len; i += 1) {
        effectItem = new GroupEffect(effects2[i], element);
        this.effectElements.push(effectItem);
      }
    }
    function GroupEffect(data2, element) {
      this.init(data2, element);
    }
    extendPrototype([DynamicPropertyContainer], GroupEffect);
    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
    GroupEffect.prototype.init = function(data2, element) {
      this.data = data2;
      this.effectElements = [];
      this.initDynamicPropertyContainer(element);
      var i;
      var len = this.data.ef.length;
      var eff;
      var effects2 = this.data.ef;
      for (i = 0; i < len; i += 1) {
        eff = null;
        switch (effects2[i].ty) {
          case 0:
            eff = new SliderEffect(effects2[i], element, this);
            break;
          case 1:
            eff = new AngleEffect(effects2[i], element, this);
            break;
          case 2:
            eff = new ColorEffect(effects2[i], element, this);
            break;
          case 3:
            eff = new PointEffect(effects2[i], element, this);
            break;
          case 4:
          case 7:
            eff = new CheckboxEffect(effects2[i], element, this);
            break;
          case 10:
            eff = new LayerIndexEffect(effects2[i], element, this);
            break;
          case 11:
            eff = new MaskIndexEffect(effects2[i], element, this);
            break;
          case 5:
            eff = new EffectsManager(effects2[i], element);
            break;
          default:
            eff = new NoValueEffect(effects2[i]);
            break;
        }
        if (eff) {
          this.effectElements.push(eff);
        }
      }
    };
    function BaseElement() {
    }
    BaseElement.prototype = {
      checkMasks: function checkMasks() {
        if (!this.data.hasMask) {
          return false;
        }
        var i = 0;
        var len = this.data.masksProperties.length;
        while (i < len) {
          if (this.data.masksProperties[i].mode !== "n" && this.data.masksProperties[i].cl !== false) {
            return true;
          }
          i += 1;
        }
        return false;
      },
      initExpressions: function initExpressions() {
        var expressionsInterfaces2 = getExpressionInterfaces();
        if (!expressionsInterfaces2) {
          return;
        }
        var LayerExpressionInterface2 = expressionsInterfaces2("layer");
        var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
        var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
        var TextExpressionInterface2 = expressionsInterfaces2("text");
        var CompExpressionInterface2 = expressionsInterfaces2("comp");
        this.layerInterface = LayerExpressionInterface2(this);
        if (this.data.hasMask && this.maskManager) {
          this.layerInterface.registerMaskInterface(this.maskManager);
        }
        var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
        this.layerInterface.registerEffectsInterface(effectsInterface);
        if (this.data.ty === 0 || this.data.xt) {
          this.compInterface = CompExpressionInterface2(this);
        } else if (this.data.ty === 4) {
          this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
          this.layerInterface.content = this.layerInterface.shapeInterface;
        } else if (this.data.ty === 5) {
          this.layerInterface.textInterface = TextExpressionInterface2(this);
          this.layerInterface.text = this.layerInterface.textInterface;
        }
      },
      setBlendMode: function setBlendMode() {
        var blendModeValue = getBlendMode(this.data.bm);
        var elem2 = this.baseElement || this.layerElement;
        elem2.style["mix-blend-mode"] = blendModeValue;
      },
      initBaseData: function initBaseData(data2, globalData2, comp2) {
        this.globalData = globalData2;
        this.comp = comp2;
        this.data = data2;
        this.layerId = createElementID();
        if (!this.data.sr) {
          this.data.sr = 1;
        }
        this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
      },
      getType: function getType() {
        return this.type;
      },
      sourceRectAtTime: function sourceRectAtTime2() {
      }
    };
    function FrameElement() {
    }
    FrameElement.prototype = {
      /**
         * @function
         * Initializes frame related properties.
         *
         */
      initFrame: function initFrame2() {
        this._isFirstFrame = false;
        this.dynamicProperties = [];
        this._mdf = false;
      },
      /**
         * @function
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         *
         */
      prepareProperties: function prepareProperties(num, isVisible) {
        var i;
        var len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          if (isVisible || this._isParent && this.dynamicProperties[i].propType === "transform") {
            this.dynamicProperties[i].getValue();
            if (this.dynamicProperties[i]._mdf) {
              this.globalData._mdf = true;
              this._mdf = true;
            }
          }
        }
      },
      addDynamicProperty: function addDynamicProperty(prop) {
        if (this.dynamicProperties.indexOf(prop) === -1) {
          this.dynamicProperties.push(prop);
        }
      }
    };
    function FootageElement(data2, globalData2, comp2) {
      this.initFrame();
      this.initRenderable();
      this.assetData = globalData2.getAssetData(data2.refId);
      this.footageData = globalData2.imageLoader.getAsset(this.assetData);
      this.initBaseData(data2, globalData2, comp2);
    }
    FootageElement.prototype.prepareFrame = function() {
    };
    extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
    FootageElement.prototype.getBaseElement = function() {
      return null;
    };
    FootageElement.prototype.renderFrame = function() {
    };
    FootageElement.prototype.destroy = function() {
    };
    FootageElement.prototype.initExpressions = function() {
      var expressionsInterfaces2 = getExpressionInterfaces();
      if (!expressionsInterfaces2) {
        return;
      }
      var FootageInterface2 = expressionsInterfaces2("footage");
      this.layerInterface = FootageInterface2(this);
    };
    FootageElement.prototype.getFootageData = function() {
      return this.footageData;
    };
    function AudioElement(data2, globalData2, comp2) {
      this.initFrame();
      this.initRenderable();
      this.assetData = globalData2.getAssetData(data2.refId);
      this.initBaseData(data2, globalData2, comp2);
      this._isPlaying = false;
      this._canPlay = false;
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      this.audio = this.globalData.audioController.createAudio(assetPath);
      this._currentTime = 0;
      this.globalData.audioController.addAudio(this);
      this._volumeMultiplier = 1;
      this._volume = 1;
      this._previousVolume = null;
      this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
        _placeholder: true
      };
      this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
        k: [100]
      }, 1, 0.01, this);
    }
    AudioElement.prototype.prepareFrame = function(num) {
      this.prepareRenderableFrame(num, true);
      this.prepareProperties(num, true);
      if (!this.tm._placeholder) {
        var timeRemapped = this.tm.v;
        this._currentTime = timeRemapped;
      } else {
        this._currentTime = num / this.data.sr;
      }
      this._volume = this.lv.v[0];
      var totalVolume = this._volume * this._volumeMultiplier;
      if (this._previousVolume !== totalVolume) {
        this._previousVolume = totalVolume;
        this.audio.volume(totalVolume);
      }
    };
    extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
    AudioElement.prototype.renderFrame = function() {
      if (this.isInRange && this._canPlay) {
        if (!this._isPlaying) {
          this.audio.play();
          this.audio.seek(this._currentTime / this.globalData.frameRate);
          this._isPlaying = true;
        } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
          this.audio.seek(this._currentTime / this.globalData.frameRate);
        }
      }
    };
    AudioElement.prototype.show = function() {
    };
    AudioElement.prototype.hide = function() {
      this.audio.pause();
      this._isPlaying = false;
    };
    AudioElement.prototype.pause = function() {
      this.audio.pause();
      this._isPlaying = false;
      this._canPlay = false;
    };
    AudioElement.prototype.resume = function() {
      this._canPlay = true;
    };
    AudioElement.prototype.setRate = function(rateValue) {
      this.audio.rate(rateValue);
    };
    AudioElement.prototype.volume = function(volumeValue) {
      this._volumeMultiplier = volumeValue;
      this._previousVolume = volumeValue * this._volume;
      this.audio.volume(this._previousVolume);
    };
    AudioElement.prototype.getBaseElement = function() {
      return null;
    };
    AudioElement.prototype.destroy = function() {
    };
    AudioElement.prototype.sourceRectAtTime = function() {
    };
    AudioElement.prototype.initExpressions = function() {
    };
    function BaseRenderer() {
    }
    BaseRenderer.prototype.checkLayers = function(num) {
      var i;
      var len = this.layers.length;
      var data2;
      this.completeLayers = true;
      for (i = len - 1; i >= 0; i -= 1) {
        if (!this.elements[i]) {
          data2 = this.layers[i];
          if (data2.ip - data2.st <= num - this.layers[i].st && data2.op - data2.st > num - this.layers[i].st) {
            this.buildItem(i);
          }
        }
        this.completeLayers = this.elements[i] ? this.completeLayers : false;
      }
      this.checkPendingElements();
    };
    BaseRenderer.prototype.createItem = function(layer) {
      switch (layer.ty) {
        case 2:
          return this.createImage(layer);
        case 0:
          return this.createComp(layer);
        case 1:
          return this.createSolid(layer);
        case 3:
          return this.createNull(layer);
        case 4:
          return this.createShape(layer);
        case 5:
          return this.createText(layer);
        case 6:
          return this.createAudio(layer);
        case 13:
          return this.createCamera(layer);
        case 15:
          return this.createFootage(layer);
        default:
          return this.createNull(layer);
      }
    };
    BaseRenderer.prototype.createCamera = function() {
      throw new Error("You're using a 3d camera. Try the html renderer.");
    };
    BaseRenderer.prototype.createAudio = function(data2) {
      return new AudioElement(data2, this.globalData, this);
    };
    BaseRenderer.prototype.createFootage = function(data2) {
      return new FootageElement(data2, this.globalData, this);
    };
    BaseRenderer.prototype.buildAllItems = function() {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        this.buildItem(i);
      }
      this.checkPendingElements();
    };
    BaseRenderer.prototype.includeLayers = function(newLayers) {
      this.completeLayers = false;
      var i;
      var len = newLayers.length;
      var j;
      var jLen = this.layers.length;
      for (i = 0; i < len; i += 1) {
        j = 0;
        while (j < jLen) {
          if (this.layers[j].id === newLayers[i].id) {
            this.layers[j] = newLayers[i];
            break;
          }
          j += 1;
        }
      }
    };
    BaseRenderer.prototype.setProjectInterface = function(pInterface) {
      this.globalData.projectInterface = pInterface;
    };
    BaseRenderer.prototype.initItems = function() {
      if (!this.globalData.progressiveLoad) {
        this.buildAllItems();
      }
    };
    BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
      var elements2 = this.elements;
      var layers = this.layers;
      var i = 0;
      var len = layers.length;
      while (i < len) {
        if (layers[i].ind == parentName) {
          if (!elements2[i] || elements2[i] === true) {
            this.buildItem(i);
            this.addPendingElement(element);
          } else {
            hierarchy.push(elements2[i]);
            elements2[i].setAsParent();
            if (layers[i].parent !== void 0) {
              this.buildElementParenting(element, layers[i].parent, hierarchy);
            } else {
              element.setHierarchy(hierarchy);
            }
          }
        }
        i += 1;
      }
    };
    BaseRenderer.prototype.addPendingElement = function(element) {
      this.pendingElements.push(element);
    };
    BaseRenderer.prototype.searchExtraCompositions = function(assets) {
      var i;
      var len = assets.length;
      for (i = 0; i < len; i += 1) {
        if (assets[i].xt) {
          var comp2 = this.createComp(assets[i]);
          comp2.initExpressions();
          this.globalData.projectInterface.registerComposition(comp2);
        }
      }
    };
    BaseRenderer.prototype.getElementById = function(ind) {
      var i;
      var len = this.elements.length;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i].data.ind === ind) {
          return this.elements[i];
        }
      }
      return null;
    };
    BaseRenderer.prototype.getElementByPath = function(path) {
      var pathValue = path.shift();
      var element;
      if (typeof pathValue === "number") {
        element = this.elements[pathValue];
      } else {
        var i;
        var len = this.elements.length;
        for (i = 0; i < len; i += 1) {
          if (this.elements[i].data.nm === pathValue) {
            element = this.elements[i];
            break;
          }
        }
      }
      if (path.length === 0) {
        return element;
      }
      return element.getElementByPath(path);
    };
    BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
      this.globalData.fontManager = new FontManager();
      this.globalData.slotManager = slotFactory(animData);
      this.globalData.fontManager.addChars(animData.chars);
      this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
      this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
      this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
      this.globalData.imageLoader = this.animationItem.imagePreloader;
      this.globalData.audioController = this.animationItem.audioController;
      this.globalData.frameId = 0;
      this.globalData.frameRate = animData.fr;
      this.globalData.nm = animData.nm;
      this.globalData.compSize = {
        w: animData.w,
        h: animData.h
      };
    };
    var effectTypes = {
      TRANSFORM_EFFECT: "transformEFfect"
    };
    function TransformElement() {
    }
    TransformElement.prototype = {
      initTransform: function initTransform() {
        var mat = new Matrix();
        this.finalTransform = {
          mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
            o: 0
          },
          _matMdf: false,
          _localMatMdf: false,
          _opMdf: false,
          mat,
          localMat: mat,
          localOpacity: 1
        };
        if (this.data.ao) {
          this.finalTransform.mProp.autoOriented = true;
        }
        if (this.data.ty !== 11)
          ;
      },
      renderTransform: function renderTransform() {
        this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
        this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
        if (this.hierarchy) {
          var mat;
          var finalMat = this.finalTransform.mat;
          var i = 0;
          var len = this.hierarchy.length;
          if (!this.finalTransform._matMdf) {
            while (i < len) {
              if (this.hierarchy[i].finalTransform.mProp._mdf) {
                this.finalTransform._matMdf = true;
                break;
              }
              i += 1;
            }
          }
          if (this.finalTransform._matMdf) {
            mat = this.finalTransform.mProp.v.props;
            finalMat.cloneFromProps(mat);
            for (i = 0; i < len; i += 1) {
              finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
            }
          }
        }
        if (this.finalTransform._matMdf) {
          this.finalTransform._localMatMdf = this.finalTransform._matMdf;
        }
        if (this.finalTransform._opMdf) {
          this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
        }
      },
      renderLocalTransform: function renderLocalTransform() {
        if (this.localTransforms) {
          var i = 0;
          var len = this.localTransforms.length;
          this.finalTransform._localMatMdf = this.finalTransform._matMdf;
          if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
            while (i < len) {
              if (this.localTransforms[i]._mdf) {
                this.finalTransform._localMatMdf = true;
              }
              if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
                this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                this.finalTransform._opMdf = true;
              }
              i += 1;
            }
          }
          if (this.finalTransform._localMatMdf) {
            var localMat = this.finalTransform.localMat;
            this.localTransforms[0].matrix.clone(localMat);
            for (i = 1; i < len; i += 1) {
              var lmat = this.localTransforms[i].matrix;
              localMat.multiply(lmat);
            }
            localMat.multiply(this.finalTransform.mat);
          }
          if (this.finalTransform._opMdf) {
            var localOp = this.finalTransform.localOpacity;
            for (i = 0; i < len; i += 1) {
              localOp *= this.localTransforms[i].opacity * 0.01;
            }
            this.finalTransform.localOpacity = localOp;
          }
        }
      },
      searchEffectTransforms: function searchEffectTransforms() {
        if (this.renderableEffectsManager) {
          var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          if (transformEffects.length) {
            this.localTransforms = [];
            this.finalTransform.localMat = new Matrix();
            var i = 0;
            var len = transformEffects.length;
            for (i = 0; i < len; i += 1) {
              this.localTransforms.push(transformEffects[i]);
            }
          }
        }
      },
      globalToLocal: function globalToLocal(pt) {
        var transforms = [];
        transforms.push(this.finalTransform);
        var flag = true;
        var comp2 = this.comp;
        while (flag) {
          if (comp2.finalTransform) {
            if (comp2.data.hasMask) {
              transforms.splice(0, 0, comp2.finalTransform);
            }
            comp2 = comp2.comp;
          } else {
            flag = false;
          }
        }
        var i;
        var len = transforms.length;
        var ptNew;
        for (i = 0; i < len; i += 1) {
          ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
          pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
        }
        return pt;
      },
      mHelper: new Matrix()
    };
    function MaskElement(data2, element, globalData2) {
      this.data = data2;
      this.element = element;
      this.globalData = globalData2;
      this.storedData = [];
      this.masksProperties = this.data.masksProperties || [];
      this.maskElement = null;
      var defs = this.globalData.defs;
      var i;
      var len = this.masksProperties ? this.masksProperties.length : 0;
      this.viewData = createSizedArray(len);
      this.solidPath = "";
      var path;
      var properties = this.masksProperties;
      var count = 0;
      var currentMasks = [];
      var j;
      var jLen;
      var layerId = createElementID();
      var rect;
      var expansor;
      var feMorph;
      var x;
      var maskType = "clipPath";
      var maskRef = "clip-path";
      for (i = 0; i < len; i += 1) {
        if (properties[i].mode !== "a" && properties[i].mode !== "n" || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
          maskType = "mask";
          maskRef = "mask";
        }
        if ((properties[i].mode === "s" || properties[i].mode === "i") && count === 0) {
          rect = createNS("rect");
          rect.setAttribute("fill", "#ffffff");
          rect.setAttribute("width", this.element.comp.data.w || 0);
          rect.setAttribute("height", this.element.comp.data.h || 0);
          currentMasks.push(rect);
        } else {
          rect = null;
        }
        path = createNS("path");
        if (properties[i].mode === "n") {
          this.viewData[i] = {
            op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
            elem: path,
            lastPath: ""
          };
          defs.appendChild(path);
        } else {
          count += 1;
          path.setAttribute("fill", properties[i].mode === "s" ? "#000000" : "#ffffff");
          path.setAttribute("clip-rule", "nonzero");
          var filterID;
          if (properties[i].x.k !== 0) {
            maskType = "mask";
            maskRef = "mask";
            x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
            filterID = createElementID();
            expansor = createNS("filter");
            expansor.setAttribute("id", filterID);
            feMorph = createNS("feMorphology");
            feMorph.setAttribute("operator", "erode");
            feMorph.setAttribute("in", "SourceGraphic");
            feMorph.setAttribute("radius", "0");
            expansor.appendChild(feMorph);
            defs.appendChild(expansor);
            path.setAttribute("stroke", properties[i].mode === "s" ? "#000000" : "#ffffff");
          } else {
            feMorph = null;
            x = null;
          }
          this.storedData[i] = {
            elem: path,
            x,
            expan: feMorph,
            lastPath: "",
            lastOperator: "",
            filterId: filterID,
            lastRadius: 0
          };
          if (properties[i].mode === "i") {
            jLen = currentMasks.length;
            var g = createNS("g");
            for (j = 0; j < jLen; j += 1) {
              g.appendChild(currentMasks[j]);
            }
            var mask2 = createNS("mask");
            mask2.setAttribute("mask-type", "alpha");
            mask2.setAttribute("id", layerId + "_" + count);
            mask2.appendChild(path);
            defs.appendChild(mask2);
            g.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
            currentMasks.length = 0;
            currentMasks.push(g);
          } else {
            currentMasks.push(path);
          }
          if (properties[i].inv && !this.solidPath) {
            this.solidPath = this.createLayerSolidPath();
          }
          this.viewData[i] = {
            elem: path,
            lastPath: "",
            op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
            invRect: rect
          };
          if (!this.viewData[i].prop.k) {
            this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
          }
        }
      }
      this.maskElement = createNS(maskType);
      len = currentMasks.length;
      for (i = 0; i < len; i += 1) {
        this.maskElement.appendChild(currentMasks[i]);
      }
      if (count > 0) {
        this.maskElement.setAttribute("id", layerId);
        this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
        defs.appendChild(this.maskElement);
      }
      if (this.viewData.length) {
        this.element.addRenderableComponent(this);
      }
    }
    MaskElement.prototype.getMaskProperty = function(pos) {
      return this.viewData[pos].prop;
    };
    MaskElement.prototype.renderFrame = function(isFirstFrame) {
      var finalMat = this.element.finalTransform.mat;
      var i;
      var len = this.masksProperties.length;
      for (i = 0; i < len; i += 1) {
        if (this.viewData[i].prop._mdf || isFirstFrame) {
          this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
        }
        if (this.viewData[i].op._mdf || isFirstFrame) {
          this.viewData[i].elem.setAttribute("fill-opacity", this.viewData[i].op.v);
        }
        if (this.masksProperties[i].mode !== "n") {
          if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
            this.viewData[i].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
          }
          if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
            var feMorph = this.storedData[i].expan;
            if (this.storedData[i].x.v < 0) {
              if (this.storedData[i].lastOperator !== "erode") {
                this.storedData[i].lastOperator = "erode";
                this.storedData[i].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i].filterId + ")");
              }
              feMorph.setAttribute("radius", -this.storedData[i].x.v);
            } else {
              if (this.storedData[i].lastOperator !== "dilate") {
                this.storedData[i].lastOperator = "dilate";
                this.storedData[i].elem.setAttribute("filter", null);
              }
              this.storedData[i].elem.setAttribute("stroke-width", this.storedData[i].x.v * 2);
            }
          }
        }
      }
    };
    MaskElement.prototype.getMaskelement = function() {
      return this.maskElement;
    };
    MaskElement.prototype.createLayerSolidPath = function() {
      var path = "M0,0 ";
      path += " h" + this.globalData.compSize.w;
      path += " v" + this.globalData.compSize.h;
      path += " h-" + this.globalData.compSize.w;
      path += " v-" + this.globalData.compSize.h + " ";
      return path;
    };
    MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
      var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
      var i;
      var len;
      len = pathNodes._length;
      for (i = 1; i < len; i += 1) {
        pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[i][0] + "," + pathNodes.i[i][1] + " " + pathNodes.v[i][0] + "," + pathNodes.v[i][1];
      }
      if (pathNodes.c && len > 1) {
        pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
      }
      if (viewData.lastPath !== pathString) {
        var pathShapeValue = "";
        if (viewData.elem) {
          if (pathNodes.c) {
            pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
          }
          viewData.elem.setAttribute("d", pathShapeValue);
        }
        viewData.lastPath = pathString;
      }
    };
    MaskElement.prototype.destroy = function() {
      this.element = null;
      this.globalData = null;
      this.maskElement = null;
      this.data = null;
      this.masksProperties = null;
    };
    var filtersFactory = function() {
      var ob2 = {};
      ob2.createFilter = createFilter;
      ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
      function createFilter(filId, skipCoordinates) {
        var fil = createNS("filter");
        fil.setAttribute("id", filId);
        if (skipCoordinates !== true) {
          fil.setAttribute("filterUnits", "objectBoundingBox");
          fil.setAttribute("x", "0%");
          fil.setAttribute("y", "0%");
          fil.setAttribute("width", "100%");
          fil.setAttribute("height", "100%");
        }
        return fil;
      }
      function createAlphaToLuminanceFilter() {
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
        return feColorMatrix;
      }
      return ob2;
    }();
    var featureSupport = function() {
      var ob2 = {
        maskType: true,
        svgLumaHidden: true,
        offscreenCanvas: typeof OffscreenCanvas !== "undefined"
      };
      if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
        ob2.maskType = false;
      }
      if (/firefox/i.test(navigator.userAgent)) {
        ob2.svgLumaHidden = false;
      }
      return ob2;
    }();
    var registeredEffects$1 = {};
    var idPrefix = "filter_result_";
    function SVGEffects(elem2) {
      var i;
      var source = "SourceGraphic";
      var len = elem2.data.ef ? elem2.data.ef.length : 0;
      var filId = createElementID();
      var fil = filtersFactory.createFilter(filId, true);
      var count = 0;
      this.filters = [];
      var filterManager;
      for (i = 0; i < len; i += 1) {
        filterManager = null;
        var type = elem2.data.ef[i].ty;
        if (registeredEffects$1[type]) {
          var Effect = registeredEffects$1[type].effect;
          filterManager = new Effect(fil, elem2.effectsManager.effectElements[i], elem2, idPrefix + count, source);
          source = idPrefix + count;
          if (registeredEffects$1[type].countsAsEffect) {
            count += 1;
          }
        }
        if (filterManager) {
          this.filters.push(filterManager);
        }
      }
      if (count) {
        elem2.globalData.defs.appendChild(fil);
        elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
      }
      if (this.filters.length) {
        elem2.addRenderableComponent(this);
      }
    }
    SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
      var i;
      var len = this.filters.length;
      for (i = 0; i < len; i += 1) {
        this.filters[i].renderFrame(_isFirstFrame);
      }
    };
    SVGEffects.prototype.getEffects = function(type) {
      var i;
      var len = this.filters.length;
      var effects2 = [];
      for (i = 0; i < len; i += 1) {
        if (this.filters[i].type === type) {
          effects2.push(this.filters[i]);
        }
      }
      return effects2;
    };
    function registerEffect$1(id, effect2, countsAsEffect) {
      registeredEffects$1[id] = {
        effect: effect2,
        countsAsEffect
      };
    }
    function SVGBaseElement() {
    }
    SVGBaseElement.prototype = {
      initRendererElement: function initRendererElement() {
        this.layerElement = createNS("g");
      },
      createContainerElements: function createContainerElements() {
        this.matteElement = createNS("g");
        this.transformedElement = this.layerElement;
        this.maskedElement = this.layerElement;
        this._sizeChanged = false;
        var layerElementParent = null;
        if (this.data.td) {
          this.matteMasks = {};
          var gg = createNS("g");
          gg.setAttribute("id", this.layerId);
          gg.appendChild(this.layerElement);
          layerElementParent = gg;
          this.globalData.defs.appendChild(gg);
        } else if (this.data.tt) {
          this.matteElement.appendChild(this.layerElement);
          layerElementParent = this.matteElement;
          this.baseElement = this.matteElement;
        } else {
          this.baseElement = this.layerElement;
        }
        if (this.data.ln) {
          this.layerElement.setAttribute("id", this.data.ln);
        }
        if (this.data.cl) {
          this.layerElement.setAttribute("class", this.data.cl);
        }
        if (this.data.ty === 0 && !this.data.hd) {
          var cp = createNS("clipPath");
          var pt = createNS("path");
          pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
          var clipId = createElementID();
          cp.setAttribute("id", clipId);
          cp.appendChild(pt);
          this.globalData.defs.appendChild(cp);
          if (this.checkMasks()) {
            var cpGroup = createNS("g");
            cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
            cpGroup.appendChild(this.layerElement);
            this.transformedElement = cpGroup;
            if (layerElementParent) {
              layerElementParent.appendChild(this.transformedElement);
            } else {
              this.baseElement = this.transformedElement;
            }
          } else {
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
          }
        }
        if (this.data.bm !== 0) {
          this.setBlendMode();
        }
      },
      renderElement: function renderElement() {
        if (this.finalTransform._localMatMdf) {
          this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
        }
        if (this.finalTransform._opMdf) {
          this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
        }
      },
      destroyBaseElement: function destroyBaseElement() {
        this.layerElement = null;
        this.matteElement = null;
        this.maskManager.destroy();
      },
      getBaseElement: function getBaseElement() {
        if (this.data.hd) {
          return null;
        }
        return this.baseElement;
      },
      createRenderableComponents: function createRenderableComponents() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
        this.renderableEffectsManager = new SVGEffects(this);
        this.searchEffectTransforms();
      },
      getMatte: function getMatte(matteType) {
        if (!this.matteMasks) {
          this.matteMasks = {};
        }
        if (!this.matteMasks[matteType]) {
          var id = this.layerId + "_" + matteType;
          var filId;
          var fil;
          var useElement;
          var gg;
          if (matteType === 1 || matteType === 3) {
            var masker = createNS("mask");
            masker.setAttribute("id", id);
            masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
            useElement = createNS("use");
            useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
            masker.appendChild(useElement);
            this.globalData.defs.appendChild(masker);
            if (!featureSupport.maskType && matteType === 1) {
              masker.setAttribute("mask-type", "luminance");
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              this.globalData.defs.appendChild(fil);
              fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
              gg = createNS("g");
              gg.appendChild(useElement);
              masker.appendChild(gg);
              gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
            }
          } else if (matteType === 2) {
            var maskGroup = createNS("mask");
            maskGroup.setAttribute("id", id);
            maskGroup.setAttribute("mask-type", "alpha");
            var maskGrouper = createNS("g");
            maskGroup.appendChild(maskGrouper);
            filId = createElementID();
            fil = filtersFactory.createFilter(filId);
            var feCTr = createNS("feComponentTransfer");
            feCTr.setAttribute("in", "SourceGraphic");
            fil.appendChild(feCTr);
            var feFunc = createNS("feFuncA");
            feFunc.setAttribute("type", "table");
            feFunc.setAttribute("tableValues", "1.0 0.0");
            feCTr.appendChild(feFunc);
            this.globalData.defs.appendChild(fil);
            var alphaRect = createNS("rect");
            alphaRect.setAttribute("width", this.comp.data.w);
            alphaRect.setAttribute("height", this.comp.data.h);
            alphaRect.setAttribute("x", "0");
            alphaRect.setAttribute("y", "0");
            alphaRect.setAttribute("fill", "#ffffff");
            alphaRect.setAttribute("opacity", "0");
            maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
            maskGrouper.appendChild(alphaRect);
            useElement = createNS("use");
            useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
            maskGrouper.appendChild(useElement);
            if (!featureSupport.maskType) {
              maskGroup.setAttribute("mask-type", "luminance");
              fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
              gg = createNS("g");
              maskGrouper.appendChild(alphaRect);
              gg.appendChild(this.layerElement);
              maskGrouper.appendChild(gg);
            }
            this.globalData.defs.appendChild(maskGroup);
          }
          this.matteMasks[matteType] = id;
        }
        return this.matteMasks[matteType];
      },
      setMatte: function setMatte(id) {
        if (!this.matteElement) {
          return;
        }
        this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
      }
    };
    function HierarchyElement() {
    }
    HierarchyElement.prototype = {
      /**
         * @function
         * Initializes hierarchy properties
         *
         */
      initHierarchy: function initHierarchy() {
        this.hierarchy = [];
        this._isParent = false;
        this.checkParenting();
      },
      /**
         * @function
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */
      setHierarchy: function setHierarchy(hierarchy) {
        this.hierarchy = hierarchy;
      },
      /**
         * @function
         * Sets layer as parent.
         *
         */
      setAsParent: function setAsParent() {
        this._isParent = true;
      },
      /**
         * @function
         * Searches layer's parenting chain
         *
         */
      checkParenting: function checkParenting() {
        if (this.data.parent !== void 0) {
          this.comp.buildElementParenting(this, this.data.parent, []);
        }
      }
    };
    function RenderableDOMElement() {
    }
    (function() {
      var _prototype = {
        initElement: function initElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initTransform(data2, globalData2, comp2);
          this.initHierarchy();
          this.initRenderable();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          this.createContent();
          this.hide();
        },
        hide: function hide() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            var elem2 = this.baseElement || this.layerElement;
            elem2.style.display = "none";
            this.hidden = true;
          }
        },
        show: function show() {
          if (this.isInRange && !this.isTransparent) {
            if (!this.data.hd) {
              var elem2 = this.baseElement || this.layerElement;
              elem2.style.display = "block";
            }
            this.hidden = false;
            this._isFirstFrame = true;
          }
        },
        renderFrame: function renderFrame() {
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderLocalTransform();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        renderInnerContent: function renderInnerContent() {
        },
        prepareFrame: function prepareFrame(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          this.checkTransparency();
        },
        destroy: function destroy() {
          this.innerElem = null;
          this.destroyBaseElement();
        }
      };
      extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
    })();
    function IImageElement(data2, globalData2, comp2) {
      this.assetData = globalData2.getAssetData(data2.refId);
      if (this.assetData && this.assetData.sid) {
        this.assetData = globalData2.slotManager.getProp(this.assetData);
      }
      this.initElement(data2, globalData2, comp2);
      this.sourceRect = {
        top: 0,
        left: 0,
        width: this.assetData.w,
        height: this.assetData.h
      };
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
    IImageElement.prototype.createContent = function() {
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      this.innerElem = createNS("image");
      this.innerElem.setAttribute("width", this.assetData.w + "px");
      this.innerElem.setAttribute("height", this.assetData.h + "px");
      this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
      this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
      this.layerElement.appendChild(this.innerElem);
    };
    IImageElement.prototype.sourceRectAtTime = function() {
      return this.sourceRect;
    };
    function ProcessedElement(element, position2) {
      this.elem = element;
      this.pos = position2;
    }
    function IShapeElement() {
    }
    IShapeElement.prototype = {
      addShapeToModifiers: function addShapeToModifiers(data2) {
        var i;
        var len = this.shapeModifiers.length;
        for (i = 0; i < len; i += 1) {
          this.shapeModifiers[i].addShape(data2);
        }
      },
      isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
        var i = 0;
        var len = this.shapeModifiers.length;
        while (i < len) {
          if (this.shapeModifiers[i].isAnimatedWithShape(data2)) {
            return true;
          }
        }
        return false;
      },
      renderModifiers: function renderModifiers() {
        if (!this.shapeModifiers.length) {
          return;
        }
        var i;
        var len = this.shapes.length;
        for (i = 0; i < len; i += 1) {
          this.shapes[i].sh.reset();
        }
        len = this.shapeModifiers.length;
        var shouldBreakProcess;
        for (i = len - 1; i >= 0; i -= 1) {
          shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
          if (shouldBreakProcess) {
            break;
          }
        }
      },
      searchProcessedElement: function searchProcessedElement(elem2) {
        var elements2 = this.processedElements;
        var i = 0;
        var len = elements2.length;
        while (i < len) {
          if (elements2[i].elem === elem2) {
            return elements2[i].pos;
          }
          i += 1;
        }
        return 0;
      },
      addProcessedElement: function addProcessedElement(elem2, pos) {
        var elements2 = this.processedElements;
        var i = elements2.length;
        while (i) {
          i -= 1;
          if (elements2[i].elem === elem2) {
            elements2[i].pos = pos;
            return;
          }
        }
        elements2.push(new ProcessedElement(elem2, pos));
      },
      prepareFrame: function prepareFrame(num) {
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      }
    };
    var lineCapEnum = {
      1: "butt",
      2: "round",
      3: "square"
    };
    var lineJoinEnum = {
      1: "miter",
      2: "round",
      3: "bevel"
    };
    function SVGShapeData(transformers, level, shape) {
      this.caches = [];
      this.styles = [];
      this.transformers = transformers;
      this.lStr = "";
      this.sh = shape;
      this.lvl = level;
      this._isAnimated = !!shape.k;
      var i = 0;
      var len = transformers.length;
      while (i < len) {
        if (transformers[i].mProps.dynamicProperties.length) {
          this._isAnimated = true;
          break;
        }
        i += 1;
      }
    }
    SVGShapeData.prototype.setAsAnimated = function() {
      this._isAnimated = true;
    };
    function SVGStyleData(data2, level) {
      this.data = data2;
      this.type = data2.ty;
      this.d = "";
      this.lvl = level;
      this._mdf = false;
      this.closed = data2.hd === true;
      this.pElem = createNS("path");
      this.msElem = null;
    }
    SVGStyleData.prototype.reset = function() {
      this.d = "";
      this._mdf = false;
    };
    function DashProperty(elem2, data2, renderer, container) {
      this.elem = elem2;
      this.frameId = -1;
      this.dataProps = createSizedArray(data2.length);
      this.renderer = renderer;
      this.k = false;
      this.dashStr = "";
      this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
      this.dashoffset = createTypedArray("float32", 1);
      this.initDynamicPropertyContainer(container);
      var i;
      var len = data2.length || 0;
      var prop;
      for (i = 0; i < len; i += 1) {
        prop = PropertyFactory.getProp(elem2, data2[i].v, 0, 0, this);
        this.k = prop.k || this.k;
        this.dataProps[i] = {
          n: data2[i].n,
          p: prop
        };
      }
      if (!this.k) {
        this.getValue(true);
      }
      this._isAnimated = this.k;
    }
    DashProperty.prototype.getValue = function(forceRender) {
      if (this.elem.globalData.frameId === this.frameId && !forceRender) {
        return;
      }
      this.frameId = this.elem.globalData.frameId;
      this.iterateDynamicProperties();
      this._mdf = this._mdf || forceRender;
      if (this._mdf) {
        var i = 0;
        var len = this.dataProps.length;
        if (this.renderer === "svg") {
          this.dashStr = "";
        }
        for (i = 0; i < len; i += 1) {
          if (this.dataProps[i].n !== "o") {
            if (this.renderer === "svg") {
              this.dashStr += " " + this.dataProps[i].p.v;
            } else {
              this.dashArray[i] = this.dataProps[i].p.v;
            }
          } else {
            this.dashoffset[0] = this.dataProps[i].p.v;
          }
        }
      }
    };
    extendPrototype([DynamicPropertyContainer], DashProperty);
    function SVGStrokeStyleData(elem2, data2, styleOb) {
      this.initDynamicPropertyContainer(elem2);
      this.getValue = this.iterateDynamicProperties;
      this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
      this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
      this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
      this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
      this.style = styleOb;
      this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
    function SVGFillStyleData(elem2, data2, styleOb) {
      this.initDynamicPropertyContainer(elem2);
      this.getValue = this.iterateDynamicProperties;
      this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
      this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
      this.style = styleOb;
    }
    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
    function SVGNoStyleData(elem2, data2, styleOb) {
      this.initDynamicPropertyContainer(elem2);
      this.getValue = this.iterateDynamicProperties;
      this.style = styleOb;
    }
    extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
    function GradientProperty(elem2, data2, container) {
      this.data = data2;
      this.c = createTypedArray("uint8c", data2.p * 4);
      var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
      this.o = createTypedArray("float32", cLength);
      this._cmdf = false;
      this._omdf = false;
      this._collapsable = this.checkCollapsable();
      this._hasOpacity = cLength;
      this.initDynamicPropertyContainer(container);
      this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
      this.k = this.prop.k;
      this.getValue(true);
    }
    GradientProperty.prototype.comparePoints = function(values, points) {
      var i = 0;
      var len = this.o.length / 2;
      var diff;
      while (i < len) {
        diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
        if (diff > 0.01) {
          return false;
        }
        i += 1;
      }
      return true;
    };
    GradientProperty.prototype.checkCollapsable = function() {
      if (this.o.length / 2 !== this.c.length / 4) {
        return false;
      }
      if (this.data.k.k[0].s) {
        var i = 0;
        var len = this.data.k.k.length;
        while (i < len) {
          if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
            return false;
          }
          i += 1;
        }
      } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
        return false;
      }
      return true;
    };
    GradientProperty.prototype.getValue = function(forceRender) {
      this.prop.getValue();
      this._mdf = false;
      this._cmdf = false;
      this._omdf = false;
      if (this.prop._mdf || forceRender) {
        var i;
        var len = this.data.p * 4;
        var mult;
        var val2;
        for (i = 0; i < len; i += 1) {
          mult = i % 4 === 0 ? 100 : 255;
          val2 = Math.round(this.prop.v[i] * mult);
          if (this.c[i] !== val2) {
            this.c[i] = val2;
            this._cmdf = !forceRender;
          }
        }
        if (this.o.length) {
          len = this.prop.v.length;
          for (i = this.data.p * 4; i < len; i += 1) {
            mult = i % 2 === 0 ? 100 : 1;
            val2 = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
            if (this.o[i - this.data.p * 4] !== val2) {
              this.o[i - this.data.p * 4] = val2;
              this._omdf = !forceRender;
            }
          }
        }
        this._mdf = !forceRender;
      }
    };
    extendPrototype([DynamicPropertyContainer], GradientProperty);
    function SVGGradientFillStyleData(elem2, data2, styleOb) {
      this.initDynamicPropertyContainer(elem2);
      this.getValue = this.iterateDynamicProperties;
      this.initGradientData(elem2, data2, styleOb);
    }
    SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
      this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
      this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
      this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
      this.h = PropertyFactory.getProp(elem2, data2.h || {
        k: 0
      }, 0, 0.01, this);
      this.a = PropertyFactory.getProp(elem2, data2.a || {
        k: 0
      }, 0, degToRads, this);
      this.g = new GradientProperty(elem2, data2.g, this);
      this.style = styleOb;
      this.stops = [];
      this.setGradientData(styleOb.pElem, data2);
      this.setGradientOpacity(data2, styleOb);
      this._isAnimated = !!this._isAnimated;
    };
    SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
      var gradientId = createElementID();
      var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
      gfill.setAttribute("id", gradientId);
      gfill.setAttribute("spreadMethod", "pad");
      gfill.setAttribute("gradientUnits", "userSpaceOnUse");
      var stops = [];
      var stop;
      var j;
      var jLen;
      jLen = data2.g.p * 4;
      for (j = 0; j < jLen; j += 4) {
        stop = createNS("stop");
        gfill.appendChild(stop);
        stops.push(stop);
      }
      pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
      this.gf = gfill;
      this.cst = stops;
    };
    SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
      if (this.g._hasOpacity && !this.g._collapsable) {
        var stop;
        var j;
        var jLen;
        var mask2 = createNS("mask");
        var maskElement = createNS("path");
        mask2.appendChild(maskElement);
        var opacityId = createElementID();
        var maskId = createElementID();
        mask2.setAttribute("id", maskId);
        var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
        opFill.setAttribute("id", opacityId);
        opFill.setAttribute("spreadMethod", "pad");
        opFill.setAttribute("gradientUnits", "userSpaceOnUse");
        jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
        var stops = this.stops;
        for (j = data2.g.p * 4; j < jLen; j += 2) {
          stop = createNS("stop");
          stop.setAttribute("stop-color", "rgb(255,255,255)");
          opFill.appendChild(stop);
          stops.push(stop);
        }
        maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
        if (data2.ty === "gs") {
          maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
          maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
          if (data2.lj === 1) {
            maskElement.setAttribute("stroke-miterlimit", data2.ml);
          }
        }
        this.of = opFill;
        this.ms = mask2;
        this.ost = stops;
        this.maskId = maskId;
        styleOb.msElem = maskElement;
      }
    };
    extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
      this.initDynamicPropertyContainer(elem2);
      this.getValue = this.iterateDynamicProperties;
      this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
      this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
      this.initGradientData(elem2, data2, styleOb);
      this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
      this.it = [];
      this.prevViewData = [];
      this.gr = createNS("g");
    }
    function SVGTransformData(mProps, op, container) {
      this.transform = {
        mProps,
        op,
        container
      };
      this.elements = [];
      this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
      if (length2 === 0) {
        return "";
      }
      var _o = pathNodes.o;
      var _i = pathNodes.i;
      var _v = pathNodes.v;
      var i;
      var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
      for (i = 1; i < length2; i += 1) {
        shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
      }
      if (closed && length2) {
        shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        shapeString += "z";
      }
      return shapeString;
    };
    var SVGElementsRenderer = function() {
      var _identityMatrix = new Matrix();
      var _matrixHelper = new Matrix();
      var ob2 = {
        createRenderFunction
      };
      function createRenderFunction(data2) {
        switch (data2.ty) {
          case "fl":
            return renderFill;
          case "gf":
            return renderGradient;
          case "gs":
            return renderGradientStroke;
          case "st":
            return renderStroke;
          case "sh":
          case "el":
          case "rc":
          case "sr":
            return renderPath;
          case "tr":
            return renderContentTransform;
          case "no":
            return renderNoop;
          default:
            return null;
        }
      }
      function renderContentTransform(styleData, itemData, isFirstFrame) {
        if (isFirstFrame || itemData.transform.op._mdf) {
          itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
        }
        if (isFirstFrame || itemData.transform.mProps._mdf) {
          itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
        }
      }
      function renderNoop() {
      }
      function renderPath(styleData, itemData, isFirstFrame) {
        var j;
        var jLen;
        var pathStringTransformed;
        var redraw;
        var pathNodes;
        var l;
        var lLen = itemData.styles.length;
        var lvl = itemData.lvl;
        var paths;
        var mat;
        var iterations;
        var k;
        for (l = 0; l < lLen; l += 1) {
          redraw = itemData.sh._mdf || isFirstFrame;
          if (itemData.styles[l].lvl < lvl) {
            mat = _matrixHelper.reset();
            iterations = lvl - itemData.styles[l].lvl;
            k = itemData.transformers.length - 1;
            while (!redraw && iterations > 0) {
              redraw = itemData.transformers[k].mProps._mdf || redraw;
              iterations -= 1;
              k -= 1;
            }
            if (redraw) {
              iterations = lvl - itemData.styles[l].lvl;
              k = itemData.transformers.length - 1;
              while (iterations > 0) {
                mat.multiply(itemData.transformers[k].mProps.v);
                iterations -= 1;
                k -= 1;
              }
            }
          } else {
            mat = _identityMatrix;
          }
          paths = itemData.sh.paths;
          jLen = paths._length;
          if (redraw) {
            pathStringTransformed = "";
            for (j = 0; j < jLen; j += 1) {
              pathNodes = paths.shapes[j];
              if (pathNodes && pathNodes._length) {
                pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
              }
            }
            itemData.caches[l] = pathStringTransformed;
          } else {
            pathStringTransformed = itemData.caches[l];
          }
          itemData.styles[l].d += styleData.hd === true ? "" : pathStringTransformed;
          itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
        }
      }
      function renderFill(styleData, itemData, isFirstFrame) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
        }
        if (itemData.o._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
        }
      }
      function renderGradientStroke(styleData, itemData, isFirstFrame) {
        renderGradient(styleData, itemData, isFirstFrame);
        renderStroke(styleData, itemData, isFirstFrame);
      }
      function renderGradient(styleData, itemData, isFirstFrame) {
        var gfill = itemData.gf;
        var hasOpacity = itemData.g._hasOpacity;
        var pt1 = itemData.s.v;
        var pt2 = itemData.e.v;
        if (itemData.o._mdf || isFirstFrame) {
          var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
          itemData.style.pElem.setAttribute(attr, itemData.o.v);
        }
        if (itemData.s._mdf || isFirstFrame) {
          var attr1 = styleData.t === 1 ? "x1" : "cx";
          var attr2 = attr1 === "x1" ? "y1" : "cy";
          gfill.setAttribute(attr1, pt1[0]);
          gfill.setAttribute(attr2, pt1[1]);
          if (hasOpacity && !itemData.g._collapsable) {
            itemData.of.setAttribute(attr1, pt1[0]);
            itemData.of.setAttribute(attr2, pt1[1]);
          }
        }
        var stops;
        var i;
        var len;
        var stop;
        if (itemData.g._cmdf || isFirstFrame) {
          stops = itemData.cst;
          var cValues = itemData.g.c;
          len = stops.length;
          for (i = 0; i < len; i += 1) {
            stop = stops[i];
            stop.setAttribute("offset", cValues[i * 4] + "%");
            stop.setAttribute("stop-color", "rgb(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + ")");
          }
        }
        if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
          var oValues = itemData.g.o;
          if (itemData.g._collapsable) {
            stops = itemData.cst;
          } else {
            stops = itemData.ost;
          }
          len = stops.length;
          for (i = 0; i < len; i += 1) {
            stop = stops[i];
            if (!itemData.g._collapsable) {
              stop.setAttribute("offset", oValues[i * 2] + "%");
            }
            stop.setAttribute("stop-opacity", oValues[i * 2 + 1]);
          }
        }
        if (styleData.t === 1) {
          if (itemData.e._mdf || isFirstFrame) {
            gfill.setAttribute("x2", pt2[0]);
            gfill.setAttribute("y2", pt2[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute("x2", pt2[0]);
              itemData.of.setAttribute("y2", pt2[1]);
            }
          }
        } else {
          var rad;
          if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            gfill.setAttribute("r", rad);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute("r", rad);
            }
          }
          if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
            if (!rad) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            }
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            gfill.setAttribute("fx", x);
            gfill.setAttribute("fy", y);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute("fx", x);
              itemData.of.setAttribute("fy", y);
            }
          }
        }
      }
      function renderStroke(styleData, itemData, isFirstFrame) {
        var styleElem = itemData.style;
        var d = itemData.d;
        if (d && (d._mdf || isFirstFrame) && d.dashStr) {
          styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
          styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0]);
        }
        if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
          styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
        }
        if (itemData.o._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
        }
        if (itemData.w._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
          if (styleElem.msElem) {
            styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
          }
        }
      }
      return ob2;
    }();
    function SVGShapeElement(data2, globalData2, comp2) {
      this.shapes = [];
      this.shapesData = data2.shapes;
      this.stylesList = [];
      this.shapeModifiers = [];
      this.itemsData = [];
      this.processedElements = [];
      this.animatedContents = [];
      this.initElement(data2, globalData2, comp2);
      this.prevViewData = [];
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
    SVGShapeElement.prototype.initSecondaryElement = function() {
    };
    SVGShapeElement.prototype.identityMatrix = new Matrix();
    SVGShapeElement.prototype.buildExpressionInterface = function() {
    };
    SVGShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
      this.filterUniqueShapes();
    };
    SVGShapeElement.prototype.filterUniqueShapes = function() {
      var i;
      var len = this.shapes.length;
      var shape;
      var j;
      var jLen = this.stylesList.length;
      var style;
      var tempShapes = [];
      var areAnimated = false;
      for (j = 0; j < jLen; j += 1) {
        style = this.stylesList[j];
        areAnimated = false;
        tempShapes.length = 0;
        for (i = 0; i < len; i += 1) {
          shape = this.shapes[i];
          if (shape.styles.indexOf(style) !== -1) {
            tempShapes.push(shape);
            areAnimated = shape._isAnimated || areAnimated;
          }
        }
        if (tempShapes.length > 1 && areAnimated) {
          this.setShapesAsAnimated(tempShapes);
        }
      }
    };
    SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
      var i;
      var len = shapes.length;
      for (i = 0; i < len; i += 1) {
        shapes[i].setAsAnimated();
      }
    };
    SVGShapeElement.prototype.createStyleElement = function(data2, level) {
      var elementData;
      var styleOb = new SVGStyleData(data2, level);
      var pathElement = styleOb.pElem;
      if (data2.ty === "st") {
        elementData = new SVGStrokeStyleData(this, data2, styleOb);
      } else if (data2.ty === "fl") {
        elementData = new SVGFillStyleData(this, data2, styleOb);
      } else if (data2.ty === "gf" || data2.ty === "gs") {
        var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
        elementData = new GradientConstructor(this, data2, styleOb);
        this.globalData.defs.appendChild(elementData.gf);
        if (elementData.maskId) {
          this.globalData.defs.appendChild(elementData.ms);
          this.globalData.defs.appendChild(elementData.of);
          pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
        }
      } else if (data2.ty === "no") {
        elementData = new SVGNoStyleData(this, data2, styleOb);
      }
      if (data2.ty === "st" || data2.ty === "gs") {
        pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
        pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
        pathElement.setAttribute("fill-opacity", "0");
        if (data2.lj === 1) {
          pathElement.setAttribute("stroke-miterlimit", data2.ml);
        }
      }
      if (data2.r === 2) {
        pathElement.setAttribute("fill-rule", "evenodd");
      }
      if (data2.ln) {
        pathElement.setAttribute("id", data2.ln);
      }
      if (data2.cl) {
        pathElement.setAttribute("class", data2.cl);
      }
      if (data2.bm) {
        pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
      }
      this.stylesList.push(styleOb);
      this.addToAnimatedContents(data2, elementData);
      return elementData;
    };
    SVGShapeElement.prototype.createGroupElement = function(data2) {
      var elementData = new ShapeGroupData();
      if (data2.ln) {
        elementData.gr.setAttribute("id", data2.ln);
      }
      if (data2.cl) {
        elementData.gr.setAttribute("class", data2.cl);
      }
      if (data2.bm) {
        elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
      }
      return elementData;
    };
    SVGShapeElement.prototype.createTransformElement = function(data2, container) {
      var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
      var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
      this.addToAnimatedContents(data2, elementData);
      return elementData;
    };
    SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
      var ty = 4;
      if (data2.ty === "rc") {
        ty = 5;
      } else if (data2.ty === "el") {
        ty = 6;
      } else if (data2.ty === "sr") {
        ty = 7;
      }
      var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
      var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
      this.shapes.push(elementData);
      this.addShapeToModifiers(elementData);
      this.addToAnimatedContents(data2, elementData);
      return elementData;
    };
    SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
      var i = 0;
      var len = this.animatedContents.length;
      while (i < len) {
        if (this.animatedContents[i].element === element) {
          return;
        }
        i += 1;
      }
      this.animatedContents.push({
        fn: SVGElementsRenderer.createRenderFunction(data2),
        element,
        data: data2
      });
    };
    SVGShapeElement.prototype.setElementStyles = function(elementData) {
      var arr = elementData.styles;
      var j;
      var jLen = this.stylesList.length;
      for (j = 0; j < jLen; j += 1) {
        if (!this.stylesList[j].closed) {
          arr.push(this.stylesList[j]);
        }
      }
    };
    SVGShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = true;
      var i;
      var len = this.itemsData.length;
      for (i = 0; i < len; i += 1) {
        this.prevViewData[i] = this.itemsData[i];
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
      this.filterUniqueShapes();
      len = this.dynamicProperties.length;
      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();
      }
      this.renderModifiers();
    };
    SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render2) {
      var ownTransformers = [].concat(transformers);
      var i;
      var len = arr.length - 1;
      var j;
      var jLen;
      var ownStyles = [];
      var ownModifiers = [];
      var currentTransform;
      var modifier;
      var processedPos;
      for (i = len; i >= 0; i -= 1) {
        processedPos = this.searchProcessedElement(arr[i]);
        if (!processedPos) {
          arr[i]._render = render2;
        } else {
          itemsData[i] = prevViewData[processedPos - 1];
        }
        if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs" || arr[i].ty === "no") {
          if (!processedPos) {
            itemsData[i] = this.createStyleElement(arr[i], level);
          } else {
            itemsData[i].style.closed = false;
          }
          if (arr[i]._render) {
            if (itemsData[i].style.pElem.parentNode !== container) {
              container.appendChild(itemsData[i].style.pElem);
            }
          }
          ownStyles.push(itemsData[i].style);
        } else if (arr[i].ty === "gr") {
          if (!processedPos) {
            itemsData[i] = this.createGroupElement(arr[i]);
          } else {
            jLen = itemsData[i].it.length;
            for (j = 0; j < jLen; j += 1) {
              itemsData[i].prevViewData[j] = itemsData[i].it[j];
            }
          }
          this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render2);
          if (arr[i]._render) {
            if (itemsData[i].gr.parentNode !== container) {
              container.appendChild(itemsData[i].gr);
            }
          }
        } else if (arr[i].ty === "tr") {
          if (!processedPos) {
            itemsData[i] = this.createTransformElement(arr[i], container);
          }
          currentTransform = itemsData[i].transform;
          ownTransformers.push(currentTransform);
        } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
          if (!processedPos) {
            itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
          }
          this.setElementStyles(itemsData[i]);
        } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "ms" || arr[i].ty === "pb" || arr[i].ty === "zz" || arr[i].ty === "op") {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            modifier.init(this, arr[i]);
            itemsData[i] = modifier;
            this.shapeModifiers.push(modifier);
          } else {
            modifier = itemsData[i];
            modifier.closed = false;
          }
          ownModifiers.push(modifier);
        } else if (arr[i].ty === "rp") {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            itemsData[i] = modifier;
            modifier.init(this, arr, i, itemsData);
            this.shapeModifiers.push(modifier);
            render2 = false;
          } else {
            modifier = itemsData[i];
            modifier.closed = true;
          }
          ownModifiers.push(modifier);
        }
        this.addProcessedElement(arr[i], i + 1);
      }
      len = ownStyles.length;
      for (i = 0; i < len; i += 1) {
        ownStyles[i].closed = true;
      }
      len = ownModifiers.length;
      for (i = 0; i < len; i += 1) {
        ownModifiers[i].closed = true;
      }
    };
    SVGShapeElement.prototype.renderInnerContent = function() {
      this.renderModifiers();
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        this.stylesList[i].reset();
      }
      this.renderShape();
      for (i = 0; i < len; i += 1) {
        if (this.stylesList[i]._mdf || this._isFirstFrame) {
          if (this.stylesList[i].msElem) {
            this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d);
            this.stylesList[i].d = "M0 0" + this.stylesList[i].d;
          }
          this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0");
        }
      }
    };
    SVGShapeElement.prototype.renderShape = function() {
      var i;
      var len = this.animatedContents.length;
      var animatedContent;
      for (i = 0; i < len; i += 1) {
        animatedContent = this.animatedContents[i];
        if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
          animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
        }
      }
    };
    SVGShapeElement.prototype.destroy = function() {
      this.destroyBaseElement();
      this.shapesData = null;
      this.itemsData = null;
    };
    function LetterProps(o, sw, sc, fc, m, p) {
      this.o = o;
      this.sw = sw;
      this.sc = sc;
      this.fc = fc;
      this.m = m;
      this.p = p;
      this._mdf = {
        o: true,
        sw: !!sw,
        sc: !!sc,
        fc: !!fc,
        m: true,
        p: true
      };
    }
    LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
      this._mdf.o = false;
      this._mdf.sw = false;
      this._mdf.sc = false;
      this._mdf.fc = false;
      this._mdf.m = false;
      this._mdf.p = false;
      var updated = false;
      if (this.o !== o) {
        this.o = o;
        this._mdf.o = true;
        updated = true;
      }
      if (this.sw !== sw) {
        this.sw = sw;
        this._mdf.sw = true;
        updated = true;
      }
      if (this.sc !== sc) {
        this.sc = sc;
        this._mdf.sc = true;
        updated = true;
      }
      if (this.fc !== fc) {
        this.fc = fc;
        this._mdf.fc = true;
        updated = true;
      }
      if (this.m !== m) {
        this.m = m;
        this._mdf.m = true;
        updated = true;
      }
      if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
        this.p = p;
        this._mdf.p = true;
        updated = true;
      }
      return updated;
    };
    function TextProperty(elem2, data2) {
      this._frameId = initialDefaultFrame;
      this.pv = "";
      this.v = "";
      this.kf = false;
      this._isFirstFrame = true;
      this._mdf = false;
      if (data2.d && data2.d.sid) {
        data2.d = elem2.globalData.slotManager.getProp(data2.d);
      }
      this.data = data2;
      this.elem = elem2;
      this.comp = this.elem.comp;
      this.keysIndex = 0;
      this.canResize = false;
      this.minimumFontSize = 1;
      this.effectsSequence = [];
      this.currentData = {
        ascent: 0,
        boxWidth: this.defaultBoxWidth,
        f: "",
        fStyle: "",
        fWeight: "",
        fc: "",
        j: "",
        justifyOffset: "",
        l: [],
        lh: 0,
        lineWidths: [],
        ls: "",
        of: "",
        s: "",
        sc: "",
        sw: 0,
        t: 0,
        tr: 0,
        sz: 0,
        ps: null,
        fillColorAnim: false,
        strokeColorAnim: false,
        strokeWidthAnim: false,
        yOffset: 0,
        finalSize: 0,
        finalText: [],
        finalLineHeight: 0,
        __complete: false
      };
      this.copyData(this.currentData, this.data.d.k[0].s);
      if (!this.searchProperty()) {
        this.completeTextData(this.currentData);
      }
    }
    TextProperty.prototype.defaultBoxWidth = [0, 0];
    TextProperty.prototype.copyData = function(obj, data2) {
      for (var s in data2) {
        if (Object.prototype.hasOwnProperty.call(data2, s)) {
          obj[s] = data2[s];
        }
      }
      return obj;
    };
    TextProperty.prototype.setCurrentData = function(data2) {
      if (!data2.__complete) {
        this.completeTextData(data2);
      }
      this.currentData = data2;
      this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
      this._mdf = true;
    };
    TextProperty.prototype.searchProperty = function() {
      return this.searchKeyframes();
    };
    TextProperty.prototype.searchKeyframes = function() {
      this.kf = this.data.d.k.length > 1;
      if (this.kf) {
        this.addEffect(this.getKeyframeValue.bind(this));
      }
      return this.kf;
    };
    TextProperty.prototype.addEffect = function(effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.getValue = function(_finalValue) {
      if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
        return;
      }
      this.currentData.t = this.data.d.k[this.keysIndex].s.t;
      var currentValue = this.currentData;
      var currentIndex = this.keysIndex;
      if (this.lock) {
        this.setCurrentData(this.currentData);
        return;
      }
      this.lock = true;
      this._mdf = false;
      var i;
      var len = this.effectsSequence.length;
      var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
      for (i = 0; i < len; i += 1) {
        if (currentIndex !== this.keysIndex) {
          finalValue = this.effectsSequence[i](finalValue, finalValue.t);
        } else {
          finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
        }
      }
      if (currentValue !== finalValue) {
        this.setCurrentData(finalValue);
      }
      this.v = this.currentData;
      this.pv = this.v;
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    };
    TextProperty.prototype.getKeyframeValue = function() {
      var textKeys = this.data.d.k;
      var frameNum = this.elem.comp.renderedFrame;
      var i = 0;
      var len = textKeys.length;
      while (i <= len - 1) {
        if (i === len - 1 || textKeys[i + 1].t > frameNum) {
          break;
        }
        i += 1;
      }
      if (this.keysIndex !== i) {
        this.keysIndex = i;
      }
      return this.data.d.k[this.keysIndex].s;
    };
    TextProperty.prototype.buildFinalText = function(text2) {
      var charactersArray = [];
      var i = 0;
      var len = text2.length;
      var charCode;
      var secondCharCode;
      var shouldCombine = false;
      var shouldCombineNext = false;
      var currentChars = "";
      while (i < len) {
        shouldCombine = shouldCombineNext;
        shouldCombineNext = false;
        charCode = text2.charCodeAt(i);
        currentChars = text2.charAt(i);
        if (FontManager.isCombinedCharacter(charCode)) {
          shouldCombine = true;
        } else if (charCode >= 55296 && charCode <= 56319) {
          if (FontManager.isRegionalFlag(text2, i)) {
            currentChars = text2.substr(i, 14);
          } else {
            secondCharCode = text2.charCodeAt(i + 1);
            if (secondCharCode >= 56320 && secondCharCode <= 57343) {
              if (FontManager.isModifier(charCode, secondCharCode)) {
                currentChars = text2.substr(i, 2);
                shouldCombine = true;
              } else if (FontManager.isFlagEmoji(text2.substr(i, 4))) {
                currentChars = text2.substr(i, 4);
              } else {
                currentChars = text2.substr(i, 2);
              }
            }
          }
        } else if (charCode > 56319) {
          secondCharCode = text2.charCodeAt(i + 1);
          if (FontManager.isVariationSelector(charCode)) {
            shouldCombine = true;
          }
        } else if (FontManager.isZeroWidthJoiner(charCode)) {
          shouldCombine = true;
          shouldCombineNext = true;
        }
        if (shouldCombine) {
          charactersArray[charactersArray.length - 1] += currentChars;
          shouldCombine = false;
        } else {
          charactersArray.push(currentChars);
        }
        i += currentChars.length;
      }
      return charactersArray;
    };
    TextProperty.prototype.completeTextData = function(documentData) {
      documentData.__complete = true;
      var fontManager = this.elem.globalData.fontManager;
      var data2 = this.data;
      var letters = [];
      var i;
      var len;
      var newLineFlag;
      var index2 = 0;
      var val2;
      var anchorGrouping = data2.m.g;
      var currentSize = 0;
      var currentPos = 0;
      var currentLine = 0;
      var lineWidths = [];
      var lineWidth = 0;
      var maxLineWidth = 0;
      var j;
      var jLen;
      var fontData = fontManager.getFontByName(documentData.f);
      var charData;
      var cLength = 0;
      var fontProps = getFontProperties(fontData);
      documentData.fWeight = fontProps.weight;
      documentData.fStyle = fontProps.style;
      documentData.finalSize = documentData.s;
      documentData.finalText = this.buildFinalText(documentData.t);
      len = documentData.finalText.length;
      documentData.finalLineHeight = documentData.lh;
      var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
      var charCode;
      if (documentData.sz) {
        var flag = true;
        var boxWidth = documentData.sz[0];
        var boxHeight = documentData.sz[1];
        var currentHeight;
        var finalText;
        while (flag) {
          finalText = this.buildFinalText(documentData.t);
          currentHeight = 0;
          lineWidth = 0;
          len = finalText.length;
          trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
          var lastSpaceIndex = -1;
          for (i = 0; i < len; i += 1) {
            charCode = finalText[i].charCodeAt(0);
            newLineFlag = false;
            if (finalText[i] === " ") {
              lastSpaceIndex = i;
            } else if (charCode === 13 || charCode === 3) {
              lineWidth = 0;
              newLineFlag = true;
              currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
            }
            if (fontManager.chars) {
              charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
              cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
            } else {
              cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
            }
            if (lineWidth + cLength > boxWidth && finalText[i] !== " ") {
              if (lastSpaceIndex === -1) {
                len += 1;
              } else {
                i = lastSpaceIndex;
              }
              currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r");
              lastSpaceIndex = -1;
              lineWidth = 0;
            } else {
              lineWidth += cLength;
              lineWidth += trackingOffset;
            }
          }
          currentHeight += fontData.ascent * documentData.finalSize / 100;
          if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
            documentData.finalSize -= 1;
            documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
          } else {
            documentData.finalText = finalText;
            len = documentData.finalText.length;
            flag = false;
          }
        }
      }
      lineWidth = -trackingOffset;
      cLength = 0;
      var uncollapsedSpaces = 0;
      var currentChar;
      for (i = 0; i < len; i += 1) {
        newLineFlag = false;
        currentChar = documentData.finalText[i];
        charCode = currentChar.charCodeAt(0);
        if (charCode === 13 || charCode === 3) {
          uncollapsedSpaces = 0;
          lineWidths.push(lineWidth);
          maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
          lineWidth = -2 * trackingOffset;
          val2 = "";
          newLineFlag = true;
          currentLine += 1;
        } else {
          val2 = currentChar;
        }
        if (fontManager.chars) {
          charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
          cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
        } else {
          cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
        }
        if (currentChar === " ") {
          uncollapsedSpaces += cLength + trackingOffset;
        } else {
          lineWidth += cLength + trackingOffset + uncollapsedSpaces;
          uncollapsedSpaces = 0;
        }
        letters.push({
          l: cLength,
          an: cLength,
          add: currentSize,
          n: newLineFlag,
          anIndexes: [],
          val: val2,
          line: currentLine,
          animatorJustifyOffset: 0
        });
        if (anchorGrouping == 2) {
          currentSize += cLength;
          if (val2 === "" || val2 === " " || i === len - 1) {
            if (val2 === "" || val2 === " ") {
              currentSize -= cLength;
            }
            while (currentPos <= i) {
              letters[currentPos].an = currentSize;
              letters[currentPos].ind = index2;
              letters[currentPos].extra = cLength;
              currentPos += 1;
            }
            index2 += 1;
            currentSize = 0;
          }
        } else if (anchorGrouping == 3) {
          currentSize += cLength;
          if (val2 === "" || i === len - 1) {
            if (val2 === "") {
              currentSize -= cLength;
            }
            while (currentPos <= i) {
              letters[currentPos].an = currentSize;
              letters[currentPos].ind = index2;
              letters[currentPos].extra = cLength;
              currentPos += 1;
            }
            currentSize = 0;
            index2 += 1;
          }
        } else {
          letters[index2].ind = index2;
          letters[index2].extra = 0;
          index2 += 1;
        }
      }
      documentData.l = letters;
      maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
      lineWidths.push(lineWidth);
      if (documentData.sz) {
        documentData.boxWidth = documentData.sz[0];
        documentData.justifyOffset = 0;
      } else {
        documentData.boxWidth = maxLineWidth;
        switch (documentData.j) {
          case 1:
            documentData.justifyOffset = -documentData.boxWidth;
            break;
          case 2:
            documentData.justifyOffset = -documentData.boxWidth / 2;
            break;
          default:
            documentData.justifyOffset = 0;
        }
      }
      documentData.lineWidths = lineWidths;
      var animators = data2.a;
      var animatorData;
      var letterData;
      jLen = animators.length;
      var based;
      var ind;
      var indexes = [];
      for (j = 0; j < jLen; j += 1) {
        animatorData = animators[j];
        if (animatorData.a.sc) {
          documentData.strokeColorAnim = true;
        }
        if (animatorData.a.sw) {
          documentData.strokeWidthAnim = true;
        }
        if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
          documentData.fillColorAnim = true;
        }
        ind = 0;
        based = animatorData.s.b;
        for (i = 0; i < len; i += 1) {
          letterData = letters[i];
          letterData.anIndexes[j] = ind;
          if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
            if (animatorData.s.rn === 1) {
              indexes.push(ind);
            }
            ind += 1;
          }
        }
        data2.a[j].s.totalChars = ind;
        var currentInd = -1;
        var newInd;
        if (animatorData.s.rn === 1) {
          for (i = 0; i < len; i += 1) {
            letterData = letters[i];
            if (currentInd != letterData.anIndexes[j]) {
              currentInd = letterData.anIndexes[j];
              newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
            }
            letterData.anIndexes[j] = newInd;
          }
        }
      }
      documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
      documentData.ls = documentData.ls || 0;
      documentData.ascent = fontData.ascent * documentData.finalSize / 100;
    };
    TextProperty.prototype.updateDocumentData = function(newData, index2) {
      index2 = index2 === void 0 ? this.keysIndex : index2;
      var dData = this.copyData({}, this.data.d.k[index2].s);
      dData = this.copyData(dData, newData);
      this.data.d.k[index2].s = dData;
      this.recalculate(index2);
      this.setCurrentData(dData);
      this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.recalculate = function(index2) {
      var dData = this.data.d.k[index2].s;
      dData.__complete = false;
      this.keysIndex = 0;
      this._isFirstFrame = true;
      this.getValue(dData);
    };
    TextProperty.prototype.canResizeFont = function(_canResize) {
      this.canResize = _canResize;
      this.recalculate(this.keysIndex);
      this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
      this.minimumFontSize = Math.floor(_fontValue) || 1;
      this.recalculate(this.keysIndex);
      this.elem.addDynamicProperty(this);
    };
    var TextSelectorProp = function() {
      var max = Math.max;
      var min = Math.min;
      var floor = Math.floor;
      function TextSelectorPropFactory(elem2, data2) {
        this._currentTextLength = -1;
        this.k = false;
        this.data = data2;
        this.elem = elem2;
        this.comp = elem2.comp;
        this.finalS = 0;
        this.finalE = 0;
        this.initDynamicPropertyContainer(elem2);
        this.s = PropertyFactory.getProp(elem2, data2.s || {
          k: 0
        }, 0, 0, this);
        if ("e" in data2) {
          this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
        } else {
          this.e = {
            v: 100
          };
        }
        this.o = PropertyFactory.getProp(elem2, data2.o || {
          k: 0
        }, 0, 0, this);
        this.xe = PropertyFactory.getProp(elem2, data2.xe || {
          k: 0
        }, 0, 0, this);
        this.ne = PropertyFactory.getProp(elem2, data2.ne || {
          k: 0
        }, 0, 0, this);
        this.sm = PropertyFactory.getProp(elem2, data2.sm || {
          k: 100
        }, 0, 0, this);
        this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
        if (!this.dynamicProperties.length) {
          this.getValue();
        }
      }
      TextSelectorPropFactory.prototype = {
        getMult: function getMult(ind) {
          if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
            this.getValue();
          }
          var x1 = 0;
          var y1 = 0;
          var x2 = 1;
          var y2 = 1;
          if (this.ne.v > 0) {
            x1 = this.ne.v / 100;
          } else {
            y1 = -this.ne.v / 100;
          }
          if (this.xe.v > 0) {
            x2 = 1 - this.xe.v / 100;
          } else {
            y2 = 1 + this.xe.v / 100;
          }
          var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
          var mult = 0;
          var s = this.finalS;
          var e = this.finalE;
          var type = this.data.sh;
          if (type === 2) {
            if (e === s) {
              mult = ind >= e ? 1 : 0;
            } else {
              mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
            }
            mult = easer(mult);
          } else if (type === 3) {
            if (e === s) {
              mult = ind >= e ? 0 : 1;
            } else {
              mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
            }
            mult = easer(mult);
          } else if (type === 4) {
            if (e === s) {
              mult = 0;
            } else {
              mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              if (mult < 0.5) {
                mult *= 2;
              } else {
                mult = 1 - 2 * (mult - 0.5);
              }
            }
            mult = easer(mult);
          } else if (type === 5) {
            if (e === s) {
              mult = 0;
            } else {
              var tot = e - s;
              ind = min(max(0, ind + 0.5 - s), e - s);
              var x = -tot / 2 + ind;
              var a = tot / 2;
              mult = Math.sqrt(1 - x * x / (a * a));
            }
            mult = easer(mult);
          } else if (type === 6) {
            if (e === s) {
              mult = 0;
            } else {
              ind = min(max(0, ind + 0.5 - s), e - s);
              mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2;
            }
            mult = easer(mult);
          } else {
            if (ind >= floor(s)) {
              if (ind - s < 0) {
                mult = max(0, min(min(e, 1) - (s - ind), 1));
              } else {
                mult = max(0, min(e - ind, 1));
              }
            }
            mult = easer(mult);
          }
          if (this.sm.v !== 100) {
            var smoothness = this.sm.v * 0.01;
            if (smoothness === 0) {
              smoothness = 1e-8;
            }
            var threshold = 0.5 - smoothness * 0.5;
            if (mult < threshold) {
              mult = 0;
            } else {
              mult = (mult - threshold) / smoothness;
              if (mult > 1) {
                mult = 1;
              }
            }
          }
          return mult * this.a.v;
        },
        getValue: function getValue(newCharsFlag) {
          this.iterateDynamicProperties();
          this._mdf = newCharsFlag || this._mdf;
          this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
          if (newCharsFlag && this.data.r === 2) {
            this.e.v = this._currentTextLength;
          }
          var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
          var o = this.o.v / divisor;
          var s = this.s.v / divisor + o;
          var e = this.e.v / divisor + o;
          if (s > e) {
            var _s = s;
            s = e;
            e = _s;
          }
          this.finalS = s;
          this.finalE = e;
        }
      };
      extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
      function getTextSelectorProp(elem2, data2, arr) {
        return new TextSelectorPropFactory(elem2, data2);
      }
      return {
        getTextSelectorProp
      };
    }();
    function TextAnimatorDataProperty(elem2, animatorProps, container) {
      var defaultData = {
        propType: false
      };
      var getProp = PropertyFactory.getProp;
      var textAnimatorAnimatables = animatorProps.a;
      this.a = {
        r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
        rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
        ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
        sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
        sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
        s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
        a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
        o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
        p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
        sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
        sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
        fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
        fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
        fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
        fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
        t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container) : defaultData
      };
      this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container);
      this.s.t = animatorProps.s.t;
    }
    function TextAnimatorProperty(textData, renderType, elem2) {
      this._isFirstFrame = true;
      this._hasMaskedPath = false;
      this._frameId = -1;
      this._textData = textData;
      this._renderType = renderType;
      this._elem = elem2;
      this._animatorsData = createSizedArray(this._textData.a.length);
      this._pathData = {};
      this._moreOptions = {
        alignment: {}
      };
      this.renderedLetters = [];
      this.lettersChangedFlag = false;
      this.initDynamicPropertyContainer(elem2);
    }
    TextAnimatorProperty.prototype.searchProperties = function() {
      var i;
      var len = this._textData.a.length;
      var animatorProps;
      var getProp = PropertyFactory.getProp;
      for (i = 0; i < len; i += 1) {
        animatorProps = this._textData.a[i];
        this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
      }
      if (this._textData.p && "m" in this._textData.p) {
        this._pathData = {
          a: getProp(this._elem, this._textData.p.a, 0, 0, this),
          f: getProp(this._elem, this._textData.p.f, 0, 0, this),
          l: getProp(this._elem, this._textData.p.l, 0, 0, this),
          r: getProp(this._elem, this._textData.p.r, 0, 0, this),
          p: getProp(this._elem, this._textData.p.p, 0, 0, this),
          m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
        };
        this._hasMaskedPath = true;
      } else {
        this._hasMaskedPath = false;
      }
      this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
    };
    TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
      this.lettersChangedFlag = lettersChangedFlag;
      if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
        return;
      }
      this._isFirstFrame = false;
      var alignment = this._moreOptions.alignment.v;
      var animators = this._animatorsData;
      var textData = this._textData;
      var matrixHelper = this.mHelper;
      var renderType = this._renderType;
      var renderedLettersCount = this.renderedLetters.length;
      var xPos;
      var yPos;
      var i;
      var len;
      var letters = documentData.l;
      var pathInfo;
      var currentLength;
      var currentPoint;
      var segmentLength;
      var flag;
      var pointInd;
      var segmentInd;
      var prevPoint;
      var points;
      var segments;
      var partialLength;
      var totalLength;
      var perc;
      var tanAngle;
      var mask2;
      if (this._hasMaskedPath) {
        mask2 = this._pathData.m;
        if (!this._pathData.n || this._pathData._mdf) {
          var paths = mask2.v;
          if (this._pathData.r.v) {
            paths = paths.reverse();
          }
          pathInfo = {
            tLength: 0,
            segments: []
          };
          len = paths._length - 1;
          var bezierData;
          totalLength = 0;
          for (i = 0; i < len; i += 1) {
            bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
            pathInfo.tLength += bezierData.segmentLength;
            pathInfo.segments.push(bezierData);
            totalLength += bezierData.segmentLength;
          }
          i = len;
          if (mask2.v.c) {
            bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
            pathInfo.tLength += bezierData.segmentLength;
            pathInfo.segments.push(bezierData);
            totalLength += bezierData.segmentLength;
          }
          this._pathData.pi = pathInfo;
        }
        pathInfo = this._pathData.pi;
        currentLength = this._pathData.f.v;
        segmentInd = 0;
        pointInd = 1;
        segmentLength = 0;
        flag = true;
        segments = pathInfo.segments;
        if (currentLength < 0 && mask2.v.c) {
          if (pathInfo.tLength < Math.abs(currentLength)) {
            currentLength = -Math.abs(currentLength) % pathInfo.tLength;
          }
          segmentInd = segments.length - 1;
          points = segments[segmentInd].points;
          pointInd = points.length - 1;
          while (currentLength < 0) {
            currentLength += points[pointInd].partialLength;
            pointInd -= 1;
            if (pointInd < 0) {
              segmentInd -= 1;
              points = segments[segmentInd].points;
              pointInd = points.length - 1;
            }
          }
        }
        points = segments[segmentInd].points;
        prevPoint = points[pointInd - 1];
        currentPoint = points[pointInd];
        partialLength = currentPoint.partialLength;
      }
      len = letters.length;
      xPos = 0;
      yPos = 0;
      var yOff = documentData.finalSize * 1.2 * 0.714;
      var firstLine = true;
      var animatorProps;
      var animatorSelector;
      var j;
      var jLen;
      var letterValue;
      jLen = animators.length;
      var mult;
      var ind = -1;
      var offf;
      var xPathPos;
      var yPathPos;
      var initPathPos = currentLength;
      var initSegmentInd = segmentInd;
      var initPointInd = pointInd;
      var currentLine = -1;
      var elemOpacity;
      var sc;
      var sw;
      var fc;
      var k;
      var letterSw;
      var letterSc;
      var letterFc;
      var letterM = "";
      var letterP = this.defaultPropsArray;
      var letterO;
      if (documentData.j === 2 || documentData.j === 1) {
        var animatorJustifyOffset = 0;
        var animatorFirstCharOffset = 0;
        var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
        var lastIndex = 0;
        var isNewLine = true;
        for (i = 0; i < len; i += 1) {
          if (letters[i].n) {
            if (animatorJustifyOffset) {
              animatorJustifyOffset += animatorFirstCharOffset;
            }
            while (lastIndex < i) {
              letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
              lastIndex += 1;
            }
            animatorJustifyOffset = 0;
            isNewLine = true;
          } else {
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.t.propType) {
                if (isNewLine && documentData.j === 2) {
                  animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                }
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                } else {
                  animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                }
              }
            }
            isNewLine = false;
          }
        }
        if (animatorJustifyOffset) {
          animatorJustifyOffset += animatorFirstCharOffset;
        }
        while (lastIndex < i) {
          letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
          lastIndex += 1;
        }
      }
      for (i = 0; i < len; i += 1) {
        matrixHelper.reset();
        elemOpacity = 1;
        if (letters[i].n) {
          xPos = 0;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          currentLength = initPathPos;
          firstLine = false;
          if (this._hasMaskedPath) {
            segmentInd = initSegmentInd;
            pointInd = initPointInd;
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
            segmentLength = 0;
          }
          letterM = "";
          letterFc = "";
          letterSw = "";
          letterO = "";
          letterP = this.defaultPropsArray;
        } else {
          if (this._hasMaskedPath) {
            if (currentLine !== letters[i].line) {
              switch (documentData.j) {
                case 1:
                  currentLength += totalLength - documentData.lineWidths[letters[i].line];
                  break;
                case 2:
                  currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                  break;
              }
              currentLine = letters[i].line;
            }
            if (ind !== letters[i].ind) {
              if (letters[ind]) {
                currentLength += letters[ind].extra;
              }
              currentLength += letters[i].an / 2;
              ind = letters[i].ind;
            }
            currentLength += alignment[0] * letters[i].an * 5e-3;
            var animatorOffset = 0;
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorOffset += animatorProps.p.v[0] * mult[0];
                } else {
                  animatorOffset += animatorProps.p.v[0] * mult;
                }
              }
              if (animatorProps.a.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorOffset += animatorProps.a.v[0] * mult[0];
                } else {
                  animatorOffset += animatorProps.a.v[0] * mult;
                }
              }
            }
            flag = true;
            if (this._pathData.a.v) {
              currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
              currentLength += this._pathData.f.v;
            }
            while (flag) {
              if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                matrixHelper.translate(-alignment[0] * letters[i].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                flag = false;
              } else if (points) {
                segmentLength += currentPoint.partialLength;
                pointInd += 1;
                if (pointInd >= points.length) {
                  pointInd = 0;
                  segmentInd += 1;
                  if (!segments[segmentInd]) {
                    if (mask2.v.c) {
                      pointInd = 0;
                      segmentInd = 0;
                      points = segments[segmentInd].points;
                    } else {
                      segmentLength -= currentPoint.partialLength;
                      points = null;
                    }
                  } else {
                    points = segments[segmentInd].points;
                  }
                }
                if (points) {
                  prevPoint = currentPoint;
                  currentPoint = points[pointInd];
                  partialLength = currentPoint.partialLength;
                }
              }
            }
            offf = letters[i].an / 2 - letters[i].add;
            matrixHelper.translate(-offf, 0, 0);
          } else {
            offf = letters[i].an / 2 - letters[i].add;
            matrixHelper.translate(-offf, 0, 0);
            matrixHelper.translate(-alignment[0] * letters[i].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.t.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (xPos !== 0 || documentData.j !== 0) {
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    currentLength += animatorProps.t.v * mult[0];
                  } else {
                    currentLength += animatorProps.t.v * mult;
                  }
                } else if (mult.length) {
                  xPos += animatorProps.t.v * mult[0];
                } else {
                  xPos += animatorProps.t.v * mult;
                }
              }
            }
          }
          if (documentData.strokeWidthAnim) {
            sw = documentData.sw || 0;
          }
          if (documentData.strokeColorAnim) {
            if (documentData.sc) {
              sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
            } else {
              sc = [0, 0, 0];
            }
          }
          if (documentData.fillColorAnim && documentData.fc) {
            fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.a.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (mult.length) {
                matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
              } else {
                matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.s.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (mult.length) {
                matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
              } else {
                matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (animatorProps.sk.propType) {
              if (mult.length) {
                matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
              } else {
                matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
              }
            }
            if (animatorProps.r.propType) {
              if (mult.length) {
                matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
              } else {
                matrixHelper.rotateZ(-animatorProps.r.v * mult);
              }
            }
            if (animatorProps.ry.propType) {
              if (mult.length) {
                matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
              } else {
                matrixHelper.rotateY(animatorProps.ry.v * mult);
              }
            }
            if (animatorProps.rx.propType) {
              if (mult.length) {
                matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
              } else {
                matrixHelper.rotateX(animatorProps.rx.v * mult);
              }
            }
            if (animatorProps.o.propType) {
              if (mult.length) {
                elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
              } else {
                elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
              }
            }
            if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
              if (mult.length) {
                sw += animatorProps.sw.v * mult[0];
              } else {
                sw += animatorProps.sw.v * mult;
              }
            }
            if (documentData.strokeColorAnim && animatorProps.sc.propType) {
              for (k = 0; k < 3; k += 1) {
                if (mult.length) {
                  sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                } else {
                  sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                }
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              if (animatorProps.fc.propType) {
                for (k = 0; k < 3; k += 1) {
                  if (mult.length) {
                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                  } else {
                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                  }
                }
              }
              if (animatorProps.fh.propType) {
                if (mult.length) {
                  fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                } else {
                  fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                }
              }
              if (animatorProps.fs.propType) {
                if (mult.length) {
                  fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                } else {
                  fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                }
              }
              if (animatorProps.fb.propType) {
                if (mult.length) {
                  fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                } else {
                  fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                }
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.p.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (this._hasMaskedPath) {
                if (mult.length) {
                  matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                } else {
                  matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              } else if (mult.length) {
                matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
              } else {
                matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
              }
            }
          }
          if (documentData.strokeWidthAnim) {
            letterSw = sw < 0 ? 0 : sw;
          }
          if (documentData.strokeColorAnim) {
            letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
          }
          if (documentData.fillColorAnim && documentData.fc) {
            letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
          }
          if (this._hasMaskedPath) {
            matrixHelper.translate(0, -documentData.ls);
            matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
            if (this._pathData.p.v) {
              tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
              var rot = Math.atan(tanAngle) * 180 / Math.PI;
              if (currentPoint.point[0] < prevPoint.point[0]) {
                rot += 180;
              }
              matrixHelper.rotate(-rot * Math.PI / 180);
            }
            matrixHelper.translate(xPathPos, yPathPos, 0);
            currentLength -= alignment[0] * letters[i].an * 5e-3;
            if (letters[i + 1] && ind !== letters[i + 1].ind) {
              currentLength += letters[i].an / 2;
              currentLength += documentData.tr * 1e-3 * documentData.finalSize;
            }
          } else {
            matrixHelper.translate(xPos, yPos, 0);
            if (documentData.ps) {
              matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
            }
            switch (documentData.j) {
              case 1:
                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                break;
              case 2:
                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                break;
            }
            matrixHelper.translate(0, -documentData.ls);
            matrixHelper.translate(offf, 0, 0);
            matrixHelper.translate(alignment[0] * letters[i].an * 5e-3, alignment[1] * yOff * 0.01, 0);
            xPos += letters[i].l + documentData.tr * 1e-3 * documentData.finalSize;
          }
          if (renderType === "html") {
            letterM = matrixHelper.toCSS();
          } else if (renderType === "svg") {
            letterM = matrixHelper.to2dCSS();
          } else {
            letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
          }
          letterO = elemOpacity;
        }
        if (renderedLettersCount <= i) {
          letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
          this.renderedLetters.push(letterValue);
          renderedLettersCount += 1;
          this.lettersChangedFlag = true;
        } else {
          letterValue = this.renderedLetters[i];
          this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
        }
      }
    };
    TextAnimatorProperty.prototype.getValue = function() {
      if (this._elem.globalData.frameId === this._frameId) {
        return;
      }
      this._frameId = this._elem.globalData.frameId;
      this.iterateDynamicProperties();
    };
    TextAnimatorProperty.prototype.mHelper = new Matrix();
    TextAnimatorProperty.prototype.defaultPropsArray = [];
    extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
    function ITextElement() {
    }
    ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
      this.lettersChangedFlag = true;
      this.initFrame();
      this.initBaseData(data2, globalData2, comp2);
      this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
      this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
      this.initTransform(data2, globalData2, comp2);
      this.initHierarchy();
      this.initRenderable();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      this.createContent();
      this.hide();
      this.textAnimator.searchProperties(this.dynamicProperties);
    };
    ITextElement.prototype.prepareFrame = function(num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
    };
    ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
      var j;
      var jLen = shapes.length;
      var pathNodes;
      var shapeStr = "";
      for (j = 0; j < jLen; j += 1) {
        if (shapes[j].ty === "sh") {
          pathNodes = shapes[j].ks.k;
          shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
        }
      }
      return shapeStr;
    };
    ITextElement.prototype.updateDocumentData = function(newData, index2) {
      this.textProperty.updateDocumentData(newData, index2);
    };
    ITextElement.prototype.canResizeFont = function(_canResize) {
      this.textProperty.canResizeFont(_canResize);
    };
    ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
      this.textProperty.setMinimumFontSize(_fontSize);
    };
    ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
      if (documentData.ps) {
        matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
      }
      matrixHelper.translate(0, -documentData.ls, 0);
      switch (documentData.j) {
        case 1:
          matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
          break;
        case 2:
          matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
          break;
      }
      matrixHelper.translate(xPos, yPos, 0);
    };
    ITextElement.prototype.buildColor = function(colorData) {
      return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
    };
    ITextElement.prototype.emptyProp = new LetterProps();
    ITextElement.prototype.destroy = function() {
    };
    ITextElement.prototype.validateText = function() {
      if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
        this.buildNewText();
        this.textProperty._isFirstFrame = false;
        this.textProperty._mdf = false;
      }
    };
    var emptyShapeData = {
      shapes: []
    };
    function SVGTextLottieElement(data2, globalData2, comp2) {
      this.textSpans = [];
      this.renderType = "svg";
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
    SVGTextLottieElement.prototype.createContent = function() {
      if (this.data.singleShape && !this.globalData.fontManager.chars) {
        this.textContainer = createNS("text");
      }
    };
    SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
      var i = 0;
      var len = textArray.length;
      var textContents = [];
      var currentTextContent = "";
      while (i < len) {
        if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
          textContents.push(currentTextContent);
          currentTextContent = "";
        } else {
          currentTextContent += textArray[i];
        }
        i += 1;
      }
      textContents.push(currentTextContent);
      return textContents;
    };
    SVGTextLottieElement.prototype.buildShapeData = function(data2, scale2) {
      if (data2.shapes && data2.shapes.length) {
        var shape = data2.shapes[0];
        if (shape.it) {
          var shapeItem = shape.it[shape.it.length - 1];
          if (shapeItem.s) {
            shapeItem.s.k[0] = scale2;
            shapeItem.s.k[1] = scale2;
          }
        }
      }
      return data2;
    };
    SVGTextLottieElement.prototype.buildNewText = function() {
      this.addDynamicProperty(this);
      var i;
      var len;
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
      if (documentData.fc) {
        this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
      } else {
        this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
      }
      if (documentData.sc) {
        this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
        this.layerElement.setAttribute("stroke-width", documentData.sw);
      }
      this.layerElement.setAttribute("font-size", documentData.finalSize);
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      if (fontData.fClass) {
        this.layerElement.setAttribute("class", fontData.fClass);
      } else {
        this.layerElement.setAttribute("font-family", fontData.fFamily);
        var fWeight = documentData.fWeight;
        var fStyle = documentData.fStyle;
        this.layerElement.setAttribute("font-style", fStyle);
        this.layerElement.setAttribute("font-weight", fWeight);
      }
      this.layerElement.setAttribute("aria-label", documentData.t);
      var letters = documentData.l || [];
      var usesGlyphs = !!this.globalData.fontManager.chars;
      len = letters.length;
      var tSpan;
      var matrixHelper = this.mHelper;
      var shapeStr = "";
      var singleShape = this.data.singleShape;
      var xPos = 0;
      var yPos = 0;
      var firstLine = true;
      var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
      if (singleShape && !usesGlyphs && !documentData.sz) {
        var tElement = this.textContainer;
        var justify = "start";
        switch (documentData.j) {
          case 1:
            justify = "end";
            break;
          case 2:
            justify = "middle";
            break;
          default:
            justify = "start";
            break;
        }
        tElement.setAttribute("text-anchor", justify);
        tElement.setAttribute("letter-spacing", trackingOffset);
        var textContent = this.buildTextContents(documentData.finalText);
        len = textContent.length;
        yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
        for (i = 0; i < len; i += 1) {
          tSpan = this.textSpans[i].span || createNS("tspan");
          tSpan.textContent = textContent[i];
          tSpan.setAttribute("x", 0);
          tSpan.setAttribute("y", yPos);
          tSpan.style.display = "inherit";
          tElement.appendChild(tSpan);
          if (!this.textSpans[i]) {
            this.textSpans[i] = {
              span: null,
              glyph: null
            };
          }
          this.textSpans[i].span = tSpan;
          yPos += documentData.finalLineHeight;
        }
        this.layerElement.appendChild(tElement);
      } else {
        var cachedSpansLength = this.textSpans.length;
        var charData;
        for (i = 0; i < len; i += 1) {
          if (!this.textSpans[i]) {
            this.textSpans[i] = {
              span: null,
              childSpan: null,
              glyph: null
            };
          }
          if (!usesGlyphs || !singleShape || i === 0) {
            tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? "g" : "text");
            if (cachedSpansLength <= i) {
              tSpan.setAttribute("stroke-linecap", "butt");
              tSpan.setAttribute("stroke-linejoin", "round");
              tSpan.setAttribute("stroke-miterlimit", "4");
              this.textSpans[i].span = tSpan;
              if (usesGlyphs) {
                var childSpan = createNS("g");
                tSpan.appendChild(childSpan);
                this.textSpans[i].childSpan = childSpan;
              }
              this.textSpans[i].span = tSpan;
              this.layerElement.appendChild(tSpan);
            }
            tSpan.style.display = "inherit";
          }
          matrixHelper.reset();
          if (singleShape) {
            if (letters[i].n) {
              xPos = -trackingOffset;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              firstLine = false;
            }
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
            xPos += letters[i].l || 0;
            xPos += trackingOffset;
          }
          if (usesGlyphs) {
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var glyphElement;
            if (charData.t === 1) {
              glyphElement = new SVGCompElement(charData.data, this.globalData, this);
            } else {
              var data2 = emptyShapeData;
              if (charData.data && charData.data.shapes) {
                data2 = this.buildShapeData(charData.data, documentData.finalSize);
              }
              glyphElement = new SVGShapeElement(data2, this.globalData, this);
            }
            if (this.textSpans[i].glyph) {
              var glyph = this.textSpans[i].glyph;
              this.textSpans[i].childSpan.removeChild(glyph.layerElement);
              glyph.destroy();
            }
            this.textSpans[i].glyph = glyphElement;
            glyphElement._debug = true;
            glyphElement.prepareFrame(0);
            glyphElement.renderFrame();
            this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);
            if (charData.t === 1) {
              this.textSpans[i].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
            }
          } else {
            if (singleShape) {
              tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
            }
            tSpan.textContent = letters[i].val;
            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
          }
        }
        if (singleShape && tSpan) {
          tSpan.setAttribute("d", shapeStr);
        }
      }
      while (i < this.textSpans.length) {
        this.textSpans[i].span.style.display = "none";
        i += 1;
      }
      this._sizeChanged = true;
    };
    SVGTextLottieElement.prototype.sourceRectAtTime = function() {
      this.prepareFrame(this.comp.renderedFrame - this.data.st);
      this.renderInnerContent();
      if (this._sizeChanged) {
        this._sizeChanged = false;
        var textBox = this.layerElement.getBBox();
        this.bbox = {
          top: textBox.y,
          left: textBox.x,
          width: textBox.width,
          height: textBox.height
        };
      }
      return this.bbox;
    };
    SVGTextLottieElement.prototype.getValue = function() {
      var i;
      var len = this.textSpans.length;
      var glyphElement;
      this.renderedFrame = this.comp.renderedFrame;
      for (i = 0; i < len; i += 1) {
        glyphElement = this.textSpans[i].glyph;
        if (glyphElement) {
          glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
          if (glyphElement._mdf) {
            this._mdf = true;
          }
        }
      }
    };
    SVGTextLottieElement.prototype.renderInnerContent = function() {
      this.validateText();
      if (!this.data.singleShape || this._mdf) {
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
          this._sizeChanged = true;
          var i;
          var len;
          var renderedLetters = this.textAnimator.renderedLetters;
          var letters = this.textProperty.currentData.l;
          len = letters.length;
          var renderedLetter;
          var textSpan;
          var glyphElement;
          for (i = 0; i < len; i += 1) {
            if (!letters[i].n) {
              renderedLetter = renderedLetters[i];
              textSpan = this.textSpans[i].span;
              glyphElement = this.textSpans[i].glyph;
              if (glyphElement) {
                glyphElement.renderFrame();
              }
              if (renderedLetter._mdf.m) {
                textSpan.setAttribute("transform", renderedLetter.m);
              }
              if (renderedLetter._mdf.o) {
                textSpan.setAttribute("opacity", renderedLetter.o);
              }
              if (renderedLetter._mdf.sw) {
                textSpan.setAttribute("stroke-width", renderedLetter.sw);
              }
              if (renderedLetter._mdf.sc) {
                textSpan.setAttribute("stroke", renderedLetter.sc);
              }
              if (renderedLetter._mdf.fc) {
                textSpan.setAttribute("fill", renderedLetter.fc);
              }
            }
          }
        }
      }
    };
    function ISolidElement(data2, globalData2, comp2) {
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([IImageElement], ISolidElement);
    ISolidElement.prototype.createContent = function() {
      var rect = createNS("rect");
      rect.setAttribute("width", this.data.sw);
      rect.setAttribute("height", this.data.sh);
      rect.setAttribute("fill", this.data.sc);
      this.layerElement.appendChild(rect);
    };
    function NullElement(data2, globalData2, comp2) {
      this.initFrame();
      this.initBaseData(data2, globalData2, comp2);
      this.initFrame();
      this.initTransform(data2, globalData2, comp2);
      this.initHierarchy();
    }
    NullElement.prototype.prepareFrame = function(num) {
      this.prepareProperties(num, true);
    };
    NullElement.prototype.renderFrame = function() {
    };
    NullElement.prototype.getBaseElement = function() {
      return null;
    };
    NullElement.prototype.destroy = function() {
    };
    NullElement.prototype.sourceRectAtTime = function() {
    };
    NullElement.prototype.hide = function() {
    };
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
    function SVGRendererBase() {
    }
    extendPrototype([BaseRenderer], SVGRendererBase);
    SVGRendererBase.prototype.createNull = function(data2) {
      return new NullElement(data2, this.globalData, this);
    };
    SVGRendererBase.prototype.createShape = function(data2) {
      return new SVGShapeElement(data2, this.globalData, this);
    };
    SVGRendererBase.prototype.createText = function(data2) {
      return new SVGTextLottieElement(data2, this.globalData, this);
    };
    SVGRendererBase.prototype.createImage = function(data2) {
      return new IImageElement(data2, this.globalData, this);
    };
    SVGRendererBase.prototype.createSolid = function(data2) {
      return new ISolidElement(data2, this.globalData, this);
    };
    SVGRendererBase.prototype.configAnimation = function(animData) {
      this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
      if (this.renderConfig.viewBoxSize) {
        this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
      } else {
        this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
      }
      if (!this.renderConfig.viewBoxOnly) {
        this.svgElement.setAttribute("width", animData.w);
        this.svgElement.setAttribute("height", animData.h);
        this.svgElement.style.width = "100%";
        this.svgElement.style.height = "100%";
        this.svgElement.style.transform = "translate3d(0,0,0)";
        this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
      }
      if (this.renderConfig.width) {
        this.svgElement.setAttribute("width", this.renderConfig.width);
      }
      if (this.renderConfig.height) {
        this.svgElement.setAttribute("height", this.renderConfig.height);
      }
      if (this.renderConfig.className) {
        this.svgElement.setAttribute("class", this.renderConfig.className);
      }
      if (this.renderConfig.id) {
        this.svgElement.setAttribute("id", this.renderConfig.id);
      }
      if (this.renderConfig.focusable !== void 0) {
        this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
      }
      this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
      this.animationItem.wrapper.appendChild(this.svgElement);
      var defs = this.globalData.defs;
      this.setupGlobalData(animData, defs);
      this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
      this.data = animData;
      var maskElement = createNS("clipPath");
      var rect = createNS("rect");
      rect.setAttribute("width", animData.w);
      rect.setAttribute("height", animData.h);
      rect.setAttribute("x", 0);
      rect.setAttribute("y", 0);
      var maskId = createElementID();
      maskElement.setAttribute("id", maskId);
      maskElement.appendChild(rect);
      this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
      defs.appendChild(maskElement);
      this.layers = animData.layers;
      this.elements = createSizedArray(animData.layers.length);
    };
    SVGRendererBase.prototype.destroy = function() {
      if (this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = "";
      }
      this.layerElement = null;
      this.globalData.defs = null;
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i] && this.elements[i].destroy) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.destroyed = true;
      this.animationItem = null;
    };
    SVGRendererBase.prototype.updateContainerSize = function() {
    };
    SVGRendererBase.prototype.findIndexByInd = function(ind) {
      var i = 0;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.layers[i].ind === ind) {
          return i;
        }
      }
      return -1;
    };
    SVGRendererBase.prototype.buildItem = function(pos) {
      var elements2 = this.elements;
      if (elements2[pos] || this.layers[pos].ty === 99) {
        return;
      }
      elements2[pos] = true;
      var element = this.createItem(this.layers[pos]);
      elements2[pos] = element;
      if (getExpressionsPlugin()) {
        if (this.layers[pos].ty === 0) {
          this.globalData.projectInterface.registerComposition(element);
        }
        element.initExpressions();
      }
      this.appendElementInPos(element, pos);
      if (this.layers[pos].tt) {
        var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
        if (elementIndex === -1) {
          return;
        }
        if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
          this.buildItem(elementIndex);
          this.addPendingElement(element);
        } else {
          var matteElement = elements2[elementIndex];
          var matteMask = matteElement.getMatte(this.layers[pos].tt);
          element.setMatte(matteMask);
        }
      }
    };
    SVGRendererBase.prototype.checkPendingElements = function() {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
        if (element.data.tt) {
          var i = 0;
          var len = this.elements.length;
          while (i < len) {
            if (this.elements[i] === element) {
              var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
              var matteElement = this.elements[elementIndex];
              var matteMask = matteElement.getMatte(this.layers[i].tt);
              element.setMatte(matteMask);
              break;
            }
            i += 1;
          }
        }
      }
    };
    SVGRendererBase.prototype.renderFrame = function(num) {
      if (this.renderedFrame === num || this.destroyed) {
        return;
      }
      if (num === null) {
        num = this.renderedFrame;
      } else {
        this.renderedFrame = num;
      }
      this.globalData.frameNum = num;
      this.globalData.frameId += 1;
      this.globalData.projectInterface.currentFrame = num;
      this.globalData._mdf = false;
      var i;
      var len = this.layers.length;
      if (!this.completeLayers) {
        this.checkLayers(num);
      }
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(num - this.layers[i].st);
        }
      }
      if (this.globalData._mdf) {
        for (i = 0; i < len; i += 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      }
    };
    SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
      var newElement = element.getBaseElement();
      if (!newElement) {
        return;
      }
      var i = 0;
      var nextElement;
      while (i < pos) {
        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
          nextElement = this.elements[i].getBaseElement();
        }
        i += 1;
      }
      if (nextElement) {
        this.layerElement.insertBefore(newElement, nextElement);
      } else {
        this.layerElement.appendChild(newElement);
      }
    };
    SVGRendererBase.prototype.hide = function() {
      this.layerElement.style.display = "none";
    };
    SVGRendererBase.prototype.show = function() {
      this.layerElement.style.display = "block";
    };
    function ICompElement() {
    }
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
    ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
      this.initFrame();
      this.initBaseData(data2, globalData2, comp2);
      this.initTransform(data2, globalData2, comp2);
      this.initRenderable();
      this.initHierarchy();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      if (this.data.xt || !globalData2.progressiveLoad) {
        this.buildAllItems();
      }
      this.hide();
    };
    ICompElement.prototype.prepareFrame = function(num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
      if (!this.isInRange && !this.data.xt) {
        return;
      }
      if (!this.tm._placeholder) {
        var timeRemapped = this.tm.v;
        if (timeRemapped === this.data.op) {
          timeRemapped = this.data.op - 1;
        }
        this.renderedFrame = timeRemapped;
      } else {
        this.renderedFrame = num / this.data.sr;
      }
      var i;
      var len = this.elements.length;
      if (!this.completeLayers) {
        this.checkLayers(this.renderedFrame);
      }
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
          if (this.elements[i]._mdf) {
            this._mdf = true;
          }
        }
      }
    };
    ICompElement.prototype.renderInnerContent = function() {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    };
    ICompElement.prototype.setElements = function(elems) {
      this.elements = elems;
    };
    ICompElement.prototype.getElements = function() {
      return this.elements;
    };
    ICompElement.prototype.destroyElements = function() {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
    };
    ICompElement.prototype.destroy = function() {
      this.destroyElements();
      this.destroyBaseElement();
    };
    function SVGCompElement(data2, globalData2, comp2) {
      this.layers = data2.layers;
      this.supports3d = true;
      this.completeLayers = false;
      this.pendingElements = [];
      this.elements = this.layers ? createSizedArray(this.layers.length) : [];
      this.initElement(data2, globalData2, comp2);
      this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
        _placeholder: true
      };
    }
    extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
    SVGCompElement.prototype.createComp = function(data2) {
      return new SVGCompElement(data2, this.globalData, this);
    };
    function SVGRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.svgElement = createNS("svg");
      var ariaLabel = "";
      if (config && config.title) {
        var titleElement = createNS("title");
        var titleId = createElementID();
        titleElement.setAttribute("id", titleId);
        titleElement.textContent = config.title;
        this.svgElement.appendChild(titleElement);
        ariaLabel += titleId;
      }
      if (config && config.description) {
        var descElement = createNS("desc");
        var descId = createElementID();
        descElement.setAttribute("id", descId);
        descElement.textContent = config.description;
        this.svgElement.appendChild(descElement);
        ariaLabel += " " + descId;
      }
      if (ariaLabel) {
        this.svgElement.setAttribute("aria-labelledby", ariaLabel);
      }
      var defs = createNS("defs");
      this.svgElement.appendChild(defs);
      var maskElement = createNS("g");
      this.svgElement.appendChild(maskElement);
      this.layerElement = maskElement;
      this.renderConfig = {
        preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: config && config.contentVisibility || "visible",
        progressiveLoad: config && config.progressiveLoad || false,
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        viewBoxOnly: config && config.viewBoxOnly || false,
        viewBoxSize: config && config.viewBoxSize || false,
        className: config && config.className || "",
        id: config && config.id || "",
        focusable: config && config.focusable,
        filterSize: {
          width: config && config.filterSize && config.filterSize.width || "100%",
          height: config && config.filterSize && config.filterSize.height || "100%",
          x: config && config.filterSize && config.filterSize.x || "0%",
          y: config && config.filterSize && config.filterSize.y || "0%"
        },
        width: config && config.width,
        height: config && config.height,
        runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        defs,
        renderConfig: this.renderConfig
      };
      this.elements = [];
      this.pendingElements = [];
      this.destroyed = false;
      this.rendererType = "svg";
    }
    extendPrototype([SVGRendererBase], SVGRenderer);
    SVGRenderer.prototype.createComp = function(data2) {
      return new SVGCompElement(data2, this.globalData, this);
    };
    function ShapeTransformManager() {
      this.sequences = {};
      this.sequenceList = [];
      this.transform_key_count = 0;
    }
    ShapeTransformManager.prototype = {
      addTransformSequence: function addTransformSequence(transforms) {
        var i;
        var len = transforms.length;
        var key2 = "_";
        for (i = 0; i < len; i += 1) {
          key2 += transforms[i].transform.key + "_";
        }
        var sequence = this.sequences[key2];
        if (!sequence) {
          sequence = {
            transforms: [].concat(transforms),
            finalTransform: new Matrix(),
            _mdf: false
          };
          this.sequences[key2] = sequence;
          this.sequenceList.push(sequence);
        }
        return sequence;
      },
      processSequence: function processSequence(sequence, isFirstFrame) {
        var i = 0;
        var len = sequence.transforms.length;
        var _mdf = isFirstFrame;
        while (i < len && !isFirstFrame) {
          if (sequence.transforms[i].transform.mProps._mdf) {
            _mdf = true;
            break;
          }
          i += 1;
        }
        if (_mdf) {
          sequence.finalTransform.reset();
          for (i = len - 1; i >= 0; i -= 1) {
            sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
          }
        }
        sequence._mdf = _mdf;
      },
      processSequences: function processSequences(isFirstFrame) {
        var i;
        var len = this.sequenceList.length;
        for (i = 0; i < len; i += 1) {
          this.processSequence(this.sequenceList[i], isFirstFrame);
        }
      },
      getNewKey: function getNewKey() {
        this.transform_key_count += 1;
        return "_" + this.transform_key_count;
      }
    };
    var lumaLoader = function lumaLoader2() {
      var id = "__lottie_element_luma_buffer";
      var lumaBuffer = null;
      var lumaBufferCtx = null;
      var svg = null;
      function createLumaSvgFilter() {
        var _svg = createNS("svg");
        var fil = createNS("filter");
        var matrix = createNS("feColorMatrix");
        fil.setAttribute("id", id);
        matrix.setAttribute("type", "matrix");
        matrix.setAttribute("color-interpolation-filters", "sRGB");
        matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
        fil.appendChild(matrix);
        _svg.appendChild(fil);
        _svg.setAttribute("id", id + "_svg");
        if (featureSupport.svgLumaHidden) {
          _svg.style.display = "none";
        }
        return _svg;
      }
      function loadLuma() {
        if (!lumaBuffer) {
          svg = createLumaSvgFilter();
          document.body.appendChild(svg);
          lumaBuffer = createTag("canvas");
          lumaBufferCtx = lumaBuffer.getContext("2d");
          lumaBufferCtx.filter = "url(#" + id + ")";
          lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
          lumaBufferCtx.fillRect(0, 0, 1, 1);
        }
      }
      function getLuma(canvas2) {
        if (!lumaBuffer) {
          loadLuma();
        }
        lumaBuffer.width = canvas2.width;
        lumaBuffer.height = canvas2.height;
        lumaBufferCtx.filter = "url(#" + id + ")";
        return lumaBuffer;
      }
      return {
        load: loadLuma,
        get: getLuma
      };
    };
    function createCanvas(width2, height2) {
      if (featureSupport.offscreenCanvas) {
        return new OffscreenCanvas(width2, height2);
      }
      var canvas2 = createTag("canvas");
      canvas2.width = width2;
      canvas2.height = height2;
      return canvas2;
    }
    var assetLoader = function() {
      return {
        loadLumaCanvas: lumaLoader.load,
        getLumaCanvas: lumaLoader.get,
        createCanvas
      };
    }();
    var registeredEffects = {};
    function CVEffects(elem2) {
      var i;
      var len = elem2.data.ef ? elem2.data.ef.length : 0;
      this.filters = [];
      var filterManager;
      for (i = 0; i < len; i += 1) {
        filterManager = null;
        var type = elem2.data.ef[i].ty;
        if (registeredEffects[type]) {
          var Effect = registeredEffects[type].effect;
          filterManager = new Effect(elem2.effectsManager.effectElements[i], elem2);
        }
        if (filterManager) {
          this.filters.push(filterManager);
        }
      }
      if (this.filters.length) {
        elem2.addRenderableComponent(this);
      }
    }
    CVEffects.prototype.renderFrame = function(_isFirstFrame) {
      var i;
      var len = this.filters.length;
      for (i = 0; i < len; i += 1) {
        this.filters[i].renderFrame(_isFirstFrame);
      }
    };
    CVEffects.prototype.getEffects = function(type) {
      var i;
      var len = this.filters.length;
      var effects2 = [];
      for (i = 0; i < len; i += 1) {
        if (this.filters[i].type === type) {
          effects2.push(this.filters[i]);
        }
      }
      return effects2;
    };
    function registerEffect(id, effect2) {
      registeredEffects[id] = {
        effect: effect2
      };
    }
    function CVMaskElement(data2, element) {
      this.data = data2;
      this.element = element;
      this.masksProperties = this.data.masksProperties || [];
      this.viewData = createSizedArray(this.masksProperties.length);
      var i;
      var len = this.masksProperties.length;
      var hasMasks = false;
      for (i = 0; i < len; i += 1) {
        if (this.masksProperties[i].mode !== "n") {
          hasMasks = true;
        }
        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
      }
      this.hasMasks = hasMasks;
      if (hasMasks) {
        this.element.addRenderableComponent(this);
      }
    }
    CVMaskElement.prototype.renderFrame = function() {
      if (!this.hasMasks) {
        return;
      }
      var transform2 = this.element.finalTransform.mat;
      var ctx2 = this.element.canvasContext;
      var i;
      var len = this.masksProperties.length;
      var pt;
      var pts;
      var data2;
      ctx2.beginPath();
      for (i = 0; i < len; i += 1) {
        if (this.masksProperties[i].mode !== "n") {
          if (this.masksProperties[i].inv) {
            ctx2.moveTo(0, 0);
            ctx2.lineTo(this.element.globalData.compSize.w, 0);
            ctx2.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
            ctx2.lineTo(0, this.element.globalData.compSize.h);
            ctx2.lineTo(0, 0);
          }
          data2 = this.viewData[i].v;
          pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
          ctx2.moveTo(pt[0], pt[1]);
          var j;
          var jLen = data2._length;
          for (j = 1; j < jLen; j += 1) {
            pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[j], data2.v[j]);
            ctx2.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
          pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[0], data2.v[0]);
          ctx2.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
        }
      }
      this.element.globalData.renderer.save(true);
      ctx2.clip();
    };
    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
    CVMaskElement.prototype.destroy = function() {
      this.element = null;
    };
    function CVBaseElement() {
    }
    var operationsMap = {
      1: "source-in",
      2: "source-out",
      3: "source-in",
      4: "source-out"
    };
    CVBaseElement.prototype = {
      createElements: function createElements() {
      },
      initRendererElement: function initRendererElement() {
      },
      createContainerElements: function createContainerElements() {
        if (this.data.tt >= 1) {
          this.buffers = [];
          var canvasContext = this.globalData.canvasContext;
          var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
          this.buffers.push(bufferCanvas);
          var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
          this.buffers.push(bufferCanvas2);
          if (this.data.tt >= 3 && !document._isProxy) {
            assetLoader.loadLumaCanvas();
          }
        }
        this.canvasContext = this.globalData.canvasContext;
        this.transformCanvas = this.globalData.transformCanvas;
        this.renderableEffectsManager = new CVEffects(this);
        this.searchEffectTransforms();
      },
      createContent: function createContent() {
      },
      setBlendMode: function setBlendMode() {
        var globalData2 = this.globalData;
        if (globalData2.blendMode !== this.data.bm) {
          globalData2.blendMode = this.data.bm;
          var blendModeValue = getBlendMode(this.data.bm);
          globalData2.canvasContext.globalCompositeOperation = blendModeValue;
        }
      },
      createRenderableComponents: function createRenderableComponents() {
        this.maskManager = new CVMaskElement(this.data, this);
        this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
      },
      hideElement: function hideElement() {
        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
          this.hidden = true;
        }
      },
      showElement: function showElement() {
        if (this.isInRange && !this.isTransparent) {
          this.hidden = false;
          this._isFirstFrame = true;
          this.maskManager._isFirstFrame = true;
        }
      },
      clearCanvas: function clearCanvas2(canvasContext) {
        canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
      },
      prepareLayer: function prepareLayer() {
        if (this.data.tt >= 1) {
          var buffer = this.buffers[0];
          var bufferCtx = buffer.getContext("2d");
          this.clearCanvas(bufferCtx);
          bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
          this.currentTransform = this.canvasContext.getTransform();
          this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
          this.clearCanvas(this.canvasContext);
          this.canvasContext.setTransform(this.currentTransform);
        }
      },
      exitLayer: function exitLayer() {
        if (this.data.tt >= 1) {
          var buffer = this.buffers[1];
          var bufferCtx = buffer.getContext("2d");
          this.clearCanvas(bufferCtx);
          bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
          this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
          this.clearCanvas(this.canvasContext);
          this.canvasContext.setTransform(this.currentTransform);
          var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
          mask2.renderFrame(true);
          this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
          if (this.data.tt >= 3 && !document._isProxy) {
            var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
            var lumaBufferCtx = lumaBuffer.getContext("2d");
            lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.drawImage(lumaBuffer, 0, 0);
          }
          this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
          this.canvasContext.drawImage(buffer, 0, 0);
          this.canvasContext.globalCompositeOperation = "destination-over";
          this.canvasContext.drawImage(this.buffers[0], 0, 0);
          this.canvasContext.setTransform(this.currentTransform);
          this.canvasContext.globalCompositeOperation = "source-over";
        }
      },
      renderFrame: function renderFrame(forceRender) {
        if (this.hidden || this.data.hd) {
          return;
        }
        if (this.data.td === 1 && !forceRender) {
          return;
        }
        this.renderTransform();
        this.renderRenderable();
        this.renderLocalTransform();
        this.setBlendMode();
        var forceRealStack = this.data.ty === 0;
        this.prepareLayer();
        this.globalData.renderer.save(forceRealStack);
        this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
        this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
        this.renderInnerContent();
        this.globalData.renderer.restore(forceRealStack);
        this.exitLayer();
        if (this.maskManager.hasMasks) {
          this.globalData.renderer.restore(true);
        }
        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      destroy: function destroy() {
        this.canvasContext = null;
        this.data = null;
        this.globalData = null;
        this.maskManager.destroy();
      },
      mHelper: new Matrix()
    };
    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
    function CVShapeData(element, data2, styles, transformsManager) {
      this.styledShapes = [];
      this.tr = [0, 0, 0, 0, 0, 0];
      var ty = 4;
      if (data2.ty === "rc") {
        ty = 5;
      } else if (data2.ty === "el") {
        ty = 6;
      } else if (data2.ty === "sr") {
        ty = 7;
      }
      this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
      var i;
      var len = styles.length;
      var styledShape;
      for (i = 0; i < len; i += 1) {
        if (!styles[i].closed) {
          styledShape = {
            transforms: transformsManager.addTransformSequence(styles[i].transforms),
            trNodes: []
          };
          this.styledShapes.push(styledShape);
          styles[i].elements.push(styledShape);
        }
      }
    }
    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function CVShapeElement(data2, globalData2, comp2) {
      this.shapes = [];
      this.shapesData = data2.shapes;
      this.stylesList = [];
      this.itemsData = [];
      this.prevViewData = [];
      this.shapeModifiers = [];
      this.processedElements = [];
      this.transformsManager = new ShapeTransformManager();
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
    CVShapeElement.prototype.transformHelper = {
      opacity: 1,
      _opMdf: false
    };
    CVShapeElement.prototype.dashResetter = [];
    CVShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
    };
    CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
      var styleElem = {
        data: data2,
        type: data2.ty,
        preTransforms: this.transformsManager.addTransformSequence(transforms),
        transforms: [],
        elements: [],
        closed: data2.hd === true
      };
      var elementData = {};
      if (data2.ty === "fl" || data2.ty === "st") {
        elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
        if (!elementData.c.k) {
          styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
        }
      } else if (data2.ty === "gf" || data2.ty === "gs") {
        elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
        elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
        elementData.h = PropertyFactory.getProp(this, data2.h || {
          k: 0
        }, 0, 0.01, this);
        elementData.a = PropertyFactory.getProp(this, data2.a || {
          k: 0
        }, 0, degToRads, this);
        elementData.g = new GradientProperty(this, data2.g, this);
      }
      elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
      if (data2.ty === "st" || data2.ty === "gs") {
        styleElem.lc = lineCapEnum[data2.lc || 2];
        styleElem.lj = lineJoinEnum[data2.lj || 2];
        if (data2.lj == 1) {
          styleElem.ml = data2.ml;
        }
        elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
        if (!elementData.w.k) {
          styleElem.wi = elementData.w.v;
        }
        if (data2.d) {
          var d = new DashProperty(this, data2.d, "canvas", this);
          elementData.d = d;
          if (!elementData.d.k) {
            styleElem.da = elementData.d.dashArray;
            styleElem["do"] = elementData.d.dashoffset[0];
          }
        }
      } else {
        styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
      }
      this.stylesList.push(styleElem);
      elementData.style = styleElem;
      return elementData;
    };
    CVShapeElement.prototype.createGroupElement = function() {
      var elementData = {
        it: [],
        prevViewData: []
      };
      return elementData;
    };
    CVShapeElement.prototype.createTransformElement = function(data2) {
      var elementData = {
        transform: {
          opacity: 1,
          _opMdf: false,
          key: this.transformsManager.getNewKey(),
          op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
          mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
        }
      };
      return elementData;
    };
    CVShapeElement.prototype.createShapeElement = function(data2) {
      var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
      this.shapes.push(elementData);
      this.addShapeToModifiers(elementData);
      return elementData;
    };
    CVShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = true;
      var i;
      var len = this.itemsData.length;
      for (i = 0; i < len; i += 1) {
        this.prevViewData[i] = this.itemsData[i];
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      len = this.dynamicProperties.length;
      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();
      }
      this.renderModifiers();
      this.transformsManager.processSequences(this._isFirstFrame);
    };
    CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        if (!this.stylesList[i].closed) {
          this.stylesList[i].transforms.push(transform2);
        }
      }
    };
    CVShapeElement.prototype.removeTransformFromStyleList = function() {
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        if (!this.stylesList[i].closed) {
          this.stylesList[i].transforms.pop();
        }
      }
    };
    CVShapeElement.prototype.closeStyles = function(styles) {
      var i;
      var len = styles.length;
      for (i = 0; i < len; i += 1) {
        styles[i].closed = true;
      }
    };
    CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
      var i;
      var len = arr.length - 1;
      var j;
      var jLen;
      var ownStyles = [];
      var ownModifiers = [];
      var processedPos;
      var modifier;
      var currentTransform;
      var ownTransforms = [].concat(transforms);
      for (i = len; i >= 0; i -= 1) {
        processedPos = this.searchProcessedElement(arr[i]);
        if (!processedPos) {
          arr[i]._shouldRender = shouldRender;
        } else {
          itemsData[i] = prevViewData[processedPos - 1];
        }
        if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs") {
          if (!processedPos) {
            itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
          } else {
            itemsData[i].style.closed = false;
          }
          ownStyles.push(itemsData[i].style);
        } else if (arr[i].ty === "gr") {
          if (!processedPos) {
            itemsData[i] = this.createGroupElement(arr[i]);
          } else {
            jLen = itemsData[i].it.length;
            for (j = 0; j < jLen; j += 1) {
              itemsData[i].prevViewData[j] = itemsData[i].it[j];
            }
          }
          this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
        } else if (arr[i].ty === "tr") {
          if (!processedPos) {
            currentTransform = this.createTransformElement(arr[i]);
            itemsData[i] = currentTransform;
          }
          ownTransforms.push(itemsData[i]);
          this.addTransformToStyleList(itemsData[i]);
        } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
          if (!processedPos) {
            itemsData[i] = this.createShapeElement(arr[i]);
          }
        } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "pb" || arr[i].ty === "zz" || arr[i].ty === "op") {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            modifier.init(this, arr[i]);
            itemsData[i] = modifier;
            this.shapeModifiers.push(modifier);
          } else {
            modifier = itemsData[i];
            modifier.closed = false;
          }
          ownModifiers.push(modifier);
        } else if (arr[i].ty === "rp") {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            itemsData[i] = modifier;
            modifier.init(this, arr, i, itemsData);
            this.shapeModifiers.push(modifier);
            shouldRender = false;
          } else {
            modifier = itemsData[i];
            modifier.closed = true;
          }
          ownModifiers.push(modifier);
        }
        this.addProcessedElement(arr[i], i + 1);
      }
      this.removeTransformFromStyleList();
      this.closeStyles(ownStyles);
      len = ownModifiers.length;
      for (i = 0; i < len; i += 1) {
        ownModifiers[i].closed = true;
      }
    };
    CVShapeElement.prototype.renderInnerContent = function() {
      this.transformHelper.opacity = 1;
      this.transformHelper._opMdf = false;
      this.renderModifiers();
      this.transformsManager.processSequences(this._isFirstFrame);
      this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
    };
    CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
      if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
        groupTransform.opacity = parentTransform.opacity;
        groupTransform.opacity *= groupTransform.op.v;
        groupTransform._opMdf = true;
      }
    };
    CVShapeElement.prototype.drawLayer = function() {
      var i;
      var len = this.stylesList.length;
      var j;
      var jLen;
      var k;
      var kLen;
      var elems;
      var nodes;
      var renderer = this.globalData.renderer;
      var ctx2 = this.globalData.canvasContext;
      var type;
      var currentStyle;
      for (i = 0; i < len; i += 1) {
        currentStyle = this.stylesList[i];
        type = currentStyle.type;
        if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
          renderer.save();
          elems = currentStyle.elements;
          if (type === "st" || type === "gs") {
            renderer.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
            renderer.ctxLineWidth(currentStyle.wi);
            renderer.ctxLineCap(currentStyle.lc);
            renderer.ctxLineJoin(currentStyle.lj);
            renderer.ctxMiterLimit(currentStyle.ml || 0);
          } else {
            renderer.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
          }
          renderer.ctxOpacity(currentStyle.coOp);
          if (type !== "st" && type !== "gs") {
            ctx2.beginPath();
          }
          renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
          jLen = elems.length;
          for (j = 0; j < jLen; j += 1) {
            if (type === "st" || type === "gs") {
              ctx2.beginPath();
              if (currentStyle.da) {
                ctx2.setLineDash(currentStyle.da);
                ctx2.lineDashOffset = currentStyle["do"];
              }
            }
            nodes = elems[j].trNodes;
            kLen = nodes.length;
            for (k = 0; k < kLen; k += 1) {
              if (nodes[k].t === "m") {
                ctx2.moveTo(nodes[k].p[0], nodes[k].p[1]);
              } else if (nodes[k].t === "c") {
                ctx2.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
              } else {
                ctx2.closePath();
              }
            }
            if (type === "st" || type === "gs") {
              renderer.ctxStroke();
              if (currentStyle.da) {
                ctx2.setLineDash(this.dashResetter);
              }
            }
          }
          if (type !== "st" && type !== "gs") {
            this.globalData.renderer.ctxFill(currentStyle.r);
          }
          renderer.restore();
        }
      }
    };
    CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
      var i;
      var len = items.length - 1;
      var groupTransform;
      groupTransform = parentTransform;
      for (i = len; i >= 0; i -= 1) {
        if (items[i].ty === "tr") {
          groupTransform = data2[i].transform;
          this.renderShapeTransform(parentTransform, groupTransform);
        } else if (items[i].ty === "sh" || items[i].ty === "el" || items[i].ty === "rc" || items[i].ty === "sr") {
          this.renderPath(items[i], data2[i]);
        } else if (items[i].ty === "fl") {
          this.renderFill(items[i], data2[i], groupTransform);
        } else if (items[i].ty === "st") {
          this.renderStroke(items[i], data2[i], groupTransform);
        } else if (items[i].ty === "gf" || items[i].ty === "gs") {
          this.renderGradientFill(items[i], data2[i], groupTransform);
        } else if (items[i].ty === "gr") {
          this.renderShape(groupTransform, items[i].it, data2[i].it);
        } else if (items[i].ty === "tm")
          ;
      }
      if (isMain) {
        this.drawLayer();
      }
    };
    CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
      if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
        var shapeNodes = styledShape.trNodes;
        var paths = shape.paths;
        var i;
        var len;
        var j;
        var jLen = paths._length;
        shapeNodes.length = 0;
        var groupTransformMat = styledShape.transforms.finalTransform;
        for (j = 0; j < jLen; j += 1) {
          var pathNodes = paths.shapes[j];
          if (pathNodes && pathNodes.v) {
            len = pathNodes._length;
            for (i = 1; i < len; i += 1) {
              if (i === 1) {
                shapeNodes.push({
                  t: "m",
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }
              shapeNodes.push({
                t: "c",
                pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
              });
            }
            if (len === 1) {
              shapeNodes.push({
                t: "m",
                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
              });
            }
            if (pathNodes.c && len) {
              shapeNodes.push({
                t: "c",
                pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
              });
              shapeNodes.push({
                t: "z"
              });
            }
          }
        }
        styledShape.trNodes = shapeNodes;
      }
    };
    CVShapeElement.prototype.renderPath = function(pathData, itemData) {
      if (pathData.hd !== true && pathData._shouldRender) {
        var i;
        var len = itemData.styledShapes.length;
        for (i = 0; i < len; i += 1) {
          this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
        }
      }
    };
    CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      if (itemData.c._mdf || this._isFirstFrame) {
        styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
      }
      if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      }
    };
    CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      var grd;
      if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
        var ctx2 = this.globalData.canvasContext;
        var pt1 = itemData.s.v;
        var pt2 = itemData.e.v;
        if (styleData.t === 1) {
          grd = ctx2.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
        } else {
          var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
          var percent = itemData.h.v;
          if (percent >= 1) {
            percent = 0.99;
          } else if (percent <= -1) {
            percent = -0.99;
          }
          var dist = rad * percent;
          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
          grd = ctx2.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
        }
        var i;
        var len = styleData.g.p;
        var cValues = itemData.g.c;
        var opacity = 1;
        for (i = 0; i < len; i += 1) {
          if (itemData.g._hasOpacity && itemData.g._collapsable) {
            opacity = itemData.g.o[i * 2 + 1];
          }
          grd.addColorStop(cValues[i * 4] / 100, "rgba(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + "," + opacity + ")");
        }
        styleElem.grd = grd;
      }
      styleElem.coOp = itemData.o.v * groupTransform.opacity;
    };
    CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      var d = itemData.d;
      if (d && (d._mdf || this._isFirstFrame)) {
        styleElem.da = d.dashArray;
        styleElem["do"] = d.dashoffset[0];
      }
      if (itemData.c._mdf || this._isFirstFrame) {
        styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
      }
      if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      }
      if (itemData.w._mdf || this._isFirstFrame) {
        styleElem.wi = itemData.w.v;
      }
    };
    CVShapeElement.prototype.destroy = function() {
      this.shapesData = null;
      this.globalData = null;
      this.canvasContext = null;
      this.stylesList.length = 0;
      this.itemsData.length = 0;
    };
    function CVTextElement(data2, globalData2, comp2) {
      this.textSpans = [];
      this.yOffset = 0;
      this.fillColorAnim = false;
      this.strokeColorAnim = false;
      this.strokeWidthAnim = false;
      this.stroke = false;
      this.fill = false;
      this.justifyOffset = 0;
      this.currentRender = null;
      this.renderType = "canvas";
      this.values = {
        fill: "rgba(0,0,0,0)",
        stroke: "rgba(0,0,0,0)",
        sWidth: 0,
        fValue: ""
      };
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
    CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
    CVTextElement.prototype.buildNewText = function() {
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
      var hasFill = false;
      if (documentData.fc) {
        hasFill = true;
        this.values.fill = this.buildColor(documentData.fc);
      } else {
        this.values.fill = "rgba(0,0,0,0)";
      }
      this.fill = hasFill;
      var hasStroke = false;
      if (documentData.sc) {
        hasStroke = true;
        this.values.stroke = this.buildColor(documentData.sc);
        this.values.sWidth = documentData.sw;
      }
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      var i;
      var len;
      var letters = documentData.l;
      var matrixHelper = this.mHelper;
      this.stroke = hasStroke;
      this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
      len = documentData.finalText.length;
      var charData;
      var shapeData;
      var k;
      var kLen;
      var shapes;
      var j;
      var jLen;
      var pathNodes;
      var commands;
      var pathArr;
      var singleShape = this.data.singleShape;
      var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
      var xPos = 0;
      var yPos = 0;
      var firstLine = true;
      var cnt = 0;
      for (i = 0; i < len; i += 1) {
        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
        shapeData = charData && charData.data || {};
        matrixHelper.reset();
        if (singleShape && letters[i].n) {
          xPos = -trackingOffset;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          firstLine = false;
        }
        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
        jLen = shapes.length;
        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
        if (singleShape) {
          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
        }
        commands = createSizedArray(jLen - 1);
        var commandsCounter = 0;
        for (j = 0; j < jLen; j += 1) {
          if (shapes[j].ty === "sh") {
            kLen = shapes[j].ks.k.i.length;
            pathNodes = shapes[j].ks.k;
            pathArr = [];
            for (k = 1; k < kLen; k += 1) {
              if (k === 1) {
                pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              }
              pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
            }
            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
            commands[commandsCounter] = pathArr;
            commandsCounter += 1;
          }
        }
        if (singleShape) {
          xPos += letters[i].l;
          xPos += trackingOffset;
        }
        if (this.textSpans[cnt]) {
          this.textSpans[cnt].elem = commands;
        } else {
          this.textSpans[cnt] = {
            elem: commands
          };
        }
        cnt += 1;
      }
    };
    CVTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var ctx2 = this.canvasContext;
      ctx2.font = this.values.fValue;
      this.globalData.renderer.ctxLineCap("butt");
      this.globalData.renderer.ctxLineJoin("miter");
      this.globalData.renderer.ctxMiterLimit(4);
      if (!this.data.singleShape) {
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      }
      var i;
      var len;
      var j;
      var jLen;
      var k;
      var kLen;
      var renderedLetters = this.textAnimator.renderedLetters;
      var letters = this.textProperty.currentData.l;
      len = letters.length;
      var renderedLetter;
      var lastFill = null;
      var lastStroke = null;
      var lastStrokeW = null;
      var commands;
      var pathArr;
      var renderer = this.globalData.renderer;
      for (i = 0; i < len; i += 1) {
        if (!letters[i].n) {
          renderedLetter = renderedLetters[i];
          if (renderedLetter) {
            renderer.save();
            renderer.ctxTransform(renderedLetter.p);
            renderer.ctxOpacity(renderedLetter.o);
          }
          if (this.fill) {
            if (renderedLetter && renderedLetter.fc) {
              if (lastFill !== renderedLetter.fc) {
                renderer.ctxFillStyle(renderedLetter.fc);
                lastFill = renderedLetter.fc;
              }
            } else if (lastFill !== this.values.fill) {
              lastFill = this.values.fill;
              renderer.ctxFillStyle(this.values.fill);
            }
            commands = this.textSpans[i].elem;
            jLen = commands.length;
            this.globalData.canvasContext.beginPath();
            for (j = 0; j < jLen; j += 1) {
              pathArr = commands[j];
              kLen = pathArr.length;
              this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
              for (k = 2; k < kLen; k += 6) {
                this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
              }
            }
            this.globalData.canvasContext.closePath();
            renderer.ctxFill();
          }
          if (this.stroke) {
            if (renderedLetter && renderedLetter.sw) {
              if (lastStrokeW !== renderedLetter.sw) {
                lastStrokeW = renderedLetter.sw;
                renderer.ctxLineWidth(renderedLetter.sw);
              }
            } else if (lastStrokeW !== this.values.sWidth) {
              lastStrokeW = this.values.sWidth;
              renderer.ctxLineWidth(this.values.sWidth);
            }
            if (renderedLetter && renderedLetter.sc) {
              if (lastStroke !== renderedLetter.sc) {
                lastStroke = renderedLetter.sc;
                renderer.ctxStrokeStyle(renderedLetter.sc);
              }
            } else if (lastStroke !== this.values.stroke) {
              lastStroke = this.values.stroke;
              renderer.ctxStrokeStyle(this.values.stroke);
            }
            commands = this.textSpans[i].elem;
            jLen = commands.length;
            this.globalData.canvasContext.beginPath();
            for (j = 0; j < jLen; j += 1) {
              pathArr = commands[j];
              kLen = pathArr.length;
              this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
              for (k = 2; k < kLen; k += 6) {
                this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
              }
            }
            this.globalData.canvasContext.closePath();
            renderer.ctxStroke();
          }
          if (renderedLetter) {
            this.globalData.renderer.restore();
          }
        }
      }
    };
    function CVImageElement(data2, globalData2, comp2) {
      this.assetData = globalData2.getAssetData(data2.refId);
      this.img = globalData2.imageLoader.getAsset(this.assetData);
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
    CVImageElement.prototype.createContent = function() {
      if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
        var canvas2 = createTag("canvas");
        canvas2.width = this.assetData.w;
        canvas2.height = this.assetData.h;
        var ctx2 = canvas2.getContext("2d");
        var imgW = this.img.width;
        var imgH = this.img.height;
        var imgRel = imgW / imgH;
        var canvasRel = this.assetData.w / this.assetData.h;
        var widthCrop;
        var heightCrop;
        var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
        if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
          heightCrop = imgH;
          widthCrop = heightCrop * canvasRel;
        } else {
          widthCrop = imgW;
          heightCrop = widthCrop / canvasRel;
        }
        ctx2.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
        this.img = canvas2;
      }
    };
    CVImageElement.prototype.renderInnerContent = function() {
      this.canvasContext.drawImage(this.img, 0, 0);
    };
    CVImageElement.prototype.destroy = function() {
      this.img = null;
    };
    function CVSolidElement(data2, globalData2, comp2) {
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
    CVSolidElement.prototype.renderInnerContent = function() {
      this.globalData.renderer.ctxFillStyle(this.data.sc);
      this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
    };
    function CanvasRendererBase() {
    }
    extendPrototype([BaseRenderer], CanvasRendererBase);
    CanvasRendererBase.prototype.createShape = function(data2) {
      return new CVShapeElement(data2, this.globalData, this);
    };
    CanvasRendererBase.prototype.createText = function(data2) {
      return new CVTextElement(data2, this.globalData, this);
    };
    CanvasRendererBase.prototype.createImage = function(data2) {
      return new CVImageElement(data2, this.globalData, this);
    };
    CanvasRendererBase.prototype.createSolid = function(data2) {
      return new CVSolidElement(data2, this.globalData, this);
    };
    CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
    CanvasRendererBase.prototype.ctxTransform = function(props) {
      if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
        return;
      }
      this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
    };
    CanvasRendererBase.prototype.ctxOpacity = function(op) {
      this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
    };
    CanvasRendererBase.prototype.ctxFillStyle = function(value2) {
      this.canvasContext.fillStyle = value2;
    };
    CanvasRendererBase.prototype.ctxStrokeStyle = function(value2) {
      this.canvasContext.strokeStyle = value2;
    };
    CanvasRendererBase.prototype.ctxLineWidth = function(value2) {
      this.canvasContext.lineWidth = value2;
    };
    CanvasRendererBase.prototype.ctxLineCap = function(value2) {
      this.canvasContext.lineCap = value2;
    };
    CanvasRendererBase.prototype.ctxLineJoin = function(value2) {
      this.canvasContext.lineJoin = value2;
    };
    CanvasRendererBase.prototype.ctxMiterLimit = function(value2) {
      this.canvasContext.miterLimit = value2;
    };
    CanvasRendererBase.prototype.ctxFill = function(rule) {
      this.canvasContext.fill(rule);
    };
    CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h3) {
      this.canvasContext.fillRect(x, y, w, h3);
    };
    CanvasRendererBase.prototype.ctxStroke = function() {
      this.canvasContext.stroke();
    };
    CanvasRendererBase.prototype.reset = function() {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      this.contextData.reset();
    };
    CanvasRendererBase.prototype.save = function() {
      this.canvasContext.save();
    };
    CanvasRendererBase.prototype.restore = function(actionFlag) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      if (actionFlag) {
        this.globalData.blendMode = "source-over";
      }
      this.contextData.restore(actionFlag);
    };
    CanvasRendererBase.prototype.configAnimation = function(animData) {
      if (this.animationItem.wrapper) {
        this.animationItem.container = createTag("canvas");
        var containerStyle = this.animationItem.container.style;
        containerStyle.width = "100%";
        containerStyle.height = "100%";
        var origin2 = "0px 0px 0px";
        containerStyle.transformOrigin = origin2;
        containerStyle.mozTransformOrigin = origin2;
        containerStyle.webkitTransformOrigin = origin2;
        containerStyle["-webkit-transform"] = origin2;
        containerStyle.contentVisibility = this.renderConfig.contentVisibility;
        this.animationItem.wrapper.appendChild(this.animationItem.container);
        this.canvasContext = this.animationItem.container.getContext("2d");
        if (this.renderConfig.className) {
          this.animationItem.container.setAttribute("class", this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.animationItem.container.setAttribute("id", this.renderConfig.id);
        }
      } else {
        this.canvasContext = this.renderConfig.context;
      }
      this.contextData.setContext(this.canvasContext);
      this.data = animData;
      this.layers = animData.layers;
      this.transformCanvas = {
        w: animData.w,
        h: animData.h,
        sx: 0,
        sy: 0,
        tx: 0,
        ty: 0
      };
      this.setupGlobalData(animData, document.body);
      this.globalData.canvasContext = this.canvasContext;
      this.globalData.renderer = this;
      this.globalData.isDashed = false;
      this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
      this.globalData.transformCanvas = this.transformCanvas;
      this.elements = createSizedArray(animData.layers.length);
      this.updateContainerSize();
    };
    CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
      this.reset();
      var elementWidth;
      var elementHeight;
      if (width2) {
        elementWidth = width2;
        elementHeight = height2;
        this.canvasContext.canvas.width = elementWidth;
        this.canvasContext.canvas.height = elementHeight;
      } else {
        if (this.animationItem.wrapper && this.animationItem.container) {
          elementWidth = this.animationItem.wrapper.offsetWidth;
          elementHeight = this.animationItem.wrapper.offsetHeight;
        } else {
          elementWidth = this.canvasContext.canvas.width;
          elementHeight = this.canvasContext.canvas.height;
        }
        this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
        this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
      }
      var elementRel;
      var animationRel;
      if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
        var par = this.renderConfig.preserveAspectRatio.split(" ");
        var fillType = par[1] || "meet";
        var pos = par[0] || "xMidYMid";
        var xPos = pos.substr(0, 4);
        var yPos = pos.substr(4);
        elementRel = elementWidth / elementHeight;
        animationRel = this.transformCanvas.w / this.transformCanvas.h;
        if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        } else {
          this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        }
        if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
          this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
        } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
          this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
        } else {
          this.transformCanvas.tx = 0;
        }
        if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
          this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
        } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
          this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
        } else {
          this.transformCanvas.ty = 0;
        }
      } else if (this.renderConfig.preserveAspectRatio === "none") {
        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        this.transformCanvas.tx = 0;
        this.transformCanvas.ty = 0;
      } else {
        this.transformCanvas.sx = this.renderConfig.dpr;
        this.transformCanvas.sy = this.renderConfig.dpr;
        this.transformCanvas.tx = 0;
        this.transformCanvas.ty = 0;
      }
      this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
      this.ctxTransform(this.transformCanvas.props);
      this.canvasContext.beginPath();
      this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
      this.canvasContext.closePath();
      this.canvasContext.clip();
      this.renderFrame(this.renderedFrame, true);
    };
    CanvasRendererBase.prototype.destroy = function() {
      if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = "";
      }
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.elements[i] && this.elements[i].destroy) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.globalData.canvasContext = null;
      this.animationItem.container = null;
      this.destroyed = true;
    };
    CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
      if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
        return;
      }
      this.renderedFrame = num;
      this.globalData.frameNum = num - this.animationItem._isFirstFrame;
      this.globalData.frameId += 1;
      this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
      this.globalData.projectInterface.currentFrame = num;
      var i;
      var len = this.layers.length;
      if (!this.completeLayers) {
        this.checkLayers(num);
      }
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(num - this.layers[i].st);
        }
      }
      if (this.globalData._mdf) {
        if (this.renderConfig.clearCanvas === true) {
          this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        } else {
          this.save();
        }
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
        if (this.renderConfig.clearCanvas !== true) {
          this.restore();
        }
      }
    };
    CanvasRendererBase.prototype.buildItem = function(pos) {
      var elements2 = this.elements;
      if (elements2[pos] || this.layers[pos].ty === 99) {
        return;
      }
      var element = this.createItem(this.layers[pos], this, this.globalData);
      elements2[pos] = element;
      element.initExpressions();
    };
    CanvasRendererBase.prototype.checkPendingElements = function() {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
      }
    };
    CanvasRendererBase.prototype.hide = function() {
      this.animationItem.container.style.display = "none";
    };
    CanvasRendererBase.prototype.show = function() {
      this.animationItem.container.style.display = "block";
    };
    function CanvasContext() {
      this.opacity = -1;
      this.transform = createTypedArray("float32", 16);
      this.fillStyle = "";
      this.strokeStyle = "";
      this.lineWidth = "";
      this.lineCap = "";
      this.lineJoin = "";
      this.miterLimit = "";
      this.id = Math.random();
    }
    function CVContextData() {
      this.stack = [];
      this.cArrPos = 0;
      this.cTr = new Matrix();
      var i;
      var len = 15;
      for (i = 0; i < len; i += 1) {
        var canvasContext = new CanvasContext();
        this.stack[i] = canvasContext;
      }
      this._length = len;
      this.nativeContext = null;
      this.transformMat = new Matrix();
      this.currentOpacity = 1;
      this.currentFillStyle = "";
      this.appliedFillStyle = "";
      this.currentStrokeStyle = "";
      this.appliedStrokeStyle = "";
      this.currentLineWidth = "";
      this.appliedLineWidth = "";
      this.currentLineCap = "";
      this.appliedLineCap = "";
      this.currentLineJoin = "";
      this.appliedLineJoin = "";
      this.appliedMiterLimit = "";
      this.currentMiterLimit = "";
    }
    CVContextData.prototype.duplicate = function() {
      var newLength = this._length * 2;
      var i = 0;
      for (i = this._length; i < newLength; i += 1) {
        this.stack[i] = new CanvasContext();
      }
      this._length = newLength;
    };
    CVContextData.prototype.reset = function() {
      this.cArrPos = 0;
      this.cTr.reset();
      this.stack[this.cArrPos].opacity = 1;
    };
    CVContextData.prototype.restore = function(forceRestore) {
      this.cArrPos -= 1;
      var currentContext = this.stack[this.cArrPos];
      var transform2 = currentContext.transform;
      var i;
      var arr = this.cTr.props;
      for (i = 0; i < 16; i += 1) {
        arr[i] = transform2[i];
      }
      if (forceRestore) {
        this.nativeContext.restore();
        var prevStack = this.stack[this.cArrPos + 1];
        this.appliedFillStyle = prevStack.fillStyle;
        this.appliedStrokeStyle = prevStack.strokeStyle;
        this.appliedLineWidth = prevStack.lineWidth;
        this.appliedLineCap = prevStack.lineCap;
        this.appliedLineJoin = prevStack.lineJoin;
        this.appliedMiterLimit = prevStack.miterLimit;
      }
      this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
      if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
        this.nativeContext.globalAlpha = currentContext.opacity;
        this.currentOpacity = currentContext.opacity;
      }
      this.currentFillStyle = currentContext.fillStyle;
      this.currentStrokeStyle = currentContext.strokeStyle;
      this.currentLineWidth = currentContext.lineWidth;
      this.currentLineCap = currentContext.lineCap;
      this.currentLineJoin = currentContext.lineJoin;
      this.currentMiterLimit = currentContext.miterLimit;
    };
    CVContextData.prototype.save = function(saveOnNativeFlag) {
      if (saveOnNativeFlag) {
        this.nativeContext.save();
      }
      var props = this.cTr.props;
      if (this._length <= this.cArrPos) {
        this.duplicate();
      }
      var currentStack = this.stack[this.cArrPos];
      var i;
      for (i = 0; i < 16; i += 1) {
        currentStack.transform[i] = props[i];
      }
      this.cArrPos += 1;
      var newStack = this.stack[this.cArrPos];
      newStack.opacity = currentStack.opacity;
      newStack.fillStyle = currentStack.fillStyle;
      newStack.strokeStyle = currentStack.strokeStyle;
      newStack.lineWidth = currentStack.lineWidth;
      newStack.lineCap = currentStack.lineCap;
      newStack.lineJoin = currentStack.lineJoin;
      newStack.miterLimit = currentStack.miterLimit;
    };
    CVContextData.prototype.setOpacity = function(value2) {
      this.stack[this.cArrPos].opacity = value2;
    };
    CVContextData.prototype.setContext = function(value2) {
      this.nativeContext = value2;
    };
    CVContextData.prototype.fillStyle = function(value2) {
      if (this.stack[this.cArrPos].fillStyle !== value2) {
        this.currentFillStyle = value2;
        this.stack[this.cArrPos].fillStyle = value2;
      }
    };
    CVContextData.prototype.strokeStyle = function(value2) {
      if (this.stack[this.cArrPos].strokeStyle !== value2) {
        this.currentStrokeStyle = value2;
        this.stack[this.cArrPos].strokeStyle = value2;
      }
    };
    CVContextData.prototype.lineWidth = function(value2) {
      if (this.stack[this.cArrPos].lineWidth !== value2) {
        this.currentLineWidth = value2;
        this.stack[this.cArrPos].lineWidth = value2;
      }
    };
    CVContextData.prototype.lineCap = function(value2) {
      if (this.stack[this.cArrPos].lineCap !== value2) {
        this.currentLineCap = value2;
        this.stack[this.cArrPos].lineCap = value2;
      }
    };
    CVContextData.prototype.lineJoin = function(value2) {
      if (this.stack[this.cArrPos].lineJoin !== value2) {
        this.currentLineJoin = value2;
        this.stack[this.cArrPos].lineJoin = value2;
      }
    };
    CVContextData.prototype.miterLimit = function(value2) {
      if (this.stack[this.cArrPos].miterLimit !== value2) {
        this.currentMiterLimit = value2;
        this.stack[this.cArrPos].miterLimit = value2;
      }
    };
    CVContextData.prototype.transform = function(props) {
      this.transformMat.cloneFromProps(props);
      var currentTransform = this.cTr;
      this.transformMat.multiply(currentTransform);
      currentTransform.cloneFromProps(this.transformMat.props);
      var trProps = currentTransform.props;
      this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
    };
    CVContextData.prototype.opacity = function(op) {
      var currentOpacity = this.stack[this.cArrPos].opacity;
      currentOpacity *= op < 0 ? 0 : op;
      if (this.stack[this.cArrPos].opacity !== currentOpacity) {
        if (this.currentOpacity !== op) {
          this.nativeContext.globalAlpha = op;
          this.currentOpacity = op;
        }
        this.stack[this.cArrPos].opacity = currentOpacity;
      }
    };
    CVContextData.prototype.fill = function(rule) {
      if (this.appliedFillStyle !== this.currentFillStyle) {
        this.appliedFillStyle = this.currentFillStyle;
        this.nativeContext.fillStyle = this.appliedFillStyle;
      }
      this.nativeContext.fill(rule);
    };
    CVContextData.prototype.fillRect = function(x, y, w, h3) {
      if (this.appliedFillStyle !== this.currentFillStyle) {
        this.appliedFillStyle = this.currentFillStyle;
        this.nativeContext.fillStyle = this.appliedFillStyle;
      }
      this.nativeContext.fillRect(x, y, w, h3);
    };
    CVContextData.prototype.stroke = function() {
      if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
        this.appliedStrokeStyle = this.currentStrokeStyle;
        this.nativeContext.strokeStyle = this.appliedStrokeStyle;
      }
      if (this.appliedLineWidth !== this.currentLineWidth) {
        this.appliedLineWidth = this.currentLineWidth;
        this.nativeContext.lineWidth = this.appliedLineWidth;
      }
      if (this.appliedLineCap !== this.currentLineCap) {
        this.appliedLineCap = this.currentLineCap;
        this.nativeContext.lineCap = this.appliedLineCap;
      }
      if (this.appliedLineJoin !== this.currentLineJoin) {
        this.appliedLineJoin = this.currentLineJoin;
        this.nativeContext.lineJoin = this.appliedLineJoin;
      }
      if (this.appliedMiterLimit !== this.currentMiterLimit) {
        this.appliedMiterLimit = this.currentMiterLimit;
        this.nativeContext.miterLimit = this.appliedMiterLimit;
      }
      this.nativeContext.stroke();
    };
    function CVCompElement(data2, globalData2, comp2) {
      this.completeLayers = false;
      this.layers = data2.layers;
      this.pendingElements = [];
      this.elements = createSizedArray(this.layers.length);
      this.initElement(data2, globalData2, comp2);
      this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
        _placeholder: true
      };
    }
    extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
    CVCompElement.prototype.renderInnerContent = function() {
      var ctx2 = this.canvasContext;
      ctx2.beginPath();
      ctx2.moveTo(0, 0);
      ctx2.lineTo(this.data.w, 0);
      ctx2.lineTo(this.data.w, this.data.h);
      ctx2.lineTo(0, this.data.h);
      ctx2.lineTo(0, 0);
      ctx2.clip();
      var i;
      var len = this.layers.length;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    };
    CVCompElement.prototype.destroy = function() {
      var i;
      var len = this.layers.length;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
      this.layers = null;
      this.elements = null;
    };
    CVCompElement.prototype.createComp = function(data2) {
      return new CVCompElement(data2, this.globalData, this);
    };
    function CanvasRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.renderConfig = {
        clearCanvas: config && config.clearCanvas !== void 0 ? config.clearCanvas : true,
        context: config && config.context || null,
        progressiveLoad: config && config.progressiveLoad || false,
        preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: config && config.contentVisibility || "visible",
        className: config && config.className || "",
        id: config && config.id || "",
        runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
      };
      this.renderConfig.dpr = config && config.dpr || 1;
      if (this.animationItem.wrapper) {
        this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
      }
      this.renderedFrame = -1;
      this.globalData = {
        frameNum: -1,
        _mdf: false,
        renderConfig: this.renderConfig,
        currentGlobalAlpha: -1
      };
      this.contextData = new CVContextData();
      this.elements = [];
      this.pendingElements = [];
      this.transformMat = new Matrix();
      this.completeLayers = false;
      this.rendererType = "canvas";
      if (this.renderConfig.clearCanvas) {
        this.ctxTransform = this.contextData.transform.bind(this.contextData);
        this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
        this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
        this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
        this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
        this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
        this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
        this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
        this.ctxFill = this.contextData.fill.bind(this.contextData);
        this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
        this.ctxStroke = this.contextData.stroke.bind(this.contextData);
        this.save = this.contextData.save.bind(this.contextData);
      }
    }
    extendPrototype([CanvasRendererBase], CanvasRenderer);
    CanvasRenderer.prototype.createComp = function(data2) {
      return new CVCompElement(data2, this.globalData, this);
    };
    function HBaseElement() {
    }
    HBaseElement.prototype = {
      checkBlendMode: function checkBlendMode() {
      },
      initRendererElement: function initRendererElement() {
        this.baseElement = createTag(this.data.tg || "div");
        if (this.data.hasMask) {
          this.svgElement = createNS("svg");
          this.layerElement = createNS("g");
          this.maskedElement = this.layerElement;
          this.svgElement.appendChild(this.layerElement);
          this.baseElement.appendChild(this.svgElement);
        } else {
          this.layerElement = this.baseElement;
        }
        styleDiv(this.baseElement);
      },
      createContainerElements: function createContainerElements() {
        this.renderableEffectsManager = new CVEffects(this);
        this.transformedElement = this.baseElement;
        this.maskedElement = this.layerElement;
        if (this.data.ln) {
          this.layerElement.setAttribute("id", this.data.ln);
        }
        if (this.data.cl) {
          this.layerElement.setAttribute("class", this.data.cl);
        }
        if (this.data.bm !== 0) {
          this.setBlendMode();
        }
      },
      renderElement: function renderElement() {
        var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
        if (this.finalTransform._matMdf) {
          var matrixValue = this.finalTransform.mat.toCSS();
          transformedElementStyle.transform = matrixValue;
          transformedElementStyle.webkitTransform = matrixValue;
        }
        if (this.finalTransform._opMdf) {
          transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
        }
      },
      renderFrame: function renderFrame() {
        if (this.data.hd || this.hidden) {
          return;
        }
        this.renderTransform();
        this.renderRenderable();
        this.renderElement();
        this.renderInnerContent();
        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      destroy: function destroy() {
        this.layerElement = null;
        this.transformedElement = null;
        if (this.matteElement) {
          this.matteElement = null;
        }
        if (this.maskManager) {
          this.maskManager.destroy();
          this.maskManager = null;
        }
      },
      createRenderableComponents: function createRenderableComponents() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
      },
      addEffects: function addEffects() {
      },
      setMatte: function setMatte() {
      }
    };
    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
    HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
    function HSolidElement(data2, globalData2, comp2) {
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
    HSolidElement.prototype.createContent = function() {
      var rect;
      if (this.data.hasMask) {
        rect = createNS("rect");
        rect.setAttribute("width", this.data.sw);
        rect.setAttribute("height", this.data.sh);
        rect.setAttribute("fill", this.data.sc);
        this.svgElement.setAttribute("width", this.data.sw);
        this.svgElement.setAttribute("height", this.data.sh);
      } else {
        rect = createTag("div");
        rect.style.width = this.data.sw + "px";
        rect.style.height = this.data.sh + "px";
        rect.style.backgroundColor = this.data.sc;
      }
      this.layerElement.appendChild(rect);
    };
    function HShapeElement(data2, globalData2, comp2) {
      this.shapes = [];
      this.shapesData = data2.shapes;
      this.stylesList = [];
      this.shapeModifiers = [];
      this.itemsData = [];
      this.processedElements = [];
      this.animatedContents = [];
      this.shapesContainer = createNS("g");
      this.initElement(data2, globalData2, comp2);
      this.prevViewData = [];
      this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
    }
    extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
    HShapeElement.prototype.createContent = function() {
      var cont;
      this.baseElement.style.fontSize = 0;
      if (this.data.hasMask) {
        this.layerElement.appendChild(this.shapesContainer);
        cont = this.svgElement;
      } else {
        cont = createNS("svg");
        var size = this.comp.data ? this.comp.data : this.globalData.compSize;
        cont.setAttribute("width", size.w);
        cont.setAttribute("height", size.h);
        cont.appendChild(this.shapesContainer);
        this.layerElement.appendChild(cont);
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
      this.filterUniqueShapes();
      this.shapeCont = cont;
    };
    HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
      var i;
      var len = transformers.length;
      for (i = 0; i < len; i += 1) {
        point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
      }
      return point;
    };
    HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
      var shape = item.sh.v;
      var transformers = item.transformers;
      var i;
      var len = shape._length;
      var vPoint;
      var oPoint;
      var nextIPoint;
      var nextVPoint;
      if (len <= 1) {
        return;
      }
      for (i = 0; i < len - 1; i += 1) {
        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
        nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
        nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
      }
      if (shape.c) {
        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
        nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
        nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
      }
    };
    HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
      this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
      var bounds = this.shapeBoundingBox;
      boundingBox.x = bmMin(bounds.left, boundingBox.x);
      boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
      boundingBox.y = bmMin(bounds.top, boundingBox.y);
      boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
    };
    HShapeElement.prototype.shapeBoundingBox = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    HShapeElement.prototype.tempBoundingBox = {
      x: 0,
      xMax: 0,
      y: 0,
      yMax: 0,
      width: 0,
      height: 0
    };
    HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
      var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
      for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
        b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        c = 3 * p1[i] - 3 * p0[i];
        b |= 0;
        a |= 0;
        c |= 0;
        if (a === 0 && b === 0)
          ;
        else if (a === 0) {
          t = -c / b;
          if (t > 0 && t < 1) {
            bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
          }
        } else {
          b2ac = b * b - 4 * c * a;
          if (b2ac >= 0) {
            t1 = (-b + bmSqrt(b2ac)) / (2 * a);
            if (t1 > 0 && t1 < 1)
              bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
            t2 = (-b - bmSqrt(b2ac)) / (2 * a);
            if (t2 > 0 && t2 < 1)
              bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
          }
        }
      }
      this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
      this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
      this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
      this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
    };
    HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
      return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
    };
    HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
      var i;
      var len = itemsData.length;
      for (i = 0; i < len; i += 1) {
        if (itemsData[i] && itemsData[i].sh) {
          this.calculateShapeBoundingBox(itemsData[i], boundingBox);
        } else if (itemsData[i] && itemsData[i].it) {
          this.calculateBoundingBox(itemsData[i].it, boundingBox);
        } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
          this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
        }
      }
    };
    HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
      var width2 = 0;
      if (widthProperty.keyframes) {
        for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
          var kfw = widthProperty.keyframes[i].s;
          if (kfw > width2) {
            width2 = kfw;
          }
        }
        width2 *= widthProperty.mult;
      } else {
        width2 = widthProperty.v * widthProperty.mult;
      }
      boundingBox.x -= width2;
      boundingBox.xMax += width2;
      boundingBox.y -= width2;
      boundingBox.yMax += width2;
    };
    HShapeElement.prototype.currentBoxContains = function(box) {
      return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
    };
    HShapeElement.prototype.renderInnerContent = function() {
      this._renderShapeFrame();
      if (!this.hidden && (this._isFirstFrame || this._mdf)) {
        var tempBoundingBox = this.tempBoundingBox;
        var max = 999999;
        tempBoundingBox.x = max;
        tempBoundingBox.xMax = -max;
        tempBoundingBox.y = max;
        tempBoundingBox.yMax = -max;
        this.calculateBoundingBox(this.itemsData, tempBoundingBox);
        tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
        tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
        if (this.currentBoxContains(tempBoundingBox)) {
          return;
        }
        var changed = false;
        if (this.currentBBox.w !== tempBoundingBox.width) {
          this.currentBBox.w = tempBoundingBox.width;
          this.shapeCont.setAttribute("width", tempBoundingBox.width);
          changed = true;
        }
        if (this.currentBBox.h !== tempBoundingBox.height) {
          this.currentBBox.h = tempBoundingBox.height;
          this.shapeCont.setAttribute("height", tempBoundingBox.height);
          changed = true;
        }
        if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
          this.currentBBox.w = tempBoundingBox.width;
          this.currentBBox.h = tempBoundingBox.height;
          this.currentBBox.x = tempBoundingBox.x;
          this.currentBBox.y = tempBoundingBox.y;
          this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
          var shapeStyle = this.shapeCont.style;
          var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
          shapeStyle.transform = shapeTransform;
          shapeStyle.webkitTransform = shapeTransform;
        }
      }
    };
    function HTextElement(data2, globalData2, comp2) {
      this.textSpans = [];
      this.textPaths = [];
      this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
      this.renderType = "svg";
      this.isMasked = false;
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
    HTextElement.prototype.createContent = function() {
      this.isMasked = this.checkMasks();
      if (this.isMasked) {
        this.renderType = "svg";
        this.compW = this.comp.data.w;
        this.compH = this.comp.data.h;
        this.svgElement.setAttribute("width", this.compW);
        this.svgElement.setAttribute("height", this.compH);
        var g = createNS("g");
        this.maskedElement.appendChild(g);
        this.innerElem = g;
      } else {
        this.renderType = "html";
        this.innerElem = this.layerElement;
      }
      this.checkParenting();
    };
    HTextElement.prototype.buildNewText = function() {
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
      var innerElemStyle = this.innerElem.style;
      var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
      innerElemStyle.fill = textColor;
      innerElemStyle.color = textColor;
      if (documentData.sc) {
        innerElemStyle.stroke = this.buildColor(documentData.sc);
        innerElemStyle.strokeWidth = documentData.sw + "px";
      }
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      if (!this.globalData.fontManager.chars) {
        innerElemStyle.fontSize = documentData.finalSize + "px";
        innerElemStyle.lineHeight = documentData.finalSize + "px";
        if (fontData.fClass) {
          this.innerElem.className = fontData.fClass;
        } else {
          innerElemStyle.fontFamily = fontData.fFamily;
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          innerElemStyle.fontStyle = fStyle;
          innerElemStyle.fontWeight = fWeight;
        }
      }
      var i;
      var len;
      var letters = documentData.l;
      len = letters.length;
      var tSpan;
      var tParent;
      var tCont;
      var matrixHelper = this.mHelper;
      var shapes;
      var shapeStr = "";
      var cnt = 0;
      for (i = 0; i < len; i += 1) {
        if (this.globalData.fontManager.chars) {
          if (!this.textPaths[cnt]) {
            tSpan = createNS("path");
            tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
            tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
            tSpan.setAttribute("stroke-miterlimit", "4");
          } else {
            tSpan = this.textPaths[cnt];
          }
          if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tCont = tParent.children[0];
            } else {
              tParent = createTag("div");
              tParent.style.lineHeight = 0;
              tCont = createNS("svg");
              tCont.appendChild(tSpan);
              styleDiv(tParent);
            }
          }
        } else if (!this.isMasked) {
          if (this.textSpans[cnt]) {
            tParent = this.textSpans[cnt];
            tSpan = this.textPaths[cnt];
          } else {
            tParent = createTag("span");
            styleDiv(tParent);
            tSpan = createTag("span");
            styleDiv(tSpan);
            tParent.appendChild(tSpan);
          }
        } else {
          tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
        }
        if (this.globalData.fontManager.chars) {
          var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          var shapeData;
          if (charData) {
            shapeData = charData.data;
          } else {
            shapeData = null;
          }
          matrixHelper.reset();
          if (shapeData && shapeData.shapes && shapeData.shapes.length) {
            shapes = shapeData.shapes[0].it;
            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
            shapeStr = this.createPathShape(matrixHelper, shapes);
            tSpan.setAttribute("d", shapeStr);
          }
          if (!this.isMasked) {
            this.innerElem.appendChild(tParent);
            if (shapeData && shapeData.shapes) {
              document.body.appendChild(tCont);
              var boundingBox = tCont.getBBox();
              tCont.setAttribute("width", boundingBox.width + 2);
              tCont.setAttribute("height", boundingBox.height + 2);
              tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
              var tContStyle = tCont.style;
              var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
              tContStyle.transform = tContTranslation;
              tContStyle.webkitTransform = tContTranslation;
              letters[i].yOffset = boundingBox.y - 1;
            } else {
              tCont.setAttribute("width", 1);
              tCont.setAttribute("height", 1);
            }
            tParent.appendChild(tCont);
          } else {
            this.innerElem.appendChild(tSpan);
          }
        } else {
          tSpan.textContent = letters[i].val;
          tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
          if (!this.isMasked) {
            this.innerElem.appendChild(tParent);
            var tStyle = tSpan.style;
            var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
            tStyle.transform = tSpanTranslation;
            tStyle.webkitTransform = tSpanTranslation;
          } else {
            this.innerElem.appendChild(tSpan);
          }
        }
        if (!this.isMasked) {
          this.textSpans[cnt] = tParent;
        } else {
          this.textSpans[cnt] = tSpan;
        }
        this.textSpans[cnt].style.display = "block";
        this.textPaths[cnt] = tSpan;
        cnt += 1;
      }
      while (cnt < this.textSpans.length) {
        this.textSpans[cnt].style.display = "none";
        cnt += 1;
      }
    };
    HTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var svgStyle;
      if (this.data.singleShape) {
        if (!this._isFirstFrame && !this.lettersChangedFlag) {
          return;
        }
        if (this.isMasked && this.finalTransform._matMdf) {
          this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
          svgStyle = this.svgElement.style;
          var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
          svgStyle.transform = translation;
          svgStyle.webkitTransform = translation;
        }
      }
      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
        return;
      }
      var i;
      var len;
      var count = 0;
      var renderedLetters = this.textAnimator.renderedLetters;
      var letters = this.textProperty.currentData.l;
      len = letters.length;
      var renderedLetter;
      var textSpan;
      var textPath;
      for (i = 0; i < len; i += 1) {
        if (letters[i].n) {
          count += 1;
        } else {
          textSpan = this.textSpans[i];
          textPath = this.textPaths[i];
          renderedLetter = renderedLetters[count];
          count += 1;
          if (renderedLetter._mdf.m) {
            if (!this.isMasked) {
              textSpan.style.webkitTransform = renderedLetter.m;
              textSpan.style.transform = renderedLetter.m;
            } else {
              textSpan.setAttribute("transform", renderedLetter.m);
            }
          }
          textSpan.style.opacity = renderedLetter.o;
          if (renderedLetter.sw && renderedLetter._mdf.sw) {
            textPath.setAttribute("stroke-width", renderedLetter.sw);
          }
          if (renderedLetter.sc && renderedLetter._mdf.sc) {
            textPath.setAttribute("stroke", renderedLetter.sc);
          }
          if (renderedLetter.fc && renderedLetter._mdf.fc) {
            textPath.setAttribute("fill", renderedLetter.fc);
            textPath.style.color = renderedLetter.fc;
          }
        }
      }
      if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
        var boundingBox = this.innerElem.getBBox();
        if (this.currentBBox.w !== boundingBox.width) {
          this.currentBBox.w = boundingBox.width;
          this.svgElement.setAttribute("width", boundingBox.width);
        }
        if (this.currentBBox.h !== boundingBox.height) {
          this.currentBBox.h = boundingBox.height;
          this.svgElement.setAttribute("height", boundingBox.height);
        }
        var margin = 1;
        if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
          this.currentBBox.w = boundingBox.width + margin * 2;
          this.currentBBox.h = boundingBox.height + margin * 2;
          this.currentBBox.x = boundingBox.x - margin;
          this.currentBBox.y = boundingBox.y - margin;
          this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
          svgStyle = this.svgElement.style;
          var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
          svgStyle.transform = svgTransform;
          svgStyle.webkitTransform = svgTransform;
        }
      }
    };
    function HCameraElement(data2, globalData2, comp2) {
      this.initFrame();
      this.initBaseData(data2, globalData2, comp2);
      this.initHierarchy();
      var getProp = PropertyFactory.getProp;
      this.pe = getProp(this, data2.pe, 0, 0, this);
      if (data2.ks.p.s) {
        this.px = getProp(this, data2.ks.p.x, 1, 0, this);
        this.py = getProp(this, data2.ks.p.y, 1, 0, this);
        this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
      } else {
        this.p = getProp(this, data2.ks.p, 1, 0, this);
      }
      if (data2.ks.a) {
        this.a = getProp(this, data2.ks.a, 1, 0, this);
      }
      if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
        var i;
        var len = data2.ks.or.k.length;
        for (i = 0; i < len; i += 1) {
          data2.ks.or.k[i].to = null;
          data2.ks.or.k[i].ti = null;
        }
      }
      this.or = getProp(this, data2.ks.or, 1, degToRads, this);
      this.or.sh = true;
      this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
      this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
      this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
      this.mat = new Matrix();
      this._prevMat = new Matrix();
      this._isFirstFrame = true;
      this.finalTransform = {
        mProp: this
      };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
    HCameraElement.prototype.setup = function() {
      var i;
      var len = this.comp.threeDElements.length;
      var comp2;
      var perspectiveStyle;
      var containerStyle;
      for (i = 0; i < len; i += 1) {
        comp2 = this.comp.threeDElements[i];
        if (comp2.type === "3d") {
          perspectiveStyle = comp2.perspectiveElem.style;
          containerStyle = comp2.container.style;
          var perspective = this.pe.v + "px";
          var origin2 = "0px 0px 0px";
          var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          perspectiveStyle.perspective = perspective;
          perspectiveStyle.webkitPerspective = perspective;
          containerStyle.transformOrigin = origin2;
          containerStyle.mozTransformOrigin = origin2;
          containerStyle.webkitTransformOrigin = origin2;
          perspectiveStyle.transform = matrix;
          perspectiveStyle.webkitTransform = matrix;
        }
      }
    };
    HCameraElement.prototype.createElements = function() {
    };
    HCameraElement.prototype.hide = function() {
    };
    HCameraElement.prototype.renderFrame = function() {
      var _mdf = this._isFirstFrame;
      var i;
      var len;
      if (this.hierarchy) {
        len = this.hierarchy.length;
        for (i = 0; i < len; i += 1) {
          _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
        }
      }
      if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
        this.mat.reset();
        if (this.hierarchy) {
          len = this.hierarchy.length - 1;
          for (i = len; i >= 0; i -= 1) {
            var mTransf = this.hierarchy[i].finalTransform.mProp;
            this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
            this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
            this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
            this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
            this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
          }
        }
        if (this.p) {
          this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
        } else {
          this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
        }
        if (this.a) {
          var diffVector;
          if (this.p) {
            diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
          } else {
            diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
          }
          var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
          var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
          var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
          var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
          var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
          this.mat.rotateY(mRotationY).rotateX(-mRotationX);
        }
        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
        this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
        this.mat.translate(0, 0, this.pe.v);
        var hasMatrixChanged = !this._prevMat.equals(this.mat);
        if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
          len = this.comp.threeDElements.length;
          var comp2;
          var perspectiveStyle;
          var containerStyle;
          for (i = 0; i < len; i += 1) {
            comp2 = this.comp.threeDElements[i];
            if (comp2.type === "3d") {
              if (hasMatrixChanged) {
                var matValue = this.mat.toCSS();
                containerStyle = comp2.container.style;
                containerStyle.transform = matValue;
                containerStyle.webkitTransform = matValue;
              }
              if (this.pe._mdf) {
                perspectiveStyle = comp2.perspectiveElem.style;
                perspectiveStyle.perspective = this.pe.v + "px";
                perspectiveStyle.webkitPerspective = this.pe.v + "px";
              }
            }
          }
          this.mat.clone(this._prevMat);
        }
      }
      this._isFirstFrame = false;
    };
    HCameraElement.prototype.prepareFrame = function(num) {
      this.prepareProperties(num, true);
    };
    HCameraElement.prototype.destroy = function() {
    };
    HCameraElement.prototype.getBaseElement = function() {
      return null;
    };
    function HImageElement(data2, globalData2, comp2) {
      this.assetData = globalData2.getAssetData(data2.refId);
      this.initElement(data2, globalData2, comp2);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
    HImageElement.prototype.createContent = function() {
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      var img = new Image();
      if (this.data.hasMask) {
        this.imageElem = createNS("image");
        this.imageElem.setAttribute("width", this.assetData.w + "px");
        this.imageElem.setAttribute("height", this.assetData.h + "px");
        this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
        this.layerElement.appendChild(this.imageElem);
        this.baseElement.setAttribute("width", this.assetData.w);
        this.baseElement.setAttribute("height", this.assetData.h);
      } else {
        this.layerElement.appendChild(img);
      }
      img.crossOrigin = "anonymous";
      img.src = assetPath;
      if (this.data.ln) {
        this.baseElement.setAttribute("id", this.data.ln);
      }
    };
    function HybridRendererBase(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.renderConfig = {
        className: config && config.className || "",
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        filterSize: {
          width: config && config.filterSize && config.filterSize.width || "400%",
          height: config && config.filterSize && config.filterSize.height || "400%",
          x: config && config.filterSize && config.filterSize.x || "-100%",
          y: config && config.filterSize && config.filterSize.y || "-100%"
        }
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        renderConfig: this.renderConfig
      };
      this.pendingElements = [];
      this.elements = [];
      this.threeDElements = [];
      this.destroyed = false;
      this.camera = null;
      this.supports3d = true;
      this.rendererType = "html";
    }
    extendPrototype([BaseRenderer], HybridRendererBase);
    HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
    HybridRendererBase.prototype.checkPendingElements = function() {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
      }
    };
    HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
      var newDOMElement = element.getBaseElement();
      if (!newDOMElement) {
        return;
      }
      var layer = this.layers[pos];
      if (!layer.ddd || !this.supports3d) {
        if (this.threeDElements) {
          this.addTo3dContainer(newDOMElement, pos);
        } else {
          var i = 0;
          var nextDOMElement;
          var nextLayer;
          var tmpDOMElement;
          while (i < pos) {
            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
              nextLayer = this.elements[i];
              tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
              nextDOMElement = tmpDOMElement || nextDOMElement;
            }
            i += 1;
          }
          if (nextDOMElement) {
            if (!layer.ddd || !this.supports3d) {
              this.layerElement.insertBefore(newDOMElement, nextDOMElement);
            }
          } else if (!layer.ddd || !this.supports3d) {
            this.layerElement.appendChild(newDOMElement);
          }
        }
      } else {
        this.addTo3dContainer(newDOMElement, pos);
      }
    };
    HybridRendererBase.prototype.createShape = function(data2) {
      if (!this.supports3d) {
        return new SVGShapeElement(data2, this.globalData, this);
      }
      return new HShapeElement(data2, this.globalData, this);
    };
    HybridRendererBase.prototype.createText = function(data2) {
      if (!this.supports3d) {
        return new SVGTextLottieElement(data2, this.globalData, this);
      }
      return new HTextElement(data2, this.globalData, this);
    };
    HybridRendererBase.prototype.createCamera = function(data2) {
      this.camera = new HCameraElement(data2, this.globalData, this);
      return this.camera;
    };
    HybridRendererBase.prototype.createImage = function(data2) {
      if (!this.supports3d) {
        return new IImageElement(data2, this.globalData, this);
      }
      return new HImageElement(data2, this.globalData, this);
    };
    HybridRendererBase.prototype.createSolid = function(data2) {
      if (!this.supports3d) {
        return new ISolidElement(data2, this.globalData, this);
      }
      return new HSolidElement(data2, this.globalData, this);
    };
    HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
    HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
      var i = 0;
      var len = this.threeDElements.length;
      while (i < len) {
        if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
          return this.threeDElements[i].perspectiveElem;
        }
        i += 1;
      }
      return null;
    };
    HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
      var perspectiveElem = createTag("div");
      var style;
      var containerStyle;
      styleDiv(perspectiveElem);
      var container = createTag("div");
      styleDiv(container);
      if (type === "3d") {
        style = perspectiveElem.style;
        style.width = this.globalData.compSize.w + "px";
        style.height = this.globalData.compSize.h + "px";
        var center = "50% 50%";
        style.webkitTransformOrigin = center;
        style.mozTransformOrigin = center;
        style.transformOrigin = center;
        containerStyle = container.style;
        var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
        containerStyle.transform = matrix;
        containerStyle.webkitTransform = matrix;
      }
      perspectiveElem.appendChild(container);
      var threeDContainerData = {
        container,
        perspectiveElem,
        startPos: pos,
        endPos: pos,
        type
      };
      this.threeDElements.push(threeDContainerData);
      return threeDContainerData;
    };
    HybridRendererBase.prototype.build3dContainers = function() {
      var i;
      var len = this.layers.length;
      var lastThreeDContainerData;
      var currentContainer = "";
      for (i = 0; i < len; i += 1) {
        if (this.layers[i].ddd && this.layers[i].ty !== 3) {
          if (currentContainer !== "3d") {
            currentContainer = "3d";
            lastThreeDContainerData = this.createThreeDContainer(i, "3d");
          }
          lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        } else {
          if (currentContainer !== "2d") {
            currentContainer = "2d";
            lastThreeDContainerData = this.createThreeDContainer(i, "2d");
          }
          lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        }
      }
      len = this.threeDElements.length;
      for (i = len - 1; i >= 0; i -= 1) {
        this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
      }
    };
    HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
      var i = 0;
      var len = this.threeDElements.length;
      while (i < len) {
        if (pos <= this.threeDElements[i].endPos) {
          var j = this.threeDElements[i].startPos;
          var nextElement;
          while (j < pos) {
            if (this.elements[j] && this.elements[j].getBaseElement) {
              nextElement = this.elements[j].getBaseElement();
            }
            j += 1;
          }
          if (nextElement) {
            this.threeDElements[i].container.insertBefore(elem2, nextElement);
          } else {
            this.threeDElements[i].container.appendChild(elem2);
          }
          break;
        }
        i += 1;
      }
    };
    HybridRendererBase.prototype.configAnimation = function(animData) {
      var resizerElem = createTag("div");
      var wrapper = this.animationItem.wrapper;
      var style = resizerElem.style;
      style.width = animData.w + "px";
      style.height = animData.h + "px";
      this.resizerElem = resizerElem;
      styleDiv(resizerElem);
      style.transformStyle = "flat";
      style.mozTransformStyle = "flat";
      style.webkitTransformStyle = "flat";
      if (this.renderConfig.className) {
        resizerElem.setAttribute("class", this.renderConfig.className);
      }
      wrapper.appendChild(resizerElem);
      style.overflow = "hidden";
      var svg = createNS("svg");
      svg.setAttribute("width", "1");
      svg.setAttribute("height", "1");
      styleDiv(svg);
      this.resizerElem.appendChild(svg);
      var defs = createNS("defs");
      svg.appendChild(defs);
      this.data = animData;
      this.setupGlobalData(animData, svg);
      this.globalData.defs = defs;
      this.layers = animData.layers;
      this.layerElement = this.resizerElem;
      this.build3dContainers();
      this.updateContainerSize();
    };
    HybridRendererBase.prototype.destroy = function() {
      if (this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = "";
      }
      this.animationItem.container = null;
      this.globalData.defs = null;
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i] && this.elements[i].destroy) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.destroyed = true;
      this.animationItem = null;
    };
    HybridRendererBase.prototype.updateContainerSize = function() {
      var elementWidth = this.animationItem.wrapper.offsetWidth;
      var elementHeight = this.animationItem.wrapper.offsetHeight;
      var elementRel = elementWidth / elementHeight;
      var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
      var sx;
      var sy;
      var tx;
      var ty;
      if (animationRel > elementRel) {
        sx = elementWidth / this.globalData.compSize.w;
        sy = elementWidth / this.globalData.compSize.w;
        tx = 0;
        ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
      } else {
        sx = elementHeight / this.globalData.compSize.h;
        sy = elementHeight / this.globalData.compSize.h;
        tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
        ty = 0;
      }
      var style = this.resizerElem.style;
      style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
      style.transform = style.webkitTransform;
    };
    HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
    HybridRendererBase.prototype.hide = function() {
      this.resizerElem.style.display = "none";
    };
    HybridRendererBase.prototype.show = function() {
      this.resizerElem.style.display = "block";
    };
    HybridRendererBase.prototype.initItems = function() {
      this.buildAllItems();
      if (this.camera) {
        this.camera.setup();
      } else {
        var cWidth = this.globalData.compSize.w;
        var cHeight = this.globalData.compSize.h;
        var i;
        var len = this.threeDElements.length;
        for (i = 0; i < len; i += 1) {
          var style = this.threeDElements[i].perspectiveElem.style;
          style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
          style.perspective = style.webkitPerspective;
        }
      }
    };
    HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
      var i;
      var len = assets.length;
      var floatingContainer = createTag("div");
      for (i = 0; i < len; i += 1) {
        if (assets[i].xt) {
          var comp2 = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
          comp2.initExpressions();
          this.globalData.projectInterface.registerComposition(comp2);
        }
      }
    };
    function HCompElement(data2, globalData2, comp2) {
      this.layers = data2.layers;
      this.supports3d = !data2.hasMask;
      this.completeLayers = false;
      this.pendingElements = [];
      this.elements = this.layers ? createSizedArray(this.layers.length) : [];
      this.initElement(data2, globalData2, comp2);
      this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
        _placeholder: true
      };
    }
    extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
    HCompElement.prototype.createContainerElements = function() {
      this._createBaseContainerElements();
      if (this.data.hasMask) {
        this.svgElement.setAttribute("width", this.data.w);
        this.svgElement.setAttribute("height", this.data.h);
        this.transformedElement = this.baseElement;
      } else {
        this.transformedElement = this.layerElement;
      }
    };
    HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
      var j = 0;
      var nextElement;
      while (j < pos) {
        if (this.elements[j] && this.elements[j].getBaseElement) {
          nextElement = this.elements[j].getBaseElement();
        }
        j += 1;
      }
      if (nextElement) {
        this.layerElement.insertBefore(elem2, nextElement);
      } else {
        this.layerElement.appendChild(elem2);
      }
    };
    HCompElement.prototype.createComp = function(data2) {
      if (!this.supports3d) {
        return new SVGCompElement(data2, this.globalData, this);
      }
      return new HCompElement(data2, this.globalData, this);
    };
    function HybridRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.renderConfig = {
        className: config && config.className || "",
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        filterSize: {
          width: config && config.filterSize && config.filterSize.width || "400%",
          height: config && config.filterSize && config.filterSize.height || "400%",
          x: config && config.filterSize && config.filterSize.x || "-100%",
          y: config && config.filterSize && config.filterSize.y || "-100%"
        },
        runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        renderConfig: this.renderConfig
      };
      this.pendingElements = [];
      this.elements = [];
      this.threeDElements = [];
      this.destroyed = false;
      this.camera = null;
      this.supports3d = true;
      this.rendererType = "html";
    }
    extendPrototype([HybridRendererBase], HybridRenderer);
    HybridRenderer.prototype.createComp = function(data2) {
      if (!this.supports3d) {
        return new SVGCompElement(data2, this.globalData, this);
      }
      return new HCompElement(data2, this.globalData, this);
    };
    var CompExpressionInterface = /* @__PURE__ */ function() {
      return function(comp2) {
        function _thisLayerFunction(name2) {
          var i = 0;
          var len = comp2.layers.length;
          while (i < len) {
            if (comp2.layers[i].nm === name2 || comp2.layers[i].ind === name2) {
              return comp2.elements[i].layerInterface;
            }
            i += 1;
          }
          return null;
        }
        Object.defineProperty(_thisLayerFunction, "_name", {
          value: comp2.data.nm
        });
        _thisLayerFunction.layer = _thisLayerFunction;
        _thisLayerFunction.pixelAspect = 1;
        _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
        _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
        _thisLayerFunction.pixelAspect = 1;
        _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
        _thisLayerFunction.displayStartTime = 0;
        _thisLayerFunction.numLayers = comp2.layers.length;
        return _thisLayerFunction;
      };
    }();
    function _typeof$2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$2 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$2 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$2(obj);
    }
    function seedRandom(pool, math) {
      var global2 = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
      function seedrandom(seed, options, callback2) {
        var key2 = [];
        options = options === true ? {
          entropy: true
        } : options || {};
        var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
        var arc4 = new ARC4(key2);
        var prng = function prng2() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width2;
            d *= width2;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng["double"] = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback2 || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
      }
      math["seed" + rngname] = seedrandom;
      function ARC4(key2) {
        var t, keylen = key2.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key2 = [keylen++];
        }
        while (i < width2) {
          s[i] = i++;
        }
        for (i = 0; i < width2; i++) {
          s[i] = s[j = mask2 & j + key2[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask2 & i2 + 1];
            r = r * width2 + s2[mask2 & (s2[i2] = s2[j2 = mask2 & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        };
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      function flatten(obj, depth) {
        var result = [], typ = _typeof$2(obj), prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key2) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key2[mask2 & j] = mask2 & (smear ^= key2[mask2 & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key2);
      }
      function autoseed() {
        try {
          if (nodecrypto)
            ;
          var out = new Uint8Array(width2);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
          return tostring(out);
        } catch (e) {
          var browser = global2.navigator, plugins2 = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins2, global2.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math.random(), pool);
    }
    function initialize$2(BMMath2) {
      seedRandom([], BMMath2);
    }
    var propTypes = {
      SHAPE: "shape"
    };
    function _typeof$1(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$1 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$1 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$1(obj);
    }
    var ExpressionManager = function() {
      var ob = {};
      var Math = BMMath;
      var window = null;
      var document = null;
      var XMLHttpRequest = null;
      var fetch = null;
      var frames = null;
      var _lottieGlobal = {};
      initialize$2(BMMath);
      function resetFrame() {
        _lottieGlobal = {};
      }
      function $bm_isInstanceOfArray(arr) {
        return arr.constructor === Array || arr.constructor === Float32Array;
      }
      function isNumerable(tOfV, v) {
        return tOfV === "number" || v instanceof Number || tOfV === "boolean" || tOfV === "string";
      }
      function $bm_neg(a) {
        var tOfA = _typeof$1(a);
        if (tOfA === "number" || a instanceof Number || tOfA === "boolean") {
          return -a;
        }
        if ($bm_isInstanceOfArray(a)) {
          var i;
          var lenA = a.length;
          var retArr = [];
          for (i = 0; i < lenA; i += 1) {
            retArr[i] = -a[i];
          }
          return retArr;
        }
        if (a.propType) {
          return a.v;
        }
        return -a;
      }
      var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
      var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
      var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
      function sum(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === "string" || tOfB === "string") {
          return a + b;
        }
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          a = a.slice(0);
          a[0] += b;
          return a;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          b = b.slice(0);
          b[0] = a + b[0];
          return b;
        }
        if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
          var i = 0;
          var lenA = a.length;
          var lenB = b.length;
          var retArr = [];
          while (i < lenA || i < lenB) {
            if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) {
              retArr[i] = a[i] + b[i];
            } else {
              retArr[i] = b[i] === void 0 ? a[i] : a[i] || b[i];
            }
            i += 1;
          }
          return retArr;
        }
        return 0;
      }
      var add = sum;
      function sub(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
          if (tOfA === "string") {
            a = parseInt(a, 10);
          }
          if (tOfB === "string") {
            b = parseInt(b, 10);
          }
          return a - b;
        }
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          a = a.slice(0);
          a[0] -= b;
          return a;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          b = b.slice(0);
          b[0] = a - b[0];
          return b;
        }
        if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
          var i = 0;
          var lenA = a.length;
          var lenB = b.length;
          var retArr = [];
          while (i < lenA || i < lenB) {
            if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) {
              retArr[i] = a[i] - b[i];
            } else {
              retArr[i] = b[i] === void 0 ? a[i] : a[i] || b[i];
            }
            i += 1;
          }
          return retArr;
        }
        return 0;
      }
      function mul(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        var arr;
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
          return a * b;
        }
        var i;
        var len;
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          len = a.length;
          arr = createTypedArray("float32", len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a[i] * b;
          }
          return arr;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          len = b.length;
          arr = createTypedArray("float32", len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a * b[i];
          }
          return arr;
        }
        return 0;
      }
      function div(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        var arr;
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
          return a / b;
        }
        var i;
        var len;
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          len = a.length;
          arr = createTypedArray("float32", len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a[i] / b;
          }
          return arr;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          len = b.length;
          arr = createTypedArray("float32", len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a / b[i];
          }
          return arr;
        }
        return 0;
      }
      function mod(a, b) {
        if (typeof a === "string") {
          a = parseInt(a, 10);
        }
        if (typeof b === "string") {
          b = parseInt(b, 10);
        }
        return a % b;
      }
      var $bm_sum = sum;
      var $bm_sub = sub;
      var $bm_mul = mul;
      var $bm_div = div;
      var $bm_mod = mod;
      function clamp(num, min, max) {
        if (min > max) {
          var mm = max;
          max = min;
          min = mm;
        }
        return Math.min(Math.max(num, min), max);
      }
      function radiansToDegrees(val2) {
        return val2 / degToRads;
      }
      var radians_to_degrees = radiansToDegrees;
      function degreesToRadians(val2) {
        return val2 * degToRads;
      }
      var degrees_to_radians = radiansToDegrees;
      var helperLengthArray = [0, 0, 0, 0, 0, 0];
      function length(arr1, arr2) {
        if (typeof arr1 === "number" || arr1 instanceof Number) {
          arr2 = arr2 || 0;
          return Math.abs(arr1 - arr2);
        }
        if (!arr2) {
          arr2 = helperLengthArray;
        }
        var i;
        var len = Math.min(arr1.length, arr2.length);
        var addedLength = 0;
        for (i = 0; i < len; i += 1) {
          addedLength += Math.pow(arr2[i] - arr1[i], 2);
        }
        return Math.sqrt(addedLength);
      }
      function normalize(vec) {
        return div(vec, length(vec));
      }
      function rgbToHsl(val2) {
        var r = val2[0];
        var g = val2[1];
        var b = val2[2];
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h3;
        var s;
        var l = (max + min) / 2;
        if (max === min) {
          h3 = 0;
          s = 0;
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h3 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h3 = (b - r) / d + 2;
              break;
            case b:
              h3 = (r - g) / d + 4;
              break;
          }
          h3 /= 6;
        }
        return [h3, s, l, val2[3]];
      }
      function hue2rgb(p, q, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p + (q - p) * 6 * t;
        if (t < 1 / 2)
          return q;
        if (t < 2 / 3)
          return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }
      function hslToRgb(val2) {
        var h3 = val2[0];
        var s = val2[1];
        var l = val2[2];
        var r;
        var g;
        var b;
        if (s === 0) {
          r = l;
          b = l;
          g = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h3 + 1 / 3);
          g = hue2rgb(p, q, h3);
          b = hue2rgb(p, q, h3 - 1 / 3);
        }
        return [r, g, b, val2[3]];
      }
      function linear(t, tMin, tMax, value1, value2) {
        if (value1 === void 0 || value2 === void 0) {
          value1 = tMin;
          value2 = tMax;
          tMin = 0;
          tMax = 1;
        }
        if (tMax < tMin) {
          var _tMin = tMax;
          tMax = tMin;
          tMin = _tMin;
        }
        if (t <= tMin) {
          return value1;
        }
        if (t >= tMax) {
          return value2;
        }
        var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
        if (!value1.length) {
          return value1 + (value2 - value1) * perc;
        }
        var i;
        var len = value1.length;
        var arr = createTypedArray("float32", len);
        for (i = 0; i < len; i += 1) {
          arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
        }
        return arr;
      }
      function random(min, max) {
        if (max === void 0) {
          if (min === void 0) {
            min = 0;
            max = 1;
          } else {
            max = min;
            min = void 0;
          }
        }
        if (max.length) {
          var i;
          var len = max.length;
          if (!min) {
            min = createTypedArray("float32", len);
          }
          var arr = createTypedArray("float32", len);
          var rnd = BMMath.random();
          for (i = 0; i < len; i += 1) {
            arr[i] = min[i] + rnd * (max[i] - min[i]);
          }
          return arr;
        }
        if (min === void 0) {
          min = 0;
        }
        var rndm = BMMath.random();
        return min + rndm * (max - min);
      }
      function createPath(points, inTangents, outTangents, closed) {
        var i;
        var len = points.length;
        var path = shapePool.newElement();
        path.setPathData(!!closed, len);
        var arrPlaceholder = [0, 0];
        var inVertexPoint;
        var outVertexPoint;
        for (i = 0; i < len; i += 1) {
          inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
          outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
          path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
        }
        return path;
      }
      function initiateExpression(elem, data, property) {
        function noOp(_value) {
          return _value;
        }
        if (!elem.globalData.renderConfig.runExpressions) {
          return noOp;
        }
        var val = data.x;
        var needsVelocity = /velocity(?![\w\d])/.test(val);
        var _needsRandom = val.indexOf("random") !== -1;
        var elemType = elem.data.ty;
        var transform;
        var $bm_transform;
        var content;
        var effect;
        var thisProperty = property;
        thisProperty.valueAtTime = thisProperty.getValueAtTime;
        Object.defineProperty(thisProperty, "value", {
          get: function get() {
            return thisProperty.v;
          }
        });
        elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
        elem.comp.displayStartTime = 0;
        var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
        var outPoint = elem.data.op / elem.comp.globalData.frameRate;
        var width = elem.data.sw ? elem.data.sw : 0;
        var height = elem.data.sh ? elem.data.sh : 0;
        var name = elem.data.nm;
        var loopIn;
        var loop_in;
        var loopOut;
        var loop_out;
        var smooth;
        var toWorld;
        var fromWorld;
        var fromComp;
        var toComp;
        var fromCompToSurface;
        var position;
        var rotation;
        var anchorPoint;
        var scale;
        var thisLayer;
        var thisComp;
        var mask;
        var valueAtTime;
        var velocityAtTime;
        var scoped_bm_rt;
        var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
        var numKeys = property.kf ? data.k.length : 0;
        var active = !this.data || this.data.hd !== true;
        var wiggle = (function wiggle2(freq, amp) {
          var iWiggle;
          var j;
          var lenWiggle = this.pv.length ? this.pv.length : 1;
          var addedAmps = createTypedArray("float32", lenWiggle);
          freq = 5;
          var iterations = Math.floor(time * freq);
          iWiggle = 0;
          j = 0;
          while (iWiggle < iterations) {
            for (j = 0; j < lenWiggle; j += 1) {
              addedAmps[j] += -amp + amp * 2 * BMMath.random();
            }
            iWiggle += 1;
          }
          var periods = time * freq;
          var perc = periods - Math.floor(periods);
          var arr = createTypedArray("float32", lenWiggle);
          if (lenWiggle > 1) {
            for (j = 0; j < lenWiggle; j += 1) {
              arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
            }
            return arr;
          }
          return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
        }).bind(this);
        if (thisProperty.loopIn) {
          loopIn = thisProperty.loopIn.bind(thisProperty);
          loop_in = loopIn;
        }
        if (thisProperty.loopOut) {
          loopOut = thisProperty.loopOut.bind(thisProperty);
          loop_out = loopOut;
        }
        if (thisProperty.smooth) {
          smooth = thisProperty.smooth.bind(thisProperty);
        }
        function loopInDuration(type, duration) {
          return loopIn(type, duration, true);
        }
        function loopOutDuration(type, duration) {
          return loopOut(type, duration, true);
        }
        if (this.getValueAtTime) {
          valueAtTime = this.getValueAtTime.bind(this);
        }
        if (this.getVelocityAtTime) {
          velocityAtTime = this.getVelocityAtTime.bind(this);
        }
        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
        function lookAt(elem1, elem2) {
          var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
          var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
          var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
          return [yaw, pitch, 0];
        }
        function easeOut(t, tMin, tMax, val1, val2) {
          return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
        }
        function easeIn(t, tMin, tMax, val1, val2) {
          return applyEase(easeInBez, t, tMin, tMax, val1, val2);
        }
        function ease(t, tMin, tMax, val1, val2) {
          return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
        }
        function applyEase(fn, t, tMin, tMax, val1, val2) {
          if (val1 === void 0) {
            val1 = tMin;
            val2 = tMax;
          } else {
            t = (t - tMin) / (tMax - tMin);
          }
          if (t > 1) {
            t = 1;
          } else if (t < 0) {
            t = 0;
          }
          var mult = fn(t);
          if ($bm_isInstanceOfArray(val1)) {
            var iKey;
            var lenKey = val1.length;
            var arr = createTypedArray("float32", lenKey);
            for (iKey = 0; iKey < lenKey; iKey += 1) {
              arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
            }
            return arr;
          }
          return (val2 - val1) * mult + val1;
        }
        function nearestKey(time2) {
          var iKey;
          var lenKey = data.k.length;
          var index2;
          var keyTime;
          if (!data.k.length || typeof data.k[0] === "number") {
            index2 = 0;
            keyTime = 0;
          } else {
            index2 = -1;
            time2 *= elem.comp.globalData.frameRate;
            if (time2 < data.k[0].t) {
              index2 = 1;
              keyTime = data.k[0].t;
            } else {
              for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                if (time2 === data.k[iKey].t) {
                  index2 = iKey + 1;
                  keyTime = data.k[iKey].t;
                  break;
                } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                  if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                    index2 = iKey + 2;
                    keyTime = data.k[iKey + 1].t;
                  } else {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                  }
                  break;
                }
              }
              if (index2 === -1) {
                index2 = iKey + 1;
                keyTime = data.k[iKey].t;
              }
            }
          }
          var obKey = {};
          obKey.index = index2;
          obKey.time = keyTime / elem.comp.globalData.frameRate;
          return obKey;
        }
        function key(ind) {
          var obKey;
          var iKey;
          var lenKey;
          if (!data.k.length || typeof data.k[0] === "number") {
            throw new Error("The property has no keyframe at index " + ind);
          }
          ind -= 1;
          obKey = {
            time: data.k[ind].t / elem.comp.globalData.frameRate,
            value: []
          };
          var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
          lenKey = arr.length;
          for (iKey = 0; iKey < lenKey; iKey += 1) {
            obKey[iKey] = arr[iKey];
            obKey.value[iKey] = arr[iKey];
          }
          return obKey;
        }
        function framesToTime(fr, fps) {
          if (!fps) {
            fps = elem.comp.globalData.frameRate;
          }
          return fr / fps;
        }
        function timeToFrames(t, fps) {
          if (!t && t !== 0) {
            t = time;
          }
          if (!fps) {
            fps = elem.comp.globalData.frameRate;
          }
          return t * fps;
        }
        function seedRandom(seed) {
          BMMath.seedrandom(randSeed + seed);
        }
        function sourceRectAtTime() {
          return elem.sourceRectAtTime();
        }
        function substring(init, end) {
          if (typeof value === "string") {
            if (end === void 0) {
              return value.substring(init);
            }
            return value.substring(init, end);
          }
          return "";
        }
        function substr(init, end) {
          if (typeof value === "string") {
            if (end === void 0) {
              return value.substr(init);
            }
            return value.substr(init, end);
          }
          return "";
        }
        function posterizeTime(framesPerSecond) {
          time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
          value = valueAtTime(time);
        }
        var time;
        var velocity;
        var value;
        var text;
        var textIndex;
        var textTotal;
        var selectorValue;
        var index = elem.data.ind;
        var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
        var parent;
        var randSeed = Math.floor(Math.random() * 1e6);
        var globalData = elem.globalData;
        function executeExpression(_value) {
          value = _value;
          if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
            return value;
          }
          if (this.propType === "textSelector") {
            textIndex = this.textIndex;
            textTotal = this.textTotal;
            selectorValue = this.selectorValue;
          }
          if (!thisLayer) {
            text = elem.layerInterface.text;
            thisLayer = elem.layerInterface;
            thisComp = elem.comp.compInterface;
            toWorld = thisLayer.toWorld.bind(thisLayer);
            fromWorld = thisLayer.fromWorld.bind(thisLayer);
            fromComp = thisLayer.fromComp.bind(thisLayer);
            toComp = thisLayer.toComp.bind(thisLayer);
            mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
            fromCompToSurface = fromComp;
          }
          if (!transform) {
            transform = elem.layerInterface("ADBE Transform Group");
            $bm_transform = transform;
            if (transform) {
              anchorPoint = transform.anchorPoint;
            }
          }
          if (elemType === 4 && !content) {
            content = thisLayer("ADBE Root Vectors Group");
          }
          if (!effect) {
            effect = thisLayer(4);
          }
          hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          if (hasParent && !parent) {
            parent = elem.hierarchy[0].layerInterface;
          }
          time = this.comp.renderedFrame / this.comp.globalData.frameRate;
          if (_needsRandom) {
            seedRandom(randSeed + time);
          }
          if (needsVelocity) {
            velocity = velocityAtTime(time);
          }
          expression_function();
          this.frameExpressionId = elem.globalData.frameId;
          scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
          return scoped_bm_rt;
        }
        executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
        return executeExpression;
      }
      ob.initiateExpression = initiateExpression;
      ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
      ob.resetFrame = resetFrame;
      return ob;
    }();
    var Expressions = function() {
      var ob2 = {};
      ob2.initExpressions = initExpressions;
      ob2.resetFrame = ExpressionManager.resetFrame;
      function initExpressions(animation) {
        var stackCount = 0;
        var registers = [];
        function pushExpression() {
          stackCount += 1;
        }
        function popExpression() {
          stackCount -= 1;
          if (stackCount === 0) {
            releaseInstances();
          }
        }
        function registerExpressionProperty(expression) {
          if (registers.indexOf(expression) === -1) {
            registers.push(expression);
          }
        }
        function releaseInstances() {
          var i;
          var len = registers.length;
          for (i = 0; i < len; i += 1) {
            registers[i].release();
          }
          registers.length = 0;
        }
        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
        animation.renderer.globalData.pushExpression = pushExpression;
        animation.renderer.globalData.popExpression = popExpression;
        animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
      }
      return ob2;
    }();
    var MaskManagerInterface = function() {
      function MaskInterface(mask2, data2) {
        this._mask = mask2;
        this._data = data2;
      }
      Object.defineProperty(MaskInterface.prototype, "maskPath", {
        get: function get() {
          if (this._mask.prop.k) {
            this._mask.prop.getValue();
          }
          return this._mask.prop;
        }
      });
      Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
        get: function get() {
          if (this._mask.op.k) {
            this._mask.op.getValue();
          }
          return this._mask.op.v * 100;
        }
      });
      var MaskManager = function MaskManager2(maskManager) {
        var _masksInterfaces = createSizedArray(maskManager.viewData.length);
        var i;
        var len = maskManager.viewData.length;
        for (i = 0; i < len; i += 1) {
          _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
        }
        var maskFunction = function maskFunction2(name2) {
          i = 0;
          while (i < len) {
            if (maskManager.masksProperties[i].nm === name2) {
              return _masksInterfaces[i];
            }
            i += 1;
          }
          return null;
        };
        return maskFunction;
      };
      return MaskManager;
    }();
    var ExpressionPropertyInterface = /* @__PURE__ */ function() {
      var defaultUnidimensionalValue = {
        pv: 0,
        v: 0,
        mult: 1
      };
      var defaultMultidimensionalValue = {
        pv: [0, 0, 0],
        v: [0, 0, 0],
        mult: 1
      };
      function completeProperty(expressionValue, property2, type) {
        Object.defineProperty(expressionValue, "velocity", {
          get: function get() {
            return property2.getVelocityAtTime(property2.comp.currentFrame);
          }
        });
        expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
        expressionValue.key = function(pos) {
          if (!expressionValue.numKeys) {
            return 0;
          }
          var value2 = "";
          if ("s" in property2.keyframes[pos - 1]) {
            value2 = property2.keyframes[pos - 1].s;
          } else if ("e" in property2.keyframes[pos - 2]) {
            value2 = property2.keyframes[pos - 2].e;
          } else {
            value2 = property2.keyframes[pos - 2].s;
          }
          var valueProp = type === "unidimensional" ? new Number(value2) : Object.assign({}, value2);
          valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
          valueProp.value = type === "unidimensional" ? value2[0] : value2;
          return valueProp;
        };
        expressionValue.valueAtTime = property2.getValueAtTime;
        expressionValue.speedAtTime = property2.getSpeedAtTime;
        expressionValue.velocityAtTime = property2.getVelocityAtTime;
        expressionValue.propertyGroup = property2.propertyGroup;
      }
      function UnidimensionalPropertyInterface(property2) {
        if (!property2 || !("pv" in property2)) {
          property2 = defaultUnidimensionalValue;
        }
        var mult = 1 / property2.mult;
        var val2 = property2.pv * mult;
        var expressionValue = new Number(val2);
        expressionValue.value = val2;
        completeProperty(expressionValue, property2, "unidimensional");
        return function() {
          if (property2.k) {
            property2.getValue();
          }
          val2 = property2.v * mult;
          if (expressionValue.value !== val2) {
            expressionValue = new Number(val2);
            expressionValue.value = val2;
            completeProperty(expressionValue, property2, "unidimensional");
          }
          return expressionValue;
        };
      }
      function MultidimensionalPropertyInterface(property2) {
        if (!property2 || !("pv" in property2)) {
          property2 = defaultMultidimensionalValue;
        }
        var mult = 1 / property2.mult;
        var len = property2.data && property2.data.l || property2.pv.length;
        var expressionValue = createTypedArray("float32", len);
        var arrValue = createTypedArray("float32", len);
        expressionValue.value = arrValue;
        completeProperty(expressionValue, property2, "multidimensional");
        return function() {
          if (property2.k) {
            property2.getValue();
          }
          for (var i = 0; i < len; i += 1) {
            arrValue[i] = property2.v[i] * mult;
            expressionValue[i] = arrValue[i];
          }
          return expressionValue;
        };
      }
      function defaultGetter() {
        return defaultUnidimensionalValue;
      }
      return function(property2) {
        if (!property2) {
          return defaultGetter;
        }
        if (property2.propType === "unidimensional") {
          return UnidimensionalPropertyInterface(property2);
        }
        return MultidimensionalPropertyInterface(property2);
      };
    }();
    var TransformExpressionInterface = /* @__PURE__ */ function() {
      return function(transform2) {
        function _thisFunction(name2) {
          switch (name2) {
            case "scale":
            case "Scale":
            case "ADBE Scale":
            case 6:
              return _thisFunction.scale;
            case "rotation":
            case "Rotation":
            case "ADBE Rotation":
            case "ADBE Rotate Z":
            case 10:
              return _thisFunction.rotation;
            case "ADBE Rotate X":
              return _thisFunction.xRotation;
            case "ADBE Rotate Y":
              return _thisFunction.yRotation;
            case "position":
            case "Position":
            case "ADBE Position":
            case 2:
              return _thisFunction.position;
            case "ADBE Position_0":
              return _thisFunction.xPosition;
            case "ADBE Position_1":
              return _thisFunction.yPosition;
            case "ADBE Position_2":
              return _thisFunction.zPosition;
            case "anchorPoint":
            case "AnchorPoint":
            case "Anchor Point":
            case "ADBE AnchorPoint":
            case 1:
              return _thisFunction.anchorPoint;
            case "opacity":
            case "Opacity":
            case 11:
              return _thisFunction.opacity;
            default:
              return null;
          }
        }
        Object.defineProperty(_thisFunction, "rotation", {
          get: ExpressionPropertyInterface(transform2.r || transform2.rz)
        });
        Object.defineProperty(_thisFunction, "zRotation", {
          get: ExpressionPropertyInterface(transform2.rz || transform2.r)
        });
        Object.defineProperty(_thisFunction, "xRotation", {
          get: ExpressionPropertyInterface(transform2.rx)
        });
        Object.defineProperty(_thisFunction, "yRotation", {
          get: ExpressionPropertyInterface(transform2.ry)
        });
        Object.defineProperty(_thisFunction, "scale", {
          get: ExpressionPropertyInterface(transform2.s)
        });
        var _px;
        var _py;
        var _pz;
        var _transformFactory;
        if (transform2.p) {
          _transformFactory = ExpressionPropertyInterface(transform2.p);
        } else {
          _px = ExpressionPropertyInterface(transform2.px);
          _py = ExpressionPropertyInterface(transform2.py);
          if (transform2.pz) {
            _pz = ExpressionPropertyInterface(transform2.pz);
          }
        }
        Object.defineProperty(_thisFunction, "position", {
          get: function get() {
            if (transform2.p) {
              return _transformFactory();
            }
            return [_px(), _py(), _pz ? _pz() : 0];
          }
        });
        Object.defineProperty(_thisFunction, "xPosition", {
          get: ExpressionPropertyInterface(transform2.px)
        });
        Object.defineProperty(_thisFunction, "yPosition", {
          get: ExpressionPropertyInterface(transform2.py)
        });
        Object.defineProperty(_thisFunction, "zPosition", {
          get: ExpressionPropertyInterface(transform2.pz)
        });
        Object.defineProperty(_thisFunction, "anchorPoint", {
          get: ExpressionPropertyInterface(transform2.a)
        });
        Object.defineProperty(_thisFunction, "opacity", {
          get: ExpressionPropertyInterface(transform2.o)
        });
        Object.defineProperty(_thisFunction, "skew", {
          get: ExpressionPropertyInterface(transform2.sk)
        });
        Object.defineProperty(_thisFunction, "skewAxis", {
          get: ExpressionPropertyInterface(transform2.sa)
        });
        Object.defineProperty(_thisFunction, "orientation", {
          get: ExpressionPropertyInterface(transform2.or)
        });
        return _thisFunction;
      };
    }();
    var LayerExpressionInterface = /* @__PURE__ */ function() {
      function getMatrix(time2) {
        var toWorldMat = new Matrix();
        if (time2 !== void 0) {
          var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
          propMatrix.clone(toWorldMat);
        } else {
          var transformMat = this._elem.finalTransform.mProp;
          transformMat.applyToMatrix(toWorldMat);
        }
        return toWorldMat;
      }
      function toWorldVec(arr, time2) {
        var toWorldMat = this.getMatrix(time2);
        toWorldMat.props[12] = 0;
        toWorldMat.props[13] = 0;
        toWorldMat.props[14] = 0;
        return this.applyPoint(toWorldMat, arr);
      }
      function toWorld2(arr, time2) {
        var toWorldMat = this.getMatrix(time2);
        return this.applyPoint(toWorldMat, arr);
      }
      function fromWorldVec(arr, time2) {
        var toWorldMat = this.getMatrix(time2);
        toWorldMat.props[12] = 0;
        toWorldMat.props[13] = 0;
        toWorldMat.props[14] = 0;
        return this.invertPoint(toWorldMat, arr);
      }
      function fromWorld2(arr, time2) {
        var toWorldMat = this.getMatrix(time2);
        return this.invertPoint(toWorldMat, arr);
      }
      function applyPoint(matrix, arr) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
          }
        }
        return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
      }
      function invertPoint(matrix, arr) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
          }
        }
        return matrix.inversePoint(arr);
      }
      function fromComp2(arr) {
        var toWorldMat = new Matrix();
        toWorldMat.reset();
        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
          }
          return toWorldMat.inversePoint(arr);
        }
        return toWorldMat.inversePoint(arr);
      }
      function sampleImage() {
        return [1, 1, 1, 1];
      }
      return function(elem2) {
        var transformInterface;
        function _registerMaskInterface(maskManager) {
          _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
        }
        function _registerEffectsInterface(effects2) {
          _thisLayerFunction.effect = effects2;
        }
        function _thisLayerFunction(name2) {
          switch (name2) {
            case "ADBE Root Vectors Group":
            case "Contents":
            case 2:
              return _thisLayerFunction.shapeInterface;
            case 1:
            case 6:
            case "Transform":
            case "transform":
            case "ADBE Transform Group":
              return transformInterface;
            case 4:
            case "ADBE Effect Parade":
            case "effects":
            case "Effects":
              return _thisLayerFunction.effect;
            case "ADBE Text Properties":
              return _thisLayerFunction.textInterface;
            default:
              return null;
          }
        }
        _thisLayerFunction.getMatrix = getMatrix;
        _thisLayerFunction.invertPoint = invertPoint;
        _thisLayerFunction.applyPoint = applyPoint;
        _thisLayerFunction.toWorld = toWorld2;
        _thisLayerFunction.toWorldVec = toWorldVec;
        _thisLayerFunction.fromWorld = fromWorld2;
        _thisLayerFunction.fromWorldVec = fromWorldVec;
        _thisLayerFunction.toComp = toWorld2;
        _thisLayerFunction.fromComp = fromComp2;
        _thisLayerFunction.sampleImage = sampleImage;
        _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
        _thisLayerFunction._elem = elem2;
        transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
        var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
        Object.defineProperties(_thisLayerFunction, {
          hasParent: {
            get: function get() {
              return elem2.hierarchy.length;
            }
          },
          parent: {
            get: function get() {
              return elem2.hierarchy[0].layerInterface;
            }
          },
          rotation: getDescriptor(transformInterface, "rotation"),
          scale: getDescriptor(transformInterface, "scale"),
          position: getDescriptor(transformInterface, "position"),
          opacity: getDescriptor(transformInterface, "opacity"),
          anchorPoint: anchorPointDescriptor,
          anchor_point: anchorPointDescriptor,
          transform: {
            get: function get() {
              return transformInterface;
            }
          },
          active: {
            get: function get() {
              return elem2.isInRange;
            }
          }
        });
        _thisLayerFunction.startTime = elem2.data.st;
        _thisLayerFunction.index = elem2.data.ind;
        _thisLayerFunction.source = elem2.data.refId;
        _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
        _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
        _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
        _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
        _thisLayerFunction._name = elem2.data.nm;
        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
        return _thisLayerFunction;
      };
    }();
    var propertyGroupFactory = /* @__PURE__ */ function() {
      return function(interfaceFunction, parentPropertyGroup) {
        return function(val2) {
          val2 = val2 === void 0 ? 1 : val2;
          if (val2 <= 0) {
            return interfaceFunction;
          }
          return parentPropertyGroup(val2 - 1);
        };
      };
    }();
    var PropertyInterface = /* @__PURE__ */ function() {
      return function(propertyName, propertyGroup) {
        var interfaceFunction = {
          _name: propertyName
        };
        function _propertyGroup(val2) {
          val2 = val2 === void 0 ? 1 : val2;
          if (val2 <= 0) {
            return interfaceFunction;
          }
          return propertyGroup(val2 - 1);
        }
        return _propertyGroup;
      };
    }();
    var EffectsExpressionInterface = /* @__PURE__ */ function() {
      var ob2 = {
        createEffectsInterface
      };
      function createEffectsInterface(elem2, propertyGroup) {
        if (elem2.effectsManager) {
          var effectElements = [];
          var effectsData = elem2.data.ef;
          var i;
          var len = elem2.effectsManager.effectElements.length;
          for (i = 0; i < len; i += 1) {
            effectElements.push(createGroupInterface(effectsData[i], elem2.effectsManager.effectElements[i], propertyGroup, elem2));
          }
          var effects2 = elem2.data.ef || [];
          var groupInterface = function groupInterface2(name2) {
            i = 0;
            len = effects2.length;
            while (i < len) {
              if (name2 === effects2[i].nm || name2 === effects2[i].mn || name2 === effects2[i].ix) {
                return effectElements[i];
              }
              i += 1;
            }
            return null;
          };
          Object.defineProperty(groupInterface, "numProperties", {
            get: function get() {
              return effects2.length;
            }
          });
          return groupInterface;
        }
        return null;
      }
      function createGroupInterface(data2, elements2, propertyGroup, elem2) {
        function groupInterface(name2) {
          var effects2 = data2.ef;
          var i2 = 0;
          var len2 = effects2.length;
          while (i2 < len2) {
            if (name2 === effects2[i2].nm || name2 === effects2[i2].mn || name2 === effects2[i2].ix) {
              if (effects2[i2].ty === 5) {
                return effectElements[i2];
              }
              return effectElements[i2]();
            }
            i2 += 1;
          }
          throw new Error();
        }
        var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
        var effectElements = [];
        var i;
        var len = data2.ef.length;
        for (i = 0; i < len; i += 1) {
          if (data2.ef[i].ty === 5) {
            effectElements.push(createGroupInterface(data2.ef[i], elements2.effectElements[i], elements2.effectElements[i].propertyGroup, elem2));
          } else {
            effectElements.push(createValueInterface(elements2.effectElements[i], data2.ef[i].ty, elem2, _propertyGroup));
          }
        }
        if (data2.mn === "ADBE Color Control") {
          Object.defineProperty(groupInterface, "color", {
            get: function get() {
              return effectElements[0]();
            }
          });
        }
        Object.defineProperties(groupInterface, {
          numProperties: {
            get: function get() {
              return data2.np;
            }
          },
          _name: {
            value: data2.nm
          },
          propertyGroup: {
            value: _propertyGroup
          }
        });
        groupInterface.enabled = data2.en !== 0;
        groupInterface.active = groupInterface.enabled;
        return groupInterface;
      }
      function createValueInterface(element, type, elem2, propertyGroup) {
        var expressionProperty = ExpressionPropertyInterface(element.p);
        function interfaceFunction() {
          if (type === 10) {
            return elem2.comp.compInterface(element.p.v);
          }
          return expressionProperty();
        }
        if (element.p.setGroupProperty) {
          element.p.setGroupProperty(PropertyInterface("", propertyGroup));
        }
        return interfaceFunction;
      }
      return ob2;
    }();
    var ShapePathInterface = /* @__PURE__ */ function() {
      return function pathInterfaceFactory(shape, view, propertyGroup) {
        var prop = view.sh;
        function interfaceFunction(val2) {
          if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
            return interfaceFunction.path;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          path: {
            get: function get() {
              if (prop.k) {
                prop.getValue();
              }
              return prop;
            }
          },
          shape: {
            get: function get() {
              if (prop.k) {
                prop.getValue();
              }
              return prop;
            }
          },
          _name: {
            value: shape.nm
          },
          ix: {
            value: shape.ix
          },
          propertyIndex: {
            value: shape.ix
          },
          mn: {
            value: shape.mn
          },
          propertyGroup: {
            value: propertyGroup
          }
        });
        return interfaceFunction;
      };
    }();
    var ShapeExpressionInterface = /* @__PURE__ */ function() {
      function iterateElements(shapes, view, propertyGroup) {
        var arr = [];
        var i;
        var len = shapes ? shapes.length : 0;
        for (i = 0; i < len; i += 1) {
          if (shapes[i].ty === "gr") {
            arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "fl") {
            arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "st") {
            arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "tm") {
            arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "tr")
            ;
          else if (shapes[i].ty === "el") {
            arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "sr") {
            arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "sh") {
            arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "rc") {
            arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "rd") {
            arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "rp") {
            arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === "gf") {
            arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else {
            arr.push(defaultInterfaceFactory(shapes[i], view[i]));
          }
        }
        return arr;
      }
      function contentsInterfaceFactory(shape, view, propertyGroup) {
        var interfaces2;
        var interfaceFunction = function _interfaceFunction(value2) {
          var i = 0;
          var len = interfaces2.length;
          while (i < len) {
            if (interfaces2[i]._name === value2 || interfaces2[i].mn === value2 || interfaces2[i].propertyIndex === value2 || interfaces2[i].ix === value2 || interfaces2[i].ind === value2) {
              return interfaces2[i];
            }
            i += 1;
          }
          if (typeof value2 === "number") {
            return interfaces2[value2 - 1];
          }
          return null;
        };
        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
        interfaceFunction.numProperties = interfaces2.length;
        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
        interfaceFunction.transform = transformInterface;
        interfaceFunction.propertyIndex = shape.cix;
        interfaceFunction._name = shape.nm;
        return interfaceFunction;
      }
      function groupInterfaceFactory(shape, view, propertyGroup) {
        var interfaceFunction = function _interfaceFunction(value2) {
          switch (value2) {
            case "ADBE Vectors Group":
            case "Contents":
            case 2:
              return interfaceFunction.content;
            default:
              return interfaceFunction.transform;
          }
        };
        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
        interfaceFunction.content = content2;
        interfaceFunction.transform = transformInterface;
        Object.defineProperty(interfaceFunction, "_name", {
          get: function get() {
            return shape.nm;
          }
        });
        interfaceFunction.numProperties = shape.np;
        interfaceFunction.propertyIndex = shape.ix;
        interfaceFunction.nm = shape.nm;
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function fillInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val2) {
          if (val2 === "Color" || val2 === "color") {
            return interfaceFunction.color;
          }
          if (val2 === "Opacity" || val2 === "opacity") {
            return interfaceFunction.opacity;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          color: {
            get: ExpressionPropertyInterface(view.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o)
          },
          _name: {
            value: shape.nm
          },
          mn: {
            value: shape.mn
          }
        });
        view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
        view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
        return interfaceFunction;
      }
      function gradientFillInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val2) {
          if (val2 === "Start Point" || val2 === "start point") {
            return interfaceFunction.startPoint;
          }
          if (val2 === "End Point" || val2 === "end point") {
            return interfaceFunction.endPoint;
          }
          if (val2 === "Opacity" || val2 === "opacity") {
            return interfaceFunction.opacity;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          startPoint: {
            get: ExpressionPropertyInterface(view.s)
          },
          endPoint: {
            get: ExpressionPropertyInterface(view.e)
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o)
          },
          type: {
            get: function get() {
              return "a";
            }
          },
          _name: {
            value: shape.nm
          },
          mn: {
            value: shape.mn
          }
        });
        view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
        view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
        view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
        return interfaceFunction;
      }
      function defaultInterfaceFactory() {
        function interfaceFunction() {
          return null;
        }
        return interfaceFunction;
      }
      function strokeInterfaceFactory(shape, view, propertyGroup) {
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
        function addPropertyToDashOb(i2) {
          Object.defineProperty(dashOb, shape.d[i2].nm, {
            get: ExpressionPropertyInterface(view.d.dataProps[i2].p)
          });
        }
        var i;
        var len = shape.d ? shape.d.length : 0;
        var dashOb = {};
        for (i = 0; i < len; i += 1) {
          addPropertyToDashOb(i);
          view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
        }
        function interfaceFunction(val2) {
          if (val2 === "Color" || val2 === "color") {
            return interfaceFunction.color;
          }
          if (val2 === "Opacity" || val2 === "opacity") {
            return interfaceFunction.opacity;
          }
          if (val2 === "Stroke Width" || val2 === "stroke width") {
            return interfaceFunction.strokeWidth;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          color: {
            get: ExpressionPropertyInterface(view.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o)
          },
          strokeWidth: {
            get: ExpressionPropertyInterface(view.w)
          },
          dash: {
            get: function get() {
              return dashOb;
            }
          },
          _name: {
            value: shape.nm
          },
          mn: {
            value: shape.mn
          }
        });
        view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
        view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
        view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
        return interfaceFunction;
      }
      function trimInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val2) {
          if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
            return interfaceFunction.end;
          }
          if (val2 === shape.s.ix) {
            return interfaceFunction.start;
          }
          if (val2 === shape.o.ix) {
            return interfaceFunction.offset;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaceFunction.propertyIndex = shape.ix;
        view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
        view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
        view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
        interfaceFunction.propertyIndex = shape.ix;
        interfaceFunction.propertyGroup = propertyGroup;
        Object.defineProperties(interfaceFunction, {
          start: {
            get: ExpressionPropertyInterface(view.s)
          },
          end: {
            get: ExpressionPropertyInterface(view.e)
          },
          offset: {
            get: ExpressionPropertyInterface(view.o)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function transformInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value2) {
          if (shape.a.ix === value2 || value2 === "Anchor Point") {
            return interfaceFunction.anchorPoint;
          }
          if (shape.o.ix === value2 || value2 === "Opacity") {
            return interfaceFunction.opacity;
          }
          if (shape.p.ix === value2 || value2 === "Position") {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value2 || value2 === "Rotation" || value2 === "ADBE Vector Rotation") {
            return interfaceFunction.rotation;
          }
          if (shape.s.ix === value2 || value2 === "Scale") {
            return interfaceFunction.scale;
          }
          if (shape.sk && shape.sk.ix === value2 || value2 === "Skew") {
            return interfaceFunction.skew;
          }
          if (shape.sa && shape.sa.ix === value2 || value2 === "Skew Axis") {
            return interfaceFunction.skewAxis;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
        view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
        view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
        view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
        view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
        if (view.transform.mProps.sk) {
          view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
          view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
        }
        view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          opacity: {
            get: ExpressionPropertyInterface(view.transform.mProps.o)
          },
          position: {
            get: ExpressionPropertyInterface(view.transform.mProps.p)
          },
          anchorPoint: {
            get: ExpressionPropertyInterface(view.transform.mProps.a)
          },
          scale: {
            get: ExpressionPropertyInterface(view.transform.mProps.s)
          },
          rotation: {
            get: ExpressionPropertyInterface(view.transform.mProps.r)
          },
          skew: {
            get: ExpressionPropertyInterface(view.transform.mProps.sk)
          },
          skewAxis: {
            get: ExpressionPropertyInterface(view.transform.mProps.sa)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.ty = "tr";
        interfaceFunction.mn = shape.mn;
        interfaceFunction.propertyGroup = propertyGroup;
        return interfaceFunction;
      }
      function ellipseInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value2) {
          if (shape.p.ix === value2) {
            return interfaceFunction.position;
          }
          if (shape.s.ix === value2) {
            return interfaceFunction.size;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaceFunction.propertyIndex = shape.ix;
        var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
        prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
        prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          size: {
            get: ExpressionPropertyInterface(prop.s)
          },
          position: {
            get: ExpressionPropertyInterface(prop.p)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function starInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value2) {
          if (shape.p.ix === value2) {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value2) {
            return interfaceFunction.rotation;
          }
          if (shape.pt.ix === value2) {
            return interfaceFunction.points;
          }
          if (shape.or.ix === value2 || value2 === "ADBE Vector Star Outer Radius") {
            return interfaceFunction.outerRadius;
          }
          if (shape.os.ix === value2) {
            return interfaceFunction.outerRoundness;
          }
          if (shape.ir && (shape.ir.ix === value2 || value2 === "ADBE Vector Star Inner Radius")) {
            return interfaceFunction.innerRadius;
          }
          if (shape.is && shape.is.ix === value2) {
            return interfaceFunction.innerRoundness;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
        interfaceFunction.propertyIndex = shape.ix;
        prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
        prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
        prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
        prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
        prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
        if (shape.ir) {
          prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
          prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
        }
        Object.defineProperties(interfaceFunction, {
          position: {
            get: ExpressionPropertyInterface(prop.p)
          },
          rotation: {
            get: ExpressionPropertyInterface(prop.r)
          },
          points: {
            get: ExpressionPropertyInterface(prop.pt)
          },
          outerRadius: {
            get: ExpressionPropertyInterface(prop.or)
          },
          outerRoundness: {
            get: ExpressionPropertyInterface(prop.os)
          },
          innerRadius: {
            get: ExpressionPropertyInterface(prop.ir)
          },
          innerRoundness: {
            get: ExpressionPropertyInterface(prop.is)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function rectInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value2) {
          if (shape.p.ix === value2) {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value2) {
            return interfaceFunction.roundness;
          }
          if (shape.s.ix === value2 || value2 === "Size" || value2 === "ADBE Vector Rect Size") {
            return interfaceFunction.size;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
        interfaceFunction.propertyIndex = shape.ix;
        prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
        prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
        prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          position: {
            get: ExpressionPropertyInterface(prop.p)
          },
          roundness: {
            get: ExpressionPropertyInterface(prop.r)
          },
          size: {
            get: ExpressionPropertyInterface(prop.s)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function roundedInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value2) {
          if (shape.r.ix === value2 || value2 === "Round Corners 1") {
            return interfaceFunction.radius;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view;
        interfaceFunction.propertyIndex = shape.ix;
        prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          radius: {
            get: ExpressionPropertyInterface(prop.rd)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function repeaterInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value2) {
          if (shape.c.ix === value2 || value2 === "Copies") {
            return interfaceFunction.copies;
          }
          if (shape.o.ix === value2 || value2 === "Offset") {
            return interfaceFunction.offset;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view;
        interfaceFunction.propertyIndex = shape.ix;
        prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
        prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          copies: {
            get: ExpressionPropertyInterface(prop.c)
          },
          offset: {
            get: ExpressionPropertyInterface(prop.o)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      return function(shapes, view, propertyGroup) {
        var interfaces2;
        function _interfaceFunction(value2) {
          if (typeof value2 === "number") {
            value2 = value2 === void 0 ? 1 : value2;
            if (value2 === 0) {
              return propertyGroup;
            }
            return interfaces2[value2 - 1];
          }
          var i = 0;
          var len = interfaces2.length;
          while (i < len) {
            if (interfaces2[i]._name === value2) {
              return interfaces2[i];
            }
            i += 1;
          }
          return null;
        }
        function parentGroupWrapper() {
          return propertyGroup;
        }
        _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
        interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
        _interfaceFunction.numProperties = interfaces2.length;
        _interfaceFunction._name = "Contents";
        return _interfaceFunction;
      };
    }();
    var TextExpressionInterface = /* @__PURE__ */ function() {
      return function(elem2) {
        var _sourceText;
        function _thisLayerFunction(name2) {
          switch (name2) {
            case "ADBE Text Document":
              return _thisLayerFunction.sourceText;
            default:
              return null;
          }
        }
        Object.defineProperty(_thisLayerFunction, "sourceText", {
          get: function get() {
            elem2.textProperty.getValue();
            var stringValue = elem2.textProperty.currentData.t;
            if (!_sourceText || stringValue !== _sourceText.value) {
              _sourceText = new String(stringValue);
              _sourceText.value = stringValue || new String(stringValue);
              Object.defineProperty(_sourceText, "style", {
                get: function get2() {
                  return {
                    fillColor: elem2.textProperty.currentData.fc
                  };
                }
              });
            }
            return _sourceText;
          }
        });
        return _thisLayerFunction;
      };
    }();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var FootageInterface = /* @__PURE__ */ function() {
      var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
        var currentPropertyName = "";
        var currentProperty = elem2.getFootageData();
        function init() {
          currentPropertyName = "";
          currentProperty = elem2.getFootageData();
          return searchProperty;
        }
        function searchProperty(value2) {
          if (currentProperty[value2]) {
            currentPropertyName = value2;
            currentProperty = currentProperty[value2];
            if (_typeof(currentProperty) === "object") {
              return searchProperty;
            }
            return currentProperty;
          }
          var propertyNameIndex = value2.indexOf(currentPropertyName);
          if (propertyNameIndex !== -1) {
            var index2 = parseInt(value2.substr(propertyNameIndex + currentPropertyName.length), 10);
            currentProperty = currentProperty[index2];
            if (_typeof(currentProperty) === "object") {
              return searchProperty;
            }
            return currentProperty;
          }
          return "";
        }
        return init;
      };
      var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
        function interfaceFunction(value2) {
          if (value2 === "Outline") {
            return interfaceFunction.outlineInterface();
          }
          return null;
        }
        interfaceFunction._name = "Outline";
        interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
        return interfaceFunction;
      };
      return function(elem2) {
        function _interfaceFunction(value2) {
          if (value2 === "Data") {
            return _interfaceFunction.dataInterface;
          }
          return null;
        }
        _interfaceFunction._name = "Data";
        _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
        return _interfaceFunction;
      };
    }();
    var interfaces = {
      layer: LayerExpressionInterface,
      effects: EffectsExpressionInterface,
      comp: CompExpressionInterface,
      shape: ShapeExpressionInterface,
      text: TextExpressionInterface,
      footage: FootageInterface
    };
    function getInterface(type) {
      return interfaces[type] || null;
    }
    var expressionHelpers = /* @__PURE__ */ function() {
      function searchExpressions(elem2, data2, prop) {
        if (data2.x) {
          prop.k = true;
          prop.x = true;
          prop.initiateExpression = ExpressionManager.initiateExpression;
          prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
        }
      }
      function getValueAtTime(frameNum) {
        frameNum *= this.elem.globalData.frameRate;
        frameNum -= this.offsetTime;
        if (frameNum !== this._cachingAtTime.lastFrame) {
          this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
          this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
          this._cachingAtTime.lastFrame = frameNum;
        }
        return this._cachingAtTime.value;
      }
      function getSpeedAtTime(frameNum) {
        var delta = -0.01;
        var v1 = this.getValueAtTime(frameNum);
        var v2 = this.getValueAtTime(frameNum + delta);
        var speed = 0;
        if (v1.length) {
          var i;
          for (i = 0; i < v1.length; i += 1) {
            speed += Math.pow(v2[i] - v1[i], 2);
          }
          speed = Math.sqrt(speed) * 100;
        } else {
          speed = 0;
        }
        return speed;
      }
      function getVelocityAtTime(frameNum) {
        if (this.vel !== void 0) {
          return this.vel;
        }
        var delta = -1e-3;
        var v1 = this.getValueAtTime(frameNum);
        var v2 = this.getValueAtTime(frameNum + delta);
        var velocity2;
        if (v1.length) {
          velocity2 = createTypedArray("float32", v1.length);
          var i;
          for (i = 0; i < v1.length; i += 1) {
            velocity2[i] = (v2[i] - v1[i]) / delta;
          }
        } else {
          velocity2 = (v2 - v1) / delta;
        }
        return velocity2;
      }
      function getStaticValueAtTime() {
        return this.pv;
      }
      function setGroupProperty(propertyGroup) {
        this.propertyGroup = propertyGroup;
      }
      return {
        searchExpressions,
        getSpeedAtTime,
        getVelocityAtTime,
        getValueAtTime,
        getStaticValueAtTime,
        setGroupProperty
      };
    }();
    function addPropertyDecorator() {
      function loopOut2(type, duration, durationFlag) {
        if (!this.k || !this.keyframes) {
          return this.pv;
        }
        type = type ? type.toLowerCase() : "";
        var currentFrame = this.comp.renderedFrame;
        var keyframes = this.keyframes;
        var lastKeyFrame = keyframes[keyframes.length - 1].t;
        if (currentFrame <= lastKeyFrame) {
          return this.pv;
        }
        var cycleDuration;
        var firstKeyFrame;
        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }
          firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
          } else {
            cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
          }
          firstKeyFrame = lastKeyFrame - cycleDuration;
        }
        var i;
        var len;
        var ret;
        if (type === "pingpong") {
          var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
          if (iterations % 2 !== 0) {
            return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          }
        } else if (type === "offset") {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = (endV[i] - initV[i]) * repeats + current[i];
            }
            return ret;
          }
          return (endV - initV) * repeats + current;
        } else if (type === "continue") {
          var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            ret = new Array(lastValue.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
            }
            return ret;
          }
          return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 1e-3);
        }
        return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
      }
      function loopIn2(type, duration, durationFlag) {
        if (!this.k) {
          return this.pv;
        }
        type = type ? type.toLowerCase() : "";
        var currentFrame = this.comp.renderedFrame;
        var keyframes = this.keyframes;
        var firstKeyFrame = keyframes[0].t;
        if (currentFrame >= firstKeyFrame) {
          return this.pv;
        }
        var cycleDuration;
        var lastKeyFrame;
        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }
          lastKeyFrame = keyframes[duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
          } else {
            cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
          }
          lastKeyFrame = firstKeyFrame + cycleDuration;
        }
        var i;
        var len;
        var ret;
        if (type === "pingpong") {
          var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
          if (iterations % 2 === 0) {
            return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          }
        } else if (type === "offset") {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
            }
            return ret;
          }
          return current - (endV - initV) * repeats;
        } else if (type === "continue") {
          var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            ret = new Array(firstValue.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 1e-3;
            }
            return ret;
          }
          return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 1e-3;
        }
        return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
      }
      function smooth2(width2, samples) {
        if (!this.k) {
          return this.pv;
        }
        width2 = (width2 || 0.4) * 0.5;
        samples = Math.floor(samples || 5);
        if (samples <= 1) {
          return this.pv;
        }
        var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
        var initFrame2 = currentTime - width2;
        var endFrame = currentTime + width2;
        var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
        var i = 0;
        var j = 0;
        var value2;
        if (this.pv.length) {
          value2 = createTypedArray("float32", this.pv.length);
        } else {
          value2 = 0;
        }
        var sampleValue;
        while (i < samples) {
          sampleValue = this.getValueAtTime(initFrame2 + i * sampleFrequency);
          if (this.pv.length) {
            for (j = 0; j < this.pv.length; j += 1) {
              value2[j] += sampleValue[j];
            }
          } else {
            value2 += sampleValue;
          }
          i += 1;
        }
        if (this.pv.length) {
          for (j = 0; j < this.pv.length; j += 1) {
            value2[j] /= samples;
          }
        } else {
          value2 /= samples;
        }
        return value2;
      }
      function getTransformValueAtTime(time2) {
        if (!this._transformCachingAtTime) {
          this._transformCachingAtTime = {
            v: new Matrix()
          };
        }
        var matrix = this._transformCachingAtTime.v;
        matrix.cloneFromProps(this.pre.props);
        if (this.appliedTransformations < 1) {
          var anchor = this.a.getValueAtTime(time2);
          matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
        }
        if (this.appliedTransformations < 2) {
          var scale2 = this.s.getValueAtTime(time2);
          matrix.scale(scale2[0] * this.s.mult, scale2[1] * this.s.mult, scale2[2] * this.s.mult);
        }
        if (this.sk && this.appliedTransformations < 3) {
          var skew = this.sk.getValueAtTime(time2);
          var skewAxis = this.sa.getValueAtTime(time2);
          matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
        }
        if (this.r && this.appliedTransformations < 4) {
          var rotation2 = this.r.getValueAtTime(time2);
          matrix.rotate(-rotation2 * this.r.mult);
        } else if (!this.r && this.appliedTransformations < 4) {
          var rotationZ = this.rz.getValueAtTime(time2);
          var rotationY = this.ry.getValueAtTime(time2);
          var rotationX = this.rx.getValueAtTime(time2);
          var orientation = this.or.getValueAtTime(time2);
          matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
        }
        if (this.data.p && this.data.p.s) {
          var positionX = this.px.getValueAtTime(time2);
          var positionY = this.py.getValueAtTime(time2);
          if (this.data.p.z) {
            var positionZ = this.pz.getValueAtTime(time2);
            matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
          } else {
            matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
          }
        } else {
          var position2 = this.p.getValueAtTime(time2);
          matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
        }
        return matrix;
      }
      function getTransformStaticValueAtTime() {
        return this.v.clone(new Matrix());
      }
      var getTransformProperty = TransformPropertyFactory.getTransformProperty;
      TransformPropertyFactory.getTransformProperty = function(elem2, data2, container) {
        var prop = getTransformProperty(elem2, data2, container);
        if (prop.dynamicProperties.length) {
          prop.getValueAtTime = getTransformValueAtTime.bind(prop);
        } else {
          prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
        }
        prop.setGroupProperty = expressionHelpers.setGroupProperty;
        return prop;
      };
      var propertyGetProp = PropertyFactory.getProp;
      PropertyFactory.getProp = function(elem2, data2, type, mult, container) {
        var prop = propertyGetProp(elem2, data2, type, mult, container);
        if (prop.kf) {
          prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
        } else {
          prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
        }
        prop.setGroupProperty = expressionHelpers.setGroupProperty;
        prop.loopOut = loopOut2;
        prop.loopIn = loopIn2;
        prop.smooth = smooth2;
        prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
        prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
        prop.numKeys = data2.a === 1 ? data2.k.length : 0;
        prop.propertyIndex = data2.ix;
        var value2 = 0;
        if (type !== 0) {
          value2 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
        }
        prop._cachingAtTime = {
          lastFrame: initialDefaultFrame,
          lastIndex: 0,
          value: value2
        };
        expressionHelpers.searchExpressions(elem2, data2, prop);
        if (prop.k) {
          container.addDynamicProperty(prop);
        }
        return prop;
      };
      function getShapeValueAtTime(frameNum) {
        if (!this._cachingAtTime) {
          this._cachingAtTime = {
            shapeValue: shapePool.clone(this.pv),
            lastIndex: 0,
            lastTime: initialDefaultFrame
          };
        }
        frameNum *= this.elem.globalData.frameRate;
        frameNum -= this.offsetTime;
        if (frameNum !== this._cachingAtTime.lastTime) {
          this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
          this._cachingAtTime.lastTime = frameNum;
          this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
        }
        return this._cachingAtTime.shapeValue;
      }
      var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
      var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
      function ShapeExpressions() {
      }
      ShapeExpressions.prototype = {
        vertices: function vertices(prop, time2) {
          if (this.k) {
            this.getValue();
          }
          var shapePath = this.v;
          if (time2 !== void 0) {
            shapePath = this.getValueAtTime(time2, 0);
          }
          var i;
          var len = shapePath._length;
          var vertices2 = shapePath[prop];
          var points = shapePath.v;
          var arr = createSizedArray(len);
          for (i = 0; i < len; i += 1) {
            if (prop === "i" || prop === "o") {
              arr[i] = [vertices2[i][0] - points[i][0], vertices2[i][1] - points[i][1]];
            } else {
              arr[i] = [vertices2[i][0], vertices2[i][1]];
            }
          }
          return arr;
        },
        points: function points(time2) {
          return this.vertices("v", time2);
        },
        inTangents: function inTangents(time2) {
          return this.vertices("i", time2);
        },
        outTangents: function outTangents(time2) {
          return this.vertices("o", time2);
        },
        isClosed: function isClosed() {
          return this.v.c;
        },
        pointOnPath: function pointOnPath(perc, time2) {
          var shapePath = this.v;
          if (time2 !== void 0) {
            shapePath = this.getValueAtTime(time2, 0);
          }
          if (!this._segmentsLength) {
            this._segmentsLength = bez.getSegmentsLength(shapePath);
          }
          var segmentsLength = this._segmentsLength;
          var lengths = segmentsLength.lengths;
          var lengthPos = segmentsLength.totalLength * perc;
          var i = 0;
          var len = lengths.length;
          var accumulatedLength = 0;
          var pt;
          while (i < len) {
            if (accumulatedLength + lengths[i].addedLength > lengthPos) {
              var initIndex = i;
              var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
              var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
              pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
              break;
            } else {
              accumulatedLength += lengths[i].addedLength;
            }
            i += 1;
          }
          if (!pt) {
            pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
          }
          return pt;
        },
        vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
          if (perc == 1) {
            perc = this.v.c;
          } else if (perc == 0) {
            perc = 0.999;
          }
          var pt1 = this.pointOnPath(perc, time2);
          var pt2 = this.pointOnPath(perc + 1e-3, time2);
          var xLength = pt2[0] - pt1[0];
          var yLength = pt2[1] - pt1[1];
          var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
          if (magnitude === 0) {
            return [0, 0];
          }
          var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
          return unitVector;
        },
        tangentOnPath: function tangentOnPath(perc, time2) {
          return this.vectorOnPath(perc, time2, "tangent");
        },
        normalOnPath: function normalOnPath(perc, time2) {
          return this.vectorOnPath(perc, time2, "normal");
        },
        setGroupProperty: expressionHelpers.setGroupProperty,
        getValueAtTime: expressionHelpers.getStaticValueAtTime
      };
      extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
      extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
      KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
      KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
      var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
      ShapePropertyFactory.getShapeProp = function(elem2, data2, type, arr, trims) {
        var prop = propertyGetShapeProp(elem2, data2, type, arr, trims);
        prop.propertyIndex = data2.ix;
        prop.lock = false;
        if (type === 3) {
          expressionHelpers.searchExpressions(elem2, data2.pt, prop);
        } else if (type === 4) {
          expressionHelpers.searchExpressions(elem2, data2.ks, prop);
        }
        if (prop.k) {
          elem2.addDynamicProperty(prop);
        }
        return prop;
      };
    }
    function initialize$1() {
      addPropertyDecorator();
    }
    function addDecorator() {
      function searchExpressions() {
        if (this.data.d.x) {
          this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
          this.addEffect(this.getExpressionValue.bind(this));
          return true;
        }
        return null;
      }
      TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
        var newValue = this.calculateExpression(text2);
        if (currentValue.t !== newValue) {
          var newData = {};
          this.copyData(newData, currentValue);
          newData.t = newValue.toString();
          newData.__complete = false;
          return newData;
        }
        return currentValue;
      };
      TextProperty.prototype.searchProperty = function() {
        var isKeyframed = this.searchKeyframes();
        var hasExpressions = this.searchExpressions();
        this.kf = isKeyframed || hasExpressions;
        return this.kf;
      };
      TextProperty.prototype.searchExpressions = searchExpressions;
    }
    function initialize() {
      addDecorator();
    }
    function SVGComposableEffect() {
    }
    SVGComposableEffect.prototype = {
      createMergeNode: function createMergeNode(resultId, ins) {
        var feMerge = createNS("feMerge");
        feMerge.setAttribute("result", resultId);
        var feMergeNode;
        var i;
        for (i = 0; i < ins.length; i += 1) {
          feMergeNode = createNS("feMergeNode");
          feMergeNode.setAttribute("in", ins[i]);
          feMerge.appendChild(feMergeNode);
          feMerge.appendChild(feMergeNode);
        }
        return feMerge;
      }
    };
    var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
    function SVGTintFilter(filter2, filterManager, elem2, id, source) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS("feColorMatrix");
      feColorMatrix.setAttribute("type", "matrix");
      feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
      feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
      this.linearFilter = feColorMatrix;
      feColorMatrix.setAttribute("result", id + "_tint_1");
      filter2.appendChild(feColorMatrix);
      feColorMatrix = createNS("feColorMatrix");
      feColorMatrix.setAttribute("type", "matrix");
      feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
      feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
      feColorMatrix.setAttribute("result", id + "_tint_2");
      filter2.appendChild(feColorMatrix);
      this.matrixFilter = feColorMatrix;
      var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
      filter2.appendChild(feMerge);
    }
    extendPrototype([SVGComposableEffect], SVGTintFilter);
    SVGTintFilter.prototype.renderFrame = function(forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var colorBlack = this.filterManager.effectElements[0].p.v;
        var colorWhite = this.filterManager.effectElements[1].p.v;
        var opacity = this.filterManager.effectElements[2].p.v / 100;
        this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
        this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
      }
    };
    function SVGFillFilter(filter2, filterManager, elem2, id) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS("feColorMatrix");
      feColorMatrix.setAttribute("type", "matrix");
      feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
      feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
      feColorMatrix.setAttribute("result", id);
      filter2.appendChild(feColorMatrix);
      this.matrixFilter = feColorMatrix;
    }
    SVGFillFilter.prototype.renderFrame = function(forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var color2 = this.filterManager.effectElements[2].p.v;
        var opacity = this.filterManager.effectElements[6].p.v;
        this.matrixFilter.setAttribute("values", "0 0 0 0 " + color2[0] + " 0 0 0 0 " + color2[1] + " 0 0 0 0 " + color2[2] + " 0 0 0 " + opacity + " 0");
      }
    };
    function SVGStrokeEffect(fil, filterManager, elem2) {
      this.initialized = false;
      this.filterManager = filterManager;
      this.elem = elem2;
      this.paths = [];
    }
    SVGStrokeEffect.prototype.initialize = function() {
      var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
      var path;
      var groupPath;
      var i;
      var len;
      if (this.filterManager.effectElements[1].p.v === 1) {
        len = this.elem.maskManager.masksProperties.length;
        i = 0;
      } else {
        i = this.filterManager.effectElements[0].p.v - 1;
        len = i + 1;
      }
      groupPath = createNS("g");
      groupPath.setAttribute("fill", "none");
      groupPath.setAttribute("stroke-linecap", "round");
      groupPath.setAttribute("stroke-dashoffset", 1);
      for (i; i < len; i += 1) {
        path = createNS("path");
        groupPath.appendChild(path);
        this.paths.push({
          p: path,
          m: i
        });
      }
      if (this.filterManager.effectElements[10].p.v === 3) {
        var mask2 = createNS("mask");
        var id = createElementID();
        mask2.setAttribute("id", id);
        mask2.setAttribute("mask-type", "alpha");
        mask2.appendChild(groupPath);
        this.elem.globalData.defs.appendChild(mask2);
        var g = createNS("g");
        g.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
        while (elemChildren[0]) {
          g.appendChild(elemChildren[0]);
        }
        this.elem.layerElement.appendChild(g);
        this.masker = mask2;
        groupPath.setAttribute("stroke", "#fff");
      } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (this.filterManager.effectElements[10].p.v === 2) {
          elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
          while (elemChildren.length) {
            this.elem.layerElement.removeChild(elemChildren[0]);
          }
        }
        this.elem.layerElement.appendChild(groupPath);
        this.elem.layerElement.removeAttribute("mask");
        groupPath.setAttribute("stroke", "#fff");
      }
      this.initialized = true;
      this.pathMasker = groupPath;
    };
    SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
      if (!this.initialized) {
        this.initialize();
      }
      var i;
      var len = this.paths.length;
      var mask2;
      var path;
      for (i = 0; i < len; i += 1) {
        if (this.paths[i].m !== -1) {
          mask2 = this.elem.maskManager.viewData[this.paths[i].m];
          path = this.paths[i].p;
          if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
            path.setAttribute("d", mask2.lastPath);
          }
          if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
            var dasharrayValue;
            if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
              var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
              var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
              var l = path.getTotalLength();
              dasharrayValue = "0 0 0 " + l * s + " ";
              var lineLength = l * (e - s);
              var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              var units = Math.floor(lineLength / segment);
              var j;
              for (j = 0; j < units; j += 1) {
                dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
              }
              dasharrayValue += "0 " + l * 10 + " 0 0";
            } else {
              dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
            }
            path.setAttribute("stroke-dasharray", dasharrayValue);
          }
        }
      }
      if (forceRender || this.filterManager.effectElements[4].p._mdf) {
        this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
      }
      if (forceRender || this.filterManager.effectElements[6].p._mdf) {
        this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
      }
      if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (forceRender || this.filterManager.effectElements[3].p._mdf) {
          var color2 = this.filterManager.effectElements[3].p.v;
          this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color2[0] * 255) + "," + bmFloor(color2[1] * 255) + "," + bmFloor(color2[2] * 255) + ")");
        }
      }
    };
    function SVGTritoneFilter(filter2, filterManager, elem2, id) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS("feColorMatrix");
      feColorMatrix.setAttribute("type", "matrix");
      feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
      feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
      filter2.appendChild(feColorMatrix);
      var feComponentTransfer = createNS("feComponentTransfer");
      feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
      feComponentTransfer.setAttribute("result", id);
      this.matrixFilter = feComponentTransfer;
      var feFuncR = createNS("feFuncR");
      feFuncR.setAttribute("type", "table");
      feComponentTransfer.appendChild(feFuncR);
      this.feFuncR = feFuncR;
      var feFuncG = createNS("feFuncG");
      feFuncG.setAttribute("type", "table");
      feComponentTransfer.appendChild(feFuncG);
      this.feFuncG = feFuncG;
      var feFuncB = createNS("feFuncB");
      feFuncB.setAttribute("type", "table");
      feComponentTransfer.appendChild(feFuncB);
      this.feFuncB = feFuncB;
      filter2.appendChild(feComponentTransfer);
    }
    SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var color1 = this.filterManager.effectElements[0].p.v;
        var color2 = this.filterManager.effectElements[1].p.v;
        var color3 = this.filterManager.effectElements[2].p.v;
        var tableR = color3[0] + " " + color2[0] + " " + color1[0];
        var tableG = color3[1] + " " + color2[1] + " " + color1[1];
        var tableB = color3[2] + " " + color2[2] + " " + color1[2];
        this.feFuncR.setAttribute("tableValues", tableR);
        this.feFuncG.setAttribute("tableValues", tableG);
        this.feFuncB.setAttribute("tableValues", tableB);
      }
    };
    function SVGProLevelsFilter(filter2, filterManager, elem2, id) {
      this.filterManager = filterManager;
      var effectElements = this.filterManager.effectElements;
      var feComponentTransfer = createNS("feComponentTransfer");
      if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
        this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
      }
      if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
        this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
      }
      if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
        this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
      }
      if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
        this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
      }
      if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        filter2.appendChild(feComponentTransfer);
      }
      if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
        feComponentTransfer = createNS("feComponentTransfer");
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        feComponentTransfer.setAttribute("result", id);
        filter2.appendChild(feComponentTransfer);
        this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
        this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
        this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
      }
    }
    SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
      var feFunc = createNS(type);
      feFunc.setAttribute("type", "table");
      feComponentTransfer.appendChild(feFunc);
      return feFunc;
    };
    SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
      var cnt = 0;
      var segments = 256;
      var perc;
      var min = Math.min(inputBlack, inputWhite);
      var max = Math.max(inputBlack, inputWhite);
      var table = Array.call(null, {
        length: segments
      });
      var colorValue;
      var pos = 0;
      var outputDelta = outputWhite - outputBlack;
      var inputDelta = inputWhite - inputBlack;
      while (cnt <= 256) {
        perc = cnt / 256;
        if (perc <= min) {
          colorValue = inputDelta < 0 ? outputWhite : outputBlack;
        } else if (perc >= max) {
          colorValue = inputDelta < 0 ? outputBlack : outputWhite;
        } else {
          colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
        }
        table[pos] = colorValue;
        pos += 1;
        cnt += 256 / (segments - 1);
      }
      return table.join(" ");
    };
    SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var val2;
        var effectElements = this.filterManager.effectElements;
        if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
          val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
          this.feFuncRComposed.setAttribute("tableValues", val2);
          this.feFuncGComposed.setAttribute("tableValues", val2);
          this.feFuncBComposed.setAttribute("tableValues", val2);
        }
        if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
          val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
          this.feFuncR.setAttribute("tableValues", val2);
        }
        if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
          val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
          this.feFuncG.setAttribute("tableValues", val2);
        }
        if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
          val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
          this.feFuncB.setAttribute("tableValues", val2);
        }
        if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
          val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
          this.feFuncA.setAttribute("tableValues", val2);
        }
      }
    };
    function SVGDropShadowEffect(filter2, filterManager, elem2, id, source) {
      var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
      var filterSize = filterManager.data.fs || globalFilterSize;
      filter2.setAttribute("x", filterSize.x || globalFilterSize.x);
      filter2.setAttribute("y", filterSize.y || globalFilterSize.y);
      filter2.setAttribute("width", filterSize.width || globalFilterSize.width);
      filter2.setAttribute("height", filterSize.height || globalFilterSize.height);
      this.filterManager = filterManager;
      var feGaussianBlur = createNS("feGaussianBlur");
      feGaussianBlur.setAttribute("in", "SourceAlpha");
      feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
      feGaussianBlur.setAttribute("stdDeviation", "0");
      this.feGaussianBlur = feGaussianBlur;
      filter2.appendChild(feGaussianBlur);
      var feOffset = createNS("feOffset");
      feOffset.setAttribute("dx", "25");
      feOffset.setAttribute("dy", "0");
      feOffset.setAttribute("in", id + "_drop_shadow_1");
      feOffset.setAttribute("result", id + "_drop_shadow_2");
      this.feOffset = feOffset;
      filter2.appendChild(feOffset);
      var feFlood = createNS("feFlood");
      feFlood.setAttribute("flood-color", "#00ff00");
      feFlood.setAttribute("flood-opacity", "1");
      feFlood.setAttribute("result", id + "_drop_shadow_3");
      this.feFlood = feFlood;
      filter2.appendChild(feFlood);
      var feComposite = createNS("feComposite");
      feComposite.setAttribute("in", id + "_drop_shadow_3");
      feComposite.setAttribute("in2", id + "_drop_shadow_2");
      feComposite.setAttribute("operator", "in");
      feComposite.setAttribute("result", id + "_drop_shadow_4");
      filter2.appendChild(feComposite);
      var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
      filter2.appendChild(feMerge);
    }
    extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
    SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
      if (forceRender || this.filterManager._mdf) {
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
        }
        if (forceRender || this.filterManager.effectElements[0].p._mdf) {
          var col = this.filterManager.effectElements[0].p.v;
          this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
        }
        if (forceRender || this.filterManager.effectElements[1].p._mdf) {
          this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
        }
        if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
          var distance = this.filterManager.effectElements[3].p.v;
          var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
          var x = distance * Math.cos(angle);
          var y = distance * Math.sin(angle);
          this.feOffset.setAttribute("dx", x);
          this.feOffset.setAttribute("dy", y);
        }
      }
    };
    var _svgMatteSymbols = [];
    function SVGMatte3Effect(filterElem, filterManager, elem2) {
      this.initialized = false;
      this.filterManager = filterManager;
      this.filterElem = filterElem;
      this.elem = elem2;
      elem2.matteElement = createNS("g");
      elem2.matteElement.appendChild(elem2.layerElement);
      elem2.matteElement.appendChild(elem2.transformedElement);
      elem2.baseElement = elem2.matteElement;
    }
    SVGMatte3Effect.prototype.findSymbol = function(mask2) {
      var i = 0;
      var len = _svgMatteSymbols.length;
      while (i < len) {
        if (_svgMatteSymbols[i] === mask2) {
          return _svgMatteSymbols[i];
        }
        i += 1;
      }
      return null;
    };
    SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
      var parentNode = mask2.layerElement.parentNode;
      if (!parentNode) {
        return;
      }
      var children = parentNode.children;
      var i = 0;
      var len = children.length;
      while (i < len) {
        if (children[i] === mask2.layerElement) {
          break;
        }
        i += 1;
      }
      var nextChild;
      if (i <= len - 2) {
        nextChild = children[i + 1];
      }
      var useElem = createNS("use");
      useElem.setAttribute("href", "#" + symbolId);
      if (nextChild) {
        parentNode.insertBefore(useElem, nextChild);
      } else {
        parentNode.appendChild(useElem);
      }
    };
    SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
      if (!this.findSymbol(mask2)) {
        var symbolId = createElementID();
        var masker = createNS("mask");
        masker.setAttribute("id", mask2.layerId);
        masker.setAttribute("mask-type", "alpha");
        _svgMatteSymbols.push(mask2);
        var defs = elem2.globalData.defs;
        defs.appendChild(masker);
        var symbol = createNS("symbol");
        symbol.setAttribute("id", symbolId);
        this.replaceInParent(mask2, symbolId);
        symbol.appendChild(mask2.layerElement);
        defs.appendChild(symbol);
        var useElem = createNS("use");
        useElem.setAttribute("href", "#" + symbolId);
        masker.appendChild(useElem);
        mask2.data.hd = false;
        mask2.show();
      }
      elem2.setMatte(mask2.layerId);
    };
    SVGMatte3Effect.prototype.initialize = function() {
      var ind = this.filterManager.effectElements[0].p.v;
      var elements2 = this.elem.comp.elements;
      var i = 0;
      var len = elements2.length;
      while (i < len) {
        if (elements2[i] && elements2[i].data.ind === ind) {
          this.setElementAsMask(this.elem, elements2[i]);
        }
        i += 1;
      }
      this.initialized = true;
    };
    SVGMatte3Effect.prototype.renderFrame = function() {
      if (!this.initialized) {
        this.initialize();
      }
    };
    function SVGGaussianBlurEffect(filter2, filterManager, elem2, id) {
      filter2.setAttribute("x", "-100%");
      filter2.setAttribute("y", "-100%");
      filter2.setAttribute("width", "300%");
      filter2.setAttribute("height", "300%");
      this.filterManager = filterManager;
      var feGaussianBlur = createNS("feGaussianBlur");
      feGaussianBlur.setAttribute("result", id);
      filter2.appendChild(feGaussianBlur);
      this.feGaussianBlur = feGaussianBlur;
    }
    SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var kBlurrinessToSigma = 0.3;
        var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
        var dimensions = this.filterManager.effectElements[1].p.v;
        var sigmaX = dimensions == 3 ? 0 : sigma;
        var sigmaY = dimensions == 2 ? 0 : sigma;
        this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
        var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
        this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
      }
    };
    function TransformEffect() {
    }
    TransformEffect.prototype.init = function(effectsManager) {
      this.effectsManager = effectsManager;
      this.type = effectTypes.TRANSFORM_EFFECT;
      this.matrix = new Matrix();
      this.opacity = -1;
      this._mdf = false;
      this._opMdf = false;
    };
    TransformEffect.prototype.renderFrame = function(forceFrame) {
      this._opMdf = false;
      this._mdf = false;
      if (forceFrame || this.effectsManager._mdf) {
        var effectElements = this.effectsManager.effectElements;
        var anchor = effectElements[0].p.v;
        var position2 = effectElements[1].p.v;
        var isUniformScale = effectElements[2].p.v === 1;
        var scaleHeight = effectElements[3].p.v;
        var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
        var skew = effectElements[5].p.v;
        var skewAxis = effectElements[6].p.v;
        var rotation2 = effectElements[7].p.v;
        this.matrix.reset();
        this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
        this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
        this.matrix.rotate(-rotation2 * degToRads);
        this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
        this.matrix.translate(position2[0], position2[1], 0);
        this._mdf = true;
        if (this.opacity !== effectElements[8].p.v) {
          this.opacity = effectElements[8].p.v;
          this._opMdf = true;
        }
      }
    };
    function SVGTransformEffect(_, filterManager) {
      this.init(filterManager);
    }
    extendPrototype([TransformEffect], SVGTransformEffect);
    function CVTransformEffect(effectsManager) {
      this.init(effectsManager);
    }
    extendPrototype([TransformEffect], CVTransformEffect);
    registerRenderer("canvas", CanvasRenderer);
    registerRenderer("html", HybridRenderer);
    registerRenderer("svg", SVGRenderer);
    ShapeModifiers.registerModifier("tm", TrimModifier);
    ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
    ShapeModifiers.registerModifier("rp", RepeaterModifier);
    ShapeModifiers.registerModifier("rd", RoundCornersModifier);
    ShapeModifiers.registerModifier("zz", ZigZagModifier);
    ShapeModifiers.registerModifier("op", OffsetPathModifier);
    setExpressionsPlugin(Expressions);
    setExpressionInterfaces(getInterface);
    initialize$1();
    initialize();
    registerEffect$1(20, SVGTintFilter, true);
    registerEffect$1(21, SVGFillFilter, true);
    registerEffect$1(22, SVGStrokeEffect, false);
    registerEffect$1(23, SVGTritoneFilter, true);
    registerEffect$1(24, SVGProLevelsFilter, true);
    registerEffect$1(25, SVGDropShadowEffect, true);
    registerEffect$1(28, SVGMatte3Effect, false);
    registerEffect$1(29, SVGGaussianBlurEffect, true);
    registerEffect$1(35, SVGTransformEffect, false);
    registerEffect(35, CVTransformEffect);
    return lottie;
  });
})(lottie$1, lottie$1.exports);
var lottieExports = lottie$1.exports;
const lottie = /* @__PURE__ */ getDefaultExportFromCjs(lottieExports);
const isEmpty = (obj) => {
  return Object.keys(obj).length === 0;
};
const gotoPage = (path) => {
  removeEventHandler();
  history.push(path);
};
const eventArray = {
  CLICK: [],
  CHANGE: [],
  KEYDOWN: [],
  KEYUP: [],
  DOMLOADED: [],
  RESIZE: [],
  BEFOREUNLOAD: [],
  LOTTIE: [],
  LOTTIEANI: []
};
const resetEventArray = () => {
  for (let key2 in eventArray) {
    eventArray[key2] = [];
  }
};
const eventType = {
  CLICK: "CLICK",
  CHANGE: "CHANGE",
  KEYDOWN: "KEYDOWN",
  KEYUP: "KEYUP",
  DOMLOADED: "DOMLOADED",
  RESIZE: "RESIZE",
  BEFOREUNLOAD: "BEFOREUNLOAD",
  LOTTIE: "LOTTIE"
};
const addEventArray = (eventType2, event) => {
  eventArray[eventType2].push(event);
};
const addEventHandler = () => {
  eventArray["CLICK"].forEach((event) => {
    document.addEventListener("click", event);
  });
  eventArray["CHANGE"].forEach((event) => {
    document.addEventListener("change", event);
  });
  eventArray["KEYDOWN"].forEach((event) => {
    document.addEventListener("keydown", event);
  });
  eventArray["KEYUP"].forEach((event) => {
    document.addEventListener("keyup", event);
  });
  eventArray["DOMLOADED"].forEach((event) => {
    document.addEventListener("DOMContentLoaded", event);
  });
  eventArray["RESIZE"].forEach((event) => {
    window.addEventListener("resize", event);
  });
  eventArray["BEFOREUNLOAD"].forEach((event) => {
    window.addEventListener("beforeunload", event);
  });
  eventArray["LOTTIE"].forEach((event) => {
    eventArray["LOTTIEANI"].push(lottie.loadAnimation(event));
  });
};
const removeEventHandler = () => {
  eventArray["CLICK"].forEach((event) => {
    document.removeEventListener("click", event);
  });
  eventArray["CHANGE"].forEach((event) => {
    document.removeEventListener("change", event);
  });
  eventArray["KEYDOWN"].forEach((event) => {
    document.removeEventListener("keydown", event);
  });
  eventArray["KEYUP"].forEach((event) => {
    document.removeEventListener("keyup", event);
  });
  eventArray["DOMLOADED"].forEach((event) => {
    document.removeEventListener("DOMContentLoaded", event);
  });
  eventArray["RESIZE"].forEach((event) => {
    window.removeEventListener("resize", event);
  });
  eventArray["BEFOREUNLOAD"].forEach((event) => {
    window.removeEventListener("beforeunload", event);
  });
  eventArray["LOTTIEANI"].forEach((event) => {
    event.destroy();
  });
  resetEventArray();
};
const observable = (obj) => {
  const observerMap = {};
  return new Proxy(obj, {
    get(target, name2) {
      observerMap[name2] = observerMap[name2] || /* @__PURE__ */ new Set();
      return target[name2];
    },
    set(target, name2, value2) {
      if (target[name2] === value2)
        return true;
      target[name2] = value2;
      observerMap[name2].forEach((fn) => fn());
      return true;
    }
  });
};
const createStore = (reducer) => {
  const state = observable(reducer());
  const frozenState = {};
  Object.keys(state).forEach((key2) => {
    Object.defineProperty(frozenState, key2, {
      get: () => state[key2]
      // get  set    .
    });
  });
  const dispatch = (action) => {
    const newState = reducer(state, action);
    for (const [key2, value2] of Object.entries(newState)) {
      if (!state[key2])
        continue;
      state[key2] = value2;
    }
  };
  const getState = () => frozenState;
  return { getState, dispatch };
};
const WS_GAMELOGIC = "WS_GAMELOGIC";
const initState$3 = {
  socket: {}
};
const webSocketConnect$1 = (socket) => ({
  type: WS_GAMELOGIC,
  payload: socket
});
const reducer_gamelogic = (state = initState$3, action = {}) => {
  switch (action.type) {
    case WS_GAMELOGIC:
      return {
        ...state,
        socket: action.payload
      };
    default:
      return state;
  }
};
const ws_gamelogic = createStore(reducer_gamelogic);
const disconnectGameLogicWebSocket = () => {
  if (ws_gamelogic.getState().socket instanceof WebSocket === true) {
    ws_gamelogic.getState().socket.close();
  }
};
const connectGameLogicWebSocket = (dispatch, path) => {
  if (ws_gamelogic.getState().socket instanceof WebSocket === false || ws_gamelogic.getState().socket.readyState === WebSocket.CLOSED || ws_gamelogic.getState().socket.readyState === WebSocket.CLOSING) {
    const socket = new WebSocket("wss://10.31.5.2" + path);
    dispatch(webSocketConnect$1(socket));
    socket.onerror = (e) => {
      gotoPage("/");
    };
  }
};
const frameRunner = (callback2) => {
  let requestId2;
  return () => {
    requestId2 && cancelAnimationFrame(requestId2);
    requestId2 = requestAnimationFrame(callback2);
  };
};
const domRenderer = () => {
  const options = {
    states: {},
    stateHook: {},
    refs: {},
    refHook: {},
    dependencies: [],
    effectHook: 0,
    effectList: []
  };
  const renderInfo = {
    $root: null,
    component: null,
    currentVDOM: null
  };
  const resetOptions = () => {
    options.states = {};
    options.stateHook = {};
    options.refs = {};
    options.refHook = {};
    options.dependencies = {};
    options.effectHook = {};
    options.effectList = {};
  };
  const _render = frameRunner(() => {
    const { $root, component, currentVDOM } = renderInfo;
    if (!$root || !component)
      return;
    setCurrentComponent(component.name);
    const newVDOM = component();
    updateElement($root, newVDOM, currentVDOM);
    renderInfo.currentVDOM = newVDOM;
    options.stateHook = {};
    options.refHook = {};
    options.effectHook = {};
    for (let key2 in options.effectList) {
      options.effectList[key2].forEach((effect2) => effect2());
    }
    options.effectList = {};
  });
  const render2 = (root, component) => {
    resetOptions();
    renderInfo.$root = root;
    renderInfo.component = component;
    disconnectGameLogicWebSocket();
    const modalBackdrop = document.querySelector(".modal-backdrop");
    if (modalBackdrop) {
      modalBackdrop.remove();
    }
    _render();
  };
  const useState2 = (initialState) => {
    const { stateHook, states } = options;
    const component = currentComponent;
    if (!stateHook[component]) {
      stateHook[component] = 0;
    }
    if (states[component] === void 0) {
      states[component] = [];
    }
    const index2 = stateHook[component];
    if (states[component].length === index2)
      states[component].push(initialState);
    const state = states[component][index2];
    const setState = (newState) => {
      if (shallowEqual(states[component][index2], newState))
        return;
      states[component][index2] = newState;
      _render();
    };
    options.stateHook[component] += 1;
    return [state, setState];
  };
  const useRef2 = (initialState) => {
    const { refHook, refs } = options;
    const component = currentComponent;
    if (!refHook[component]) {
      refHook[component] = 0;
    }
    if (!refs[component]) {
      refs[component] = [];
    }
    const index2 = refHook[component];
    if (refs.length === index2)
      refs[component].push(initialState);
    const getRef = () => refs[component][index2];
    const setRef = (newRef) => {
      if (shallowEqual(getRef(), newRef))
        return;
      refs[component][index2] = newRef;
    };
    options.refHook[component] += 1;
    return [getRef, setRef];
  };
  const useEffect2 = (callback2, dependencies) => {
    const component = currentComponent;
    if (!options.effectHook[component]) {
      options.effectHook[component] = 0;
    }
    if (!options.effectList[component]) {
      options.effectList[component] = [];
    }
    if (!options.dependencies[component]) {
      options.dependencies[component] = [];
    }
    const index2 = options.effectHook[component];
    options.effectList[component][index2] = () => {
      const hasNoDeps = !dependencies;
      const prevDeps = options.dependencies[component][index2];
      const hasChangedDeps = prevDeps ? dependencies == null ? void 0 : dependencies.some((deps, i) => !shallowEqual(deps, prevDeps[i])) : true;
      if (hasNoDeps || hasChangedDeps) {
        options.dependencies[component][index2] = dependencies;
        callback2();
      }
    };
    options.effectHook[component] += 1;
  };
  return { useState: useState2, useEffect: useEffect2, useRef: useRef2, render: render2 };
};
const { useState, useEffect, useRef, render } = domRenderer();
const spaRouter = () => {
  let pageParams;
  const routeInfo2 = {
    root: null,
    routes: null
  };
  const matchUrlToRoute = (routes2, path) => {
    const segments = path.split("/").map((segment) => {
      if (segment === "")
        return "/";
      return segment;
    });
    if (segments.length <= 2 && segments[1] === "/") {
      return { Component: routes2[0].element, params: void 0 };
    }
    const traverse = (routes3, segments2, errorComponent) => {
      for (const route of routes3) {
        const { path: path2, children, element, errorElement } = route;
        const regex = pathToRegex(path2);
        const [pathname, params] = segments2[0].match(regex) || [];
        if (!pathname)
          continue;
        if (segments2.length === 1) {
          return { Component: element, params };
        } else if (children) {
          return traverse(
            children,
            segments2.slice(1),
            errorElement ?? errorComponent
          );
        }
      }
      return { Component: errorComponent, params: void 0 };
    };
    return traverse(routes2, segments);
  };
  const loadRouteComponent = (path) => {
    const { Component, params } = matchUrlToRoute(routeInfo2.routes ?? [], path);
    if (!Component) {
      gotoPage("/");
    } else {
      pageParams = params;
      if (routeInfo2.root) {
        setCurrentComponent(Component.name);
        render(routeInfo2.root, Component);
      } else {
        throw new Error("root element is empty");
      }
    }
  };
  const history2 = {
    getPageParams() {
      return pageParams;
    },
    replace(path) {
    },
    push(path) {
      const { pathname, search } = new URL(window.location.origin + path);
      window.history.pushState({}, "", pathname + search);
      loadRouteComponent(pathname);
    },
    back() {
    },
    currentPath() {
      return window.location.pathname;
    }
  };
  const router2 = (root, routes2) => {
    routeInfo2.root = root;
    routeInfo2.routes = routes2;
    const customizeAnchorBehavior = () => {
      window.addEventListener("click", (e) => {
        const anchor = e.target.closest("a[data-link]");
        if (!(anchor instanceof HTMLAnchorElement))
          return;
        if (!anchor)
          return;
        e.preventDefault();
        history2.push(anchor.pathname + anchor.search);
      });
    };
    const initLoad = () => {
      loadRouteComponent(history2.currentPath());
      customizeAnchorBehavior();
      window.addEventListener("popstate", () => {
        loadRouteComponent(history2.currentPath());
      });
    };
    initLoad();
  };
  return { history: history2, router: router2 };
};
const { history, router } = spaRouter();
const NotFoundPage = () => {
  gotoPage("/lobby");
};
const MainPage = () => {
  const MoveTo2FA = () => {
    window.location.href = "https://10.31.5.2/api/auth/login";
  };
  return /* @__PURE__ */ h("div", { class: "main-page" }, /* @__PURE__ */ h("h1", { class: "title" }, "TRAnscendence"), /* @__PURE__ */ h("button", { type: "button", class: "large-btn", onclick: MoveTo2FA }, "42 login"));
};
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val2) {
  return val2 !== null && !isUndefined(val2) && val2.constructor !== null && !isUndefined(val2.constructor) && isFunction$1(val2.constructor.isBuffer) && val2.constructor.isBuffer(val2);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val2) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val2);
  } else {
    result = val2 && val2.buffer && isArrayBuffer(val2.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber$1 = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val2) => {
  if (kindOf(val2) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val2);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val2) && !(Symbol.iterator in val2);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val2) => isObject$1(val2) && isFunction$1(val2.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val2, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val2)) {
      result[targetKey] = merge$1(result[targetKey], val2);
    } else if (isPlainObject(val2)) {
      result[targetKey] = merge$1({}, val2);
    } else if (isArray$1(val2)) {
      result[targetKey] = val2.slice();
    } else {
      result[targetKey] = val2;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val2, key2) => {
    if (thisArg && isFunction$1(val2)) {
      a[key2] = bind(val2, thisArg);
    } else {
      a[key2] = val2;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray$1(thing))
    return thing;
  let i = thing.length;
  if (!isNumber$1(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value2 = obj[name2];
    if (!isFunction$1(value2))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value2, defaultValue) => {
  return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$1(source) ? [] : {};
        forEach(source, (value2, key2) => {
          const reducedValue = visit(value2, i + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const utils$1 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber: isNumber$1,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors$1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors$1[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors$1);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key2) {
  return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path, key2, dots) {
  if (!path)
    return key2;
  return path.concat(key2).map(function each2(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined2(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null)
      return "";
    if (utils$1.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value2)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value2) || utils$1.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key2, path) {
    let arr = value2;
    if (value2 && !path && typeof value2 === "object") {
      if (utils$1.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils$1.isArray(value2) && isFlatArray(value2) || (utils$1.isFileList(value2) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value2))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each2(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path, key2, dots), convertValue(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value2, path) {
    if (utils$1.isUndefined(value2))
      return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value2);
    utils$1.forEach(value2, function each2(el, key2) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key2) ? key2.trim() : key2,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value2) {
  this._pairs.push([name2, value2]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value2) {
    return encoder.call(this, value2, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val2) {
  return encodeURIComponent(val2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h3) {
      if (h3 !== null) {
        fn(h3);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key2, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value2)) {
        this.append(key2, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key2;
  for (i = 0; i < len; i++) {
    key2 = keys[i];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value2, target, index2) {
    let name2 = path[index2++];
    if (name2 === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value2];
      } else {
        target[name2] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$1.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value2, target[name2], index2);
    if (result && utils$1.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name2, value2) => {
      buildPath(parsePropPath(name2), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data2);
    if (isObjectPayload && utils$1.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1.isArrayBuffer(data2) || utils$1.isBuffer(data2) || utils$1.isStream(data2) || utils$1.isFile(data2) || utils$1.isBlob(data2) || utils$1.isReadableStream(data2)) {
      return data2;
    }
    if (utils$1.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data2) || utils$1.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils$1.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val2;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key2 = line.substring(0, i).trim().toLowerCase();
    val2 = line.substring(i + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val2);
      } else {
        parsed[key2] = [val2];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val2 : val2;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils$1.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context2, value2, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value2, header);
  }
  if (isHeaderNameFilter) {
    value2 = header;
  }
  if (!utils$1.isString(value2))
    return;
  if (utils$1.isString(filter2)) {
    return value2.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = utils$1.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key2, value2] of header.entries()) {
        setHeader(value2, key2, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$1.findKey(this, header);
      if (key2) {
        const value2 = this[key2];
        if (!parser) {
          return value2;
        }
        if (parser === true) {
          return parseTokens(value2);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value2, key2);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$1.findKey(this, header);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils$1.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key2 = keys[i];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value2, header) => {
      const key2 = utils$1.findKey(headers, header);
      if (key2) {
        self2[key2] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils$1.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: value2 }, key2) => {
  let mapped = key2[0].toUpperCase() + key2.slice(1);
  return {
    get: () => value2,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
function transformData(fns, response) {
  const config = this || defaults$1;
  const context2 = response || config;
  const headers = AxiosHeaders.from(context2.headers);
  let data2 = context2.data;
  utils$1.forEach(fns, function transform2(fn) {
    data2 = fn.call(config, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled2() {
    const force = this === true;
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, arguments);
      }, threshold - (now - timestamp));
    }
  };
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null
    };
    data2[isDownloadStream ? "download" : "upload"] = true;
    listener(data2);
  }, freq);
};
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value2, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value2)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data2)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let { responseType } = _config;
    let onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve2(value2) {
        resolve2(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, _config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, _config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        _config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val2, key2) {
        request.setRequestHeader(key2, val2);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (typeof _config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(_config.onDownloadProgress, true));
    }
    if (typeof _config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize, encode2) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
  const iterator = readBytes(stream, chunkSize, encode2);
  let bytes = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(controller) {
      const { done, value: value2 } = await iterator.next();
      if (done) {
        controller.close();
        onFinish();
        return;
      }
      let len = value2.byteLength;
      onProgress && onProgress(bytes += len);
      controller.enqueue(new Uint8Array(value2));
    },
    cancel(reason) {
      onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const fetchProgressDecorator = (total, fn) => {
  const lengthComputable = total != null;
  return (loaded) => setTimeout(() => fn({
    lengthComputable,
    total,
    loaded
  }));
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const supportsRequestStream = isReadableStreamSupported && (() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
})();
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && !!(() => {
  try {
    return utils$1.isReadableStream(new Response("").body);
  } catch (err) {
  }
})();
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length2 = utils$1.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data: data2,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data2)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data2,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
          requestContentLength,
          progressEventReducer(onUploadProgress)
        ), null, encodeText);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "cors" : "omit";
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data2,
      duplex: "half",
      withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
          responseContentLength,
          progressEventReducer(onDownloadProgress, true)
        ), isStreamResponse && onFinish, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value2) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value2 });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value: value2 });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters$1 = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters$1.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value2, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve2;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve2 = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve2);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
function spread(callback2) {
  return function wrap(arr) {
    return callback2.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key2, value2]) => {
  HttpStatusCode[value2] = key2;
});
function createInstance(defaultConfig) {
  const context2 = new Axios(defaultConfig);
  const instance2 = bind(Axios.prototype.request, context2);
  utils$1.extend(instance2, Axios.prototype, context2, { allOwnKeys: true });
  utils$1.extend(instance2, context2, null, { allOwnKeys: true });
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters$1.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
const STATUS_401_UNAUTHORIZED = 401;
const STATUS_403_FORBIDDEN = 403;
axios.defaults.withCredentials = true;
const instance = axios.create({
  baseURL: "https://10.31.5.2",
  // baseURL: import.meta.env.VITE_BE_HOST,
  withCredentials: true
});
instance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    var _a, _b;
    if (((_a = error.response) == null ? void 0 : _a.status) === STATUS_401_UNAUTHORIZED || ((_b = error.response) == null ? void 0 : _b.status) === STATUS_403_FORBIDDEN) {
      gotoPage("/");
    }
    return Promise.reject(error);
  }
);
const apiURL = "/api";
const axiosAuthURL = `${apiURL}/auth`;
const axiosUserURL = `${apiURL}/user`;
const axiosVerifyOTPURL = `${axiosAuthURL}/otp`;
const axiosUserMeURL = `${axiosUserURL}/me`;
const axiosUserFollowURL = `${axiosUserURL}/follow`;
const axiosVerfiyOTP = async (otp) => {
  try {
    const response = await instance.post(axiosVerifyOTPURL + "/", { otp });
    return response;
  } catch (error) {
    return error;
  }
};
const axiosUserOther = async (username) => {
  try {
    const response = await instance.get(`${axiosUserURL}/${username}`);
    return response;
  } catch (error) {
    return error;
  }
};
const axiosUserMe = async () => {
  try {
    const response = await instance.get(axiosUserMeURL);
    return response;
  } catch (error) {
    return error;
  }
};
const axiosUserMeConfig = async (config2Change) => {
  try {
    const response = await instance.put(axiosUserMeURL + "/", config2Change);
    return response;
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosDeleteProfileImg = async () => {
  try {
    const response = await instance.delete(axiosUserMeURL);
    return response;
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosUserDayStat = async ({ username }) => {
  try {
    const response = await instance.get(
      `${axiosUserURL}/${username}/user-day-stat`
    );
    return response;
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosUserRecentOpponent = async ({ username }) => {
  try {
    const response = await instance.get(
      `${axiosUserURL}/${username}/user-recent-opponent`
    );
    return response;
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosGameDetail = async ({ gameId }) => {
  try {
    const response = await instance.get(
      `${axiosUserURL}/game-detail/${gameId}`
    );
    return response;
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosGameRecords = async ({ username, isSingle }) => {
  try {
    if (isSingle === "SINGLE") {
      const response = await instance.get(
        `${axiosUserURL}/${username}/record/single`
      );
      return response;
    } else if (isSingle === "MULTI") {
      const response = await instance.get(
        `${axiosUserURL}/${username}/record/multi`
      );
      return response;
    }
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosAvgGameLine = async ({ username }) => {
  try {
    const response = await instance.get(
      `${axiosUserURL}/${username}/average-line`
    );
    return response;
  } catch (error) {
    console.error(error);
    return error;
  }
};
const axiosUserFollow = async (user_name) => {
  try {
    const apiURL2 = axiosUserFollowURL + "/";
    const response = await instance.post(apiURL2, {
      following_username: user_name
    });
    return response;
  } catch (error) {
    return error;
  }
};
const axiosUserUnfollow = async (user_name) => {
  try {
    const apiURL2 = axiosUserFollowURL + "/" + user_name;
    const response = await instance.delete(apiURL2);
    return response;
  } catch (error) {
    return error;
  }
};
const axiosLogout = async () => {
  try {
    const response = await instance.get(`${axiosUserURL}/logout`);
    return response;
  } catch (error) {
    return error;
  }
};
const WS_CONNECT = "WS_CONNECT";
const initState$2 = {
  socket: {},
  offline: [],
  online: []
};
const webSocketConnect = (socket, offline, online) => ({
  type: WS_CONNECT,
  payload: [socket, offline, online]
});
const reducer_userlist = (state = initState$2, action = {}) => {
  switch (action.type) {
    case WS_CONNECT:
      return {
        ...state,
        socket: action.payload[0],
        offline: action.payload[1],
        online: action.payload[2]
      };
    default:
      return state;
  }
};
const ws_userlist = createStore(reducer_userlist);
const startWebSocketConnection = (dispatch, setUserList) => {
  if (ws_userlist.getState().socket instanceof WebSocket === false || ws_userlist.getState().socket.readyState === WebSocket.CLOSED || ws_userlist.getState().socket.readyState === WebSocket.CLOSING) {
    const socket = new WebSocket("wss://10.31.5.2/ws/online/");
    dispatch(webSocketConnect(socket, [], []));
  }
  ws_userlist.getState().socket.onmessage = (e) => {
    const data2 = JSON.parse(e.data);
    if (data2.type === "status") {
      dispatch(
        webSocketConnect(
          ws_userlist.getState().socket,
          data2.offline,
          data2.online
        )
      );
      setUserList(data2);
    } else if (data2.type === "add_online") {
      dispatch(
        webSocketConnect(
          ws_userlist.getState().socket,
          ws_userlist.getState().offline.filter((obj) => obj.username !== data2.online[0].username),
          [
            ...ws_userlist.getState().online,
            !ws_userlist.getState().online.some((obj) => obj.username === data2.online[0].username) ? data2.online[0] : null
          ].filter((obj) => obj !== null)
        )
      );
      setUserList({
        online: ws_userlist.getState().online,
        offline: ws_userlist.getState().offline
      });
    } else if (data2.type === "add_offline") {
      dispatch(
        webSocketConnect(
          ws_userlist.getState().socket,
          [
            ...ws_userlist.getState().offline,
            !ws_userlist.getState().offline.some((obj) => obj.username === data2.offline[0].username) ? data2.offline[0] : null
          ].filter((obj) => obj !== null),
          ws_userlist.getState().online.filter((obj) => obj.username !== data2.offline[0].username)
        )
      );
      setUserList({
        online: ws_userlist.getState().online,
        offline: ws_userlist.getState().offline
      });
    } else if (data2.type === "duplicate_login") {
      axiosLogout().then((res) => {
        if (res.status === 200) {
          ws_userlist.getState().socket.close();
          ws_gamelogic.getState().socket.close();
          gotoPage("/");
        }
      });
    }
  };
};
const SET_CLIENT = "SET_CLIENT";
const initState$1 = {
  client: {}
};
const set_client = (client) => ({
  type: SET_CLIENT,
  payload: client
});
const reducer_client$1 = (state = initState$1, action = {}) => {
  switch (action.type) {
    case SET_CLIENT:
      return { ...state, client: action.payload };
    default:
      return state;
  }
};
const clientUserStore = createStore(reducer_client$1);
const setUserData = (dispatch, client) => {
  dispatch(set_client(client));
};
const calcGameRate = (data2) => {
  return data2.win + data2.lose === 0 ? 0 : (data2.win / (data2.win + data2.lose) * 100).toFixed(2);
};
const moveToProfile = (userName) => {
  if (history.currentPath() === `/profile/${userName}` || userName === void 0) {
    return;
  }
  if (userName === clientUserStore.getState().client.username) {
    gotoPage(`/profile/me`);
  } else {
    gotoPage(`/profile/${userName}`);
  }
};
const User = ({ user, isactive }) => {
  const randNum = user.username[0].charCodeAt(0) % 5 + 1;
  const imgSrc = `/img/minji_${randNum}.jpg`;
  return /* @__PURE__ */ h(
    "div",
    {
      class: `user-item ${isactive ? "active" : "sleep"}`,
      onclick: () => moveToProfile(user.username)
    },
    /* @__PURE__ */ h("div", { class: "profile" }, /* @__PURE__ */ h("img", { src: user.profile_image ? user.profile_image : imgSrc }), /* @__PURE__ */ h("span", { class: `isloggedin ${isactive ? "active" : "sleep"}` }, "")),
    /* @__PURE__ */ h("div", { class: "user-info" }, /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("h6", null, user.username), /* @__PURE__ */ h("p", null, "win: ", user.win, " lose: ", user.lose), /* @__PURE__ */ h("p", null, "rate: ", calcGameRate(user), "%")))
  );
};
const UserList = () => {
  const [userListData, setUserListData] = useState({
    offline: ws_userlist.getState().offline,
    online: ws_userlist.getState().online
  });
  useEffect(() => {
    const socketAsync = async () => {
      startWebSocketConnection(ws_userlist.dispatch, setUserListData);
    };
    socketAsync();
  }, []);
  const userListToggle = () => {
    document.querySelector("#user-list-toggle").classList.toggle("active");
    document.querySelector(".overlay").classList.toggle("active");
  };
  const userListToggleBack = () => {
    document.querySelector("#user-list-toggle").classList.toggle("active");
    document.querySelector(".overlay").classList.toggle("active");
  };
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("button", { class: "user-list-btn", onclick: userListToggle }, `<`), /* @__PURE__ */ h("div", { id: "user-list-toggle" }, /* @__PURE__ */ h("div", { class: "user-list" }, userListData.online && userListData.online.map((user) => {
    return /* @__PURE__ */ h(User, { user, isactive: true });
  }), userListData.offline && userListData.offline.map((user) => {
    return /* @__PURE__ */ h(User, { user, isactive: false });
  }))), /* @__PURE__ */ h("div", { class: "overlay", onclick: userListToggleBack }));
};
const Modal = (props) => {
  return /* @__PURE__ */ h("div", { id: props.id, class: "modal fade", tabindex: "-1" }, /* @__PURE__ */ h("div", { class: "modal-dialog modal-dialog-centered" }, /* @__PURE__ */ h("div", { class: "modal-content" }, /* @__PURE__ */ h("div", { class: "modal-header" }, props.title ? props.title() : null), /* @__PURE__ */ h("div", { class: "modal-body" }, props.body ? props.body() : null), /* @__PURE__ */ h("div", { class: "modal-footer" }, props.footer ? props.footer() : null))));
};
const TitleSection = (props) => {
  return /* @__PURE__ */ h("div", { class: "modal-title" }, /* @__PURE__ */ h("div", { class: "modal-title-text" }, /* @__PURE__ */ h("img", { src: props.IconPath }), /* @__PURE__ */ h("h3", null, props.Title)), /* @__PURE__ */ h("div", { class: "modal-title-close" }, /* @__PURE__ */ h("img", { src: "/icon/close.svg", "data-bs-dismiss": "modal" })));
};
const BottomSection = (props) => {
  return /* @__PURE__ */ h(
    "button",
    {
      class: "small-btn",
      "data-bs-dismiss": "modal",
      onclick: props.ClickEvent
    },
    props.ButtonName
  );
};
const InputBox = (props) => {
  return /* @__PURE__ */ h("div", { class: "input body-element" }, /* @__PURE__ */ h("h6", null, props.text), /* @__PURE__ */ h("input", { type: props.type, placeholder: props.defaultValue }));
};
const RadioCheck = (props) => {
  const toggleInputFields = () => {
    const radios = document.querySelectorAll("input[type=radio]");
    const inputs = document.querySelectorAll("input[type=text]");
    if (radios[0].checked) {
      inputs[1].disabled = true;
      inputs[1].value = "";
    } else {
      inputs[1].disabled = false;
      inputs[1].focus();
    }
  };
  return /* @__PURE__ */ h("div", { class: "form-check" }, /* @__PURE__ */ h(
    "input",
    {
      class: "form-check-input",
      type: "radio",
      name: props.name,
      id: props.id,
      tabIndex: "-1",
      onchange: toggleInputFields
    }
  ), /* @__PURE__ */ h("label", { class: "form-check-label", for: props.id }, props.text));
};
const ToggleBtn = (props) => {
  return /* @__PURE__ */ h("label", { class: "toggle-button" }, /* @__PURE__ */ h("input", { type: "checkbox" }), /* @__PURE__ */ h("div", { class: "toggle-text" }, props.text));
};
const NumberStepper = (props) => {
  let isHolding = false;
  let modifier = 0;
  let cnt = 0;
  let delay = 100;
  const updateNumber = () => {
    const numberDisplay = document.getElementById("Number");
    if (isHolding) {
      numberDisplay.innerText = parseInt(numberDisplay.innerText) + modifier;
      cnt++;
      if (cnt > 10) {
        delay = 50;
      }
      if (parseInt(numberDisplay.innerText) < 1) {
        numberDisplay.innerText = 1;
      }
      if (parseInt(numberDisplay.innerText) > 30) {
        numberDisplay.innerText = 30;
      }
      setTimeout(() => {
        if (isHolding)
          requestAnimationFrame(updateNumber);
      }, delay);
    }
  };
  const startHolding = (mod2) => {
    if (!isHolding) {
      isHolding = true;
      modifier = mod2;
      requestAnimationFrame(updateNumber);
    }
  };
  const stopHolding = () => {
    isHolding = false;
    delay = 100;
    cnt = 0;
  };
  useEffect(() => {
    const increaseButton = document.getElementById("Increase");
    const decreaseButton = document.getElementById("Decrease");
    increaseButton.addEventListener("mousedown", () => startHolding(1));
    increaseButton.addEventListener("mouseup", stopHolding);
    increaseButton.addEventListener("mouseleave", stopHolding);
    increaseButton.addEventListener("touchstart", () => startHolding(1));
    increaseButton.addEventListener("touchend", stopHolding);
    decreaseButton.addEventListener("mousedown", () => startHolding(-1));
    decreaseButton.addEventListener("mouseup", stopHolding);
    decreaseButton.addEventListener("mouseleave", stopHolding);
    decreaseButton.addEventListener("touchstart", () => startHolding(-1));
    decreaseButton.addEventListener("touchend", stopHolding);
  }, []);
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", { class: "stepper-text" }, props.text), /* @__PURE__ */ h("div", { class: props.type }, /* @__PURE__ */ h("button", { class: "mod-btn", id: "Decrease" }, "-"), /* @__PURE__ */ h("div", { id: "Number" }, props.defaultValue), /* @__PURE__ */ h("button", { class: "mod-btn", id: "Increase" }, "+")));
};
const UserFind = ({ userData }) => {
  let imgSrc = `/img/minji_${userData.username[0].charCodeAt(0) % 5 + 1}.jpg`;
  if (userData.profile_image !== null) {
    imgSrc = userData.profile_image;
  }
  return /* @__PURE__ */ h(
    "div",
    {
      class: "user-item",
      onclick: () => {
        const findModalElement = document.getElementById("FindUserModal");
        setTimeout(() => {
          const findModal = new bootstrap.Modal(findModalElement);
          if (findModal) {
            findModal.hide();
          }
          const modalBackdrop = document.querySelector(".modal-backdrop");
          if (modalBackdrop) {
            modalBackdrop.remove();
          }
        }, 10);
        moveToProfile(userData.username);
      }
    },
    /* @__PURE__ */ h("div", { class: "profile" }, /* @__PURE__ */ h("img", { src: imgSrc })),
    /* @__PURE__ */ h("div", { class: "user-info" }, isEmpty(userData) ? null : /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("h6", null, userData.username), /* @__PURE__ */ h("p", null, "win: ", userData.win, " lose: ", userData.lose, " rate:", userData.win + userData.lose === 0 ? 0 : (userData.win / (userData.win + userData.lose) * 100).toFixed(2), "%")))
  );
};
const getModalInput = (data2) => {
  const modalElement = document.getElementById("CreateRoomModal");
  const inputs = modalElement.querySelectorAll("input[type=text]");
  inputs[0];
  const radios = modalElement.querySelectorAll("input[type=radio]");
  if (radios[1].checked && inputs[1].value == "") {
    modalElement.querySelector(".modal-content").classList.add("active");
    modalElement.querySelector(".modal-content").classList.add("shake");
    modalElement.querySelector(".modal-content").addEventListener(
      "animationend",
      function() {
        this.classList.remove("shake");
        this.classList.remove("active");
      },
      { once: true }
    );
    modalElement.querySelector(".denied").classList.add("show");
    inputs[1].focus();
    return false;
  }
  let mode = 0;
  if (radios[2].checked)
    mode = 2;
  else
    mode = 4;
  const retRoomData = {
    type: "create_room",
    room_name: inputs[0].value === "" ? `${data2.username}'s Room` : inputs[0].value,
    mode,
    is_custom: radios[5].checked ? true : false,
    is_secret: radios[1].checked ? true : false,
    password: radios[1].checked ? inputs[1].value : ""
  };
  return retRoomData;
};
const LobbyButton = ({ data: data2, sendLobbySocket }) => {
  const createRoomModalReset = () => {
    const modalElement = document.getElementById("CreateRoomModal");
    if (!modalElement)
      return;
    const inputs = modalElement.querySelectorAll("input[type=text]");
    inputs.forEach((input) => input.value = "");
    const radios = modalElement.querySelectorAll("input[type=radio]");
    modalElement.querySelector(".denied").classList.remove("show");
    radios[0].checked = true;
    radios[2].checked = true;
    radios[4].checked = true;
    inputs[1].setAttribute("disabled", true);
    inputs[0].focus();
  };
  useEffect(() => {
    addEventArray(eventType.LOTTIE, {
      container: document.getElementById("lottie"),
      renderer: "svg",
      loop: true,
      autoplay: true,
      path: "/img/quick_match.json"
    });
    createRoomModalReset();
    const modalElement = document.getElementById("CreateRoomModal");
    modalElement.addEventListener("hidden.bs.modal", createRoomModalReset);
    modalElement.querySelectorAll("input[type=text]").forEach((input) => {
      input.addEventListener("keydown", (e) => {
        const isalpha = /^[a-zA-Z0-9]*$/i.test(e.key);
        const isnumpad = /^[0-9]*$/i.test(e.key);
        if (!isalpha && !isnumpad) {
          e.preventDefault();
        }
      });
    });
    const loaderElement = document.getElementById("QuickMatchModal");
    const handleLoaderHidden = () => {
      sendLobbySocket({ type: "cancel_matchmaking" });
    };
    loaderElement.addEventListener("hidden.bs.modal", handleLoaderHidden);
    const findModalElement = document.getElementById("FindUserModal");
    const handleFindModalHidden = () => {
      const input = findModalElement.querySelector("input");
      input.value = "";
      setFindResult("");
    };
    const handleFindModalShown = () => {
      const input = findModalElement.querySelector("input");
      input.focus();
    };
    const handleFindInput = async (e) => {
      const isalpha = /^[a-zA-Z0-9]*$/i.test(e.key);
      const isnumpad = /^[0-9]*$/i.test(e.key);
      if (e.key === "Enter") {
        const findName = findModalElement.querySelector(
          ".user-item .user-info h6"
        );
        if (findName !== null) {
          setTimeout(() => {
            const findModal = new bootstrap.Modal(findModalElement);
            if (findModal) {
              findModal.hide();
            }
            const modalBackdrop = document.querySelector(".modal-backdrop");
            if (modalBackdrop) {
              modalBackdrop.remove();
            }
          }, 10);
          moveToProfile(findName.innerText);
        }
      } else if (!isalpha && !isnumpad) {
        e.preventDefault();
      }
    };
    findModalElement.addEventListener("hidden.bs.modal", handleFindModalHidden);
    findModalElement.addEventListener("shown.bs.modal", handleFindModalShown);
    findModalElement.addEventListener("input", HandleFindInput);
    const findModalInput2 = findModalElement.querySelector("input");
    findModalInput2.addEventListener("keydown", handleFindInput);
    addEventArray(eventType.KEYDOWN, (e) => {
      let isModalOpen = false;
      document.querySelectorAll(".modal").forEach((modal) => {
        if (modal.classList.contains("show")) {
          isModalOpen = true;
        }
      });
      if (isModalOpen)
        return;
      const findModal = new bootstrap.Modal(findModalElement);
      const quickMatchModal = new bootstrap.Modal(loaderElement);
      const createModal = new bootstrap.Modal(modalElement);
      const logoutModal = new bootstrap.Modal(
        document.getElementById("LogoutModal")
      );
      if (e.key === "f") {
        if (!findModalElement.classList.contains("show")) {
          findModal.show();
        }
      } else if (e.key === "q") {
        if (!loaderElement.classList.contains("show")) {
          quickMatchModal.show();
        }
      } else if (e.key === "c") {
        if (!modalElement.classList.contains("show")) {
          createModal.show();
        }
      } else if (e.key === "l") {
        if (!document.getElementById("LogoutModal").classList.contains("show")) {
          logoutModal.show();
        }
      } else if (e.key === "h") {
        gotoPage("/user/me");
      }
    });
    addEventHandler();
    return () => {
      modalElement.removeEventListener("hidden.bs.modal", handleModalHidden);
      loaderElement.removeEventListener("hidden.bs.modal", handleLoaderHidden);
      findModalElement.removeEventListener(
        "hidden.bs.modal",
        handleFindModalHidden
      );
      findModalElement.removeEventListener(
        "shown.bs.modal",
        handleFindModalShown
      );
      findModalInput2.removeEventListener("keydown", handleFindInput);
    };
  }, []);
  const findModalInput = useRef("");
  const [findResult, setFindResult] = useState("");
  const [findStatus, setFindStatus] = useState(0);
  const HandleFindInput = async (e) => {
    const findModalElement = document.getElementById("FindUserModal");
    findModalInput.current = findModalElement.querySelector("input");
    const findName = findModalInput.current.value;
    let ret = null;
    if (findName === void 0) {
      return;
    } else if (findName === "") {
      setFindStatus(0);
    } else {
      setFindStatus(1);
      ret = await axiosUserOther(findName);
      if (ret.status == 200) {
        setFindResult(ret.data.user_info);
      } else {
        setFindResult(null);
      }
    }
  };
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(
    Modal,
    {
      id: "CreateRoomModal",
      title: () => TitleSection({ IconPath: "/icon/users.svg", Title: "Create Room" }),
      body: () => {
        return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(
          InputBox,
          {
            type: "text",
            text: "Group Name",
            defaultValue: `${data2.username}'s Room`
          }
        ), /* @__PURE__ */ h("div", { class: "radio-check body-element" }, /* @__PURE__ */ h(RadioCheck, { text: "Open Room", name: "lock", id: "open" }), /* @__PURE__ */ h(RadioCheck, { text: "Private", name: "lock", id: "private" })), /* @__PURE__ */ h(InputBox, { type: "text", text: "Password", defaultValue: "" }), /* @__PURE__ */ h("div", { class: "denied cl-red" }, "password required"), /* @__PURE__ */ h("div", { class: "radio-check body-element robby-game-btn" }, /* @__PURE__ */ h(RadioCheck, { text: "1 vs 1", name: "battle", id: "1vs1" }), /* @__PURE__ */ h(RadioCheck, { text: "Tournament", name: "battle", id: "tornament" })), /* @__PURE__ */ h("div", { class: "radio-check body-element robby-game-btn" }, /* @__PURE__ */ h(RadioCheck, { text: "Classic", name: "type", id: "classic" }), /* @__PURE__ */ h(RadioCheck, { text: "Custom", name: "type", id: "custom" })));
      },
      footer: () => /* @__PURE__ */ h(
        "button",
        {
          class: "small-btn",
          onclick: () => {
            const roomData = getModalInput(data2);
            if (!roomData) {
              return;
            }
            sendLobbySocket(roomData);
          }
        },
        "create"
      )
    }
  ), /* @__PURE__ */ h(
    Modal,
    {
      id: "FindUserModal",
      title: () => TitleSection({ IconPath: "/icon/Search.svg", Title: "Find User" }),
      body: () => {
        return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", { class: "user-search-bar" }, /* @__PURE__ */ h("input", { class: "user-search-input" }), /* @__PURE__ */ h("img", { src: "/icon/search.svg" })), findStatus == 0 ? /* @__PURE__ */ h("div", null) : /* @__PURE__ */ h("div", { class: "find-result" }, findResult ? /* @__PURE__ */ h(UserFind, { userData: findResult }) : /* @__PURE__ */ h("div", { class: "not-found-msg cl-red" }, "no user found")));
      }
    }
  ), /* @__PURE__ */ h("div", { class: "modal", id: "QuickMatchModal", tabindex: "-1" }, /* @__PURE__ */ h("div", { class: "modal-dialog" }, /* @__PURE__ */ h("div", { class: "modal-content" }, /* @__PURE__ */ h("div", { id: "lottie" })))));
};
let roomID = 0;
const LobbyRoom = ({ roomInfo, clickEvent }) => {
  return /* @__PURE__ */ h(
    "div",
    {
      class: `lobby-room ${roomInfo.status === "room" ? "" : "bg-gray50 outline-gray50"}`,
      onclick: () => clickEvent(roomInfo)
    },
    /* @__PURE__ */ h("div", { class: "first-row" }, /* @__PURE__ */ h("h6", null, roomInfo.room_name.slice(0, 20)), /* @__PURE__ */ h("div", null, roomInfo.is_secret ? /* @__PURE__ */ h("img", { src: "/icon/lock.svg" }) : /* @__PURE__ */ h("div", null), roomInfo.is_custom ? /* @__PURE__ */ h("img", { src: "/icon/spanner.svg" }) : /* @__PURE__ */ h("div", null))),
    /* @__PURE__ */ h("p", null, roomInfo.status === "game" || roomInfo.status === "playing" ? "Playing..." : `${roomInfo.players.length}/${roomInfo.mode}`)
  );
};
const LobbyRooms = ({ roomList, sendLobbySocket }) => {
  useEffect(() => {
    const pswdModalElement = document.getElementById("PswdRoomModal");
    const handlePswdModalHidden = () => {
      const input = pswdModalElement.querySelector("input");
      input.value = "";
      pswdModalElement.querySelector(".denied").classList.remove("show");
    };
    const handlePswdModalShown = () => {
      const input = pswdModalElement.querySelector("input");
      input.focus();
    };
    const handlePswdModalShow = () => {
      pswdModalElement.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          sendLobbySocket({
            type: "join_secret_room",
            room_id: roomID,
            password: document.querySelector("#PswdRoomModal input").value
          });
        }
      });
    };
    pswdModalElement.addEventListener("hidden.bs.modal", handlePswdModalHidden);
    pswdModalElement.addEventListener("shown.bs.modal", handlePswdModalShown);
    pswdModalElement.addEventListener("show.bs.modal", handlePswdModalShow);
    return () => {
      pswdModalElement.removeEventListener(
        "hidden.bs.modal",
        handlePswdModalHidden
      );
      pswdModalElement.removeEventListener(
        "shown.bs.modal",
        handlePswdModalShown
      );
      pswdModalElement.removeEventListener(
        "show.bs.modal",
        handlePswdModalShow
      );
    };
  }, []);
  const handleRoomClick = (roomInfo, sendLobbySocket2) => {
    document.getElementById(
      "PswdRoomModal"
    ).childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].innerText = roomInfo.room_name;
    roomID = roomInfo.room_id;
    sendLobbySocket2({
      type: "join_room",
      room_id: roomInfo.room_id
    });
  };
  return /* @__PURE__ */ h("div", { class: "lobby-rooms-main" }, /* @__PURE__ */ h(
    Modal,
    {
      id: "PswdRoomModal",
      title: () => TitleSection({ IconPath: "/icon/lock.svg", Title: "basic room" }),
      body: () => {
        return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(InputBox, { text: "Password", defaultValue: "" }), /* @__PURE__ */ h("div", { class: "denied cl-red" }, "password not correct"));
      },
      footer: () => /* @__PURE__ */ h(
        "button",
        {
          class: "small-btn",
          onclick: () => {
            sendLobbySocket({
              type: "join_secret_room",
              room_id: roomID,
              password: document.querySelector("#PswdRoomModal input").value
            });
          }
        },
        "Enter"
      )
    }
  ), /* @__PURE__ */ h("div", { class: "lobby-rooms-nav" }, /* @__PURE__ */ h("button", { class: "selected" }, /* @__PURE__ */ h("span", { class: "vertical-text selected" }, "Rooms"))), /* @__PURE__ */ h("div", { class: "lobby-rooms" }, roomList.map((room) => {
    if (room.mode === "matchmaking")
      return;
    return /* @__PURE__ */ h(
      LobbyRoom,
      {
        roomInfo: room,
        clickEvent: () => handleRoomClick(room, sendLobbySocket),
        sendLobbySocket
      }
    );
  })));
};
const TopNavBar = () => {
  return /* @__PURE__ */ h("div", { class: "top-nav-bar" }, /* @__PURE__ */ h(
    Modal,
    {
      id: "LogoutModal",
      title: () => TitleSection({ IconPath: "/icon/logout.svg", Title: "Logout" }),
      body: () => /* @__PURE__ */ h("h6", null, "Are you sure you want to logout?"),
      footer: () => BottomSection({
        ButtonName: "Logout",
        ClickEvent: () => {
          axiosLogout().then((res) => {
            if (res.status === 200) {
              ws_userlist.getState().socket.close();
              ws_gamelogic.getState().socket.close();
              gotoPage("/");
            }
          });
        }
      })
    }
  ), /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(
    "img",
    {
      onclick: () => gotoPage("/lobby"),
      class: "main-logo",
      src: "/img/main_logo.svg"
    }
  )), /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("img", { onclick: () => gotoPage("/profile/me"), src: "/icon/user.svg" }), /* @__PURE__ */ h(
    "img",
    {
      src: "/icon/logout.svg",
      "data-bs-toggle": "modal",
      "data-bs-target": "#LogoutModal"
    }
  )));
};
const SET_WIN_SIZE = "SET_WIN_SIZE";
const initState = {
  winSize: "large"
};
const set_windowSize = (winSize) => ({
  type: SET_WIN_SIZE,
  payload: winSize
});
const reducer_client = (state = initState, action = {}) => {
  switch (action.type) {
    case SET_WIN_SIZE:
      return { ...state, winSize: action.payload };
    default:
      return state;
  }
};
const windowSizeStore = createStore(reducer_client);
const setWindowSize = (dispatch, setWinSize) => {
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  const windowSize = {};
  if (windowWidth < 760) {
    windowSize.width = "small";
  } else if (windowWidth < 1280) {
    windowSize.width = "medium";
  } else {
    windowSize.width = "large";
  }
  if (windowHeight < 480) {
    windowSize.height = "small";
  } else if (windowHeight < 720) {
    windowSize.height = "medium";
  } else {
    windowSize.height = "large";
  }
  dispatch(set_windowSize(windowSize));
  setWinSize(windowSizeStore.getState().winSize);
};
const UserCard = ({ user_name }) => {
  const defaultImg = `/img/minji_${user_name[0].charCodeAt(0) % 5 + 1}.jpg`;
  const [myProfile, setMyProfile] = useState({});
  useEffect(() => {
    const fetchProfile = async () => {
      if (user_name === "-") {
        setMyProfile({});
      } else {
        const userOther = await axiosUserOther(user_name);
        setMyProfile(userOther.data.user_info);
      }
    };
    fetchProfile();
  }, [user_name]);
  return /* @__PURE__ */ h("div", { class: "user-card border-user-select" }, /* @__PURE__ */ h("img", { src: myProfile.profile_image ?? defaultImg }), windowSizeStore.getState().winSize.width === "large" ? /* @__PURE__ */ h("h3", null, user_name) : windowSizeStore.getState().winSize.width === "medium" ? /* @__PURE__ */ h("h4", null, user_name) : /* @__PURE__ */ h("h5", null, user_name));
};
const ItemInput = (props) => {
  return /* @__PURE__ */ h("div", { class: "item" }, /* @__PURE__ */ h("h6", null, props.ItemName), /* @__PURE__ */ h("input", { type: "text", placeholder: props.defaultValue }));
};
const ItemToggle = (props) => {
  return /* @__PURE__ */ h("div", { class: "item" }, /* @__PURE__ */ h("h6", null, props.ItemName), /* @__PURE__ */ h("div", { class: "toggle" }, /* @__PURE__ */ h("label", { class: "switch" }, props.isOn ? /* @__PURE__ */ h("input", { type: "checkbox", checked: true }) : /* @__PURE__ */ h("input", { type: "checkbox" }), /* @__PURE__ */ h("span", { class: "slider" }))));
};
let gameState$2;
let canvas$4;
let context$3;
let ratio$3;
const setGameState = (state) => {
  gameState$2 = state;
};
const setCanvas = (canvasElem, width2, height2) => {
  canvas$4 = canvasElem;
  canvas$4.width = width2;
  canvas$4.height = height2;
  context$3 = canvas$4.getContext("2d");
  context$3.scale(1, 1);
};
const setRatio = (value2) => {
  ratio$3 = value2;
};
const drawPaddle$2 = (x, y) => {
  context$3.fillStyle = "#ffffff";
  context$3.fillRect(x * ratio$3, y * ratio$3, 20 * ratio$3, canvas$4.height / 5);
};
const drawBall$3 = (x, y) => {
  context$3.fillStyle = "#ffffff";
  context$3.beginPath();
  context$3.arc(
    gameState$2.ball.x * ratio$3,
    gameState$2.ball.y * ratio$3,
    gameState$2.ball.radius * ratio$3,
    0,
    Math.PI * 2
  );
  context$3.fill();
  context$3.closePath();
};
const drawLine$3 = () => {
  context$3.beginPath();
  context$3.moveTo(canvas$4.width / 2, 0);
  context$3.lineTo(canvas$4.width / 2, canvas$4.height);
  context$3.strokeStyle = "#ffffff";
  context$3.lineWidth = 2;
  context$3.stroke();
  context$3.closePath();
};
const draw$3 = () => {
  context$3.clearRect(0, 0, canvas$4.width, canvas$4.height);
  context$3.fillStyle = "#181818";
  context$3.fillRect(0, 0, canvas$4.width, canvas$4.height);
  context$3.fillStyle = "#ffffff";
  drawPaddle$2(20, gameState$2.player_bar.left);
  drawPaddle$2(1160, gameState$2.player_bar.right);
  drawBall$3(gameState$2.ball.x, gameState$2.ball.y);
  drawLine$3();
};
let canvas$3;
let context$2;
var img1$2 = new Image();
var img2$2 = new Image();
var img3$2 = new Image();
var img4$2 = new Image();
img1$2.src = "/icon/ball_speed_up.svg";
img2$2.src = "/icon/ball_speed_down.svg";
img3$2.src = "/icon/expand_arrow.svg";
img4$2.src = "/icon/reduct_arrow.svg";
var imgs$2 = { speed_up: img1$2, speed_down: img2$2, bar_up: img3$2, bar_down: img4$2 };
const drawItems$2 = (items, p_context, ratio2 = 1) => {
  console.log(items);
  items.forEach((item) => {
    switch (item.type) {
      case "speed_up":
        p_context.fillStyle = "rgba(255, 0, 0, 0.75)";
        break;
      case "speed_down":
        p_context.fillStyle = "rgba(0, 0, 255, 0.75)";
        break;
      case "bar_up":
        p_context.fillStyle = "rgba(255, 0, 255, 0.75)";
        break;
      case "bar_down":
        p_context.fillStyle = "rgba(255, 165, 0, 0.75)";
        break;
      default:
        p_context.fillStyle = "white";
    }
    p_context.fillRect(
      item.x * ratio2 - 25 * ratio2,
      item.y * ratio2 - 25 * ratio2,
      50 * ratio2,
      50 * ratio2
    );
    p_context.drawImage(
      imgs$2[item.type],
      item.x * ratio2 - 25 * ratio2,
      item.y * ratio2 - 25 * ratio2,
      50 * ratio2,
      50 * ratio2
    );
  });
};
const drawTooltip = (ratio2) => {
  canvas$3 = document.getElementById("tool-tip");
  context$2 = canvas$3.getContext("2d");
  drawItems$2(
    [
      { type: "speed_up", x: 50, y: 50 },
      { type: "speed_down", x: 50, y: 150 },
      { type: "bar_up", x: 250, y: 50 },
      { type: "bar_down", x: 250, y: 150 }
    ],
    context$2,
    ratio2
  );
  context$2.fillStyle = "white";
  context$2.fillText("Speed Up", 100 * ratio2, ratio2 * 50);
  context$2.fillText("Speed down", 100 * ratio2, ratio2 * 150);
  context$2.fillText("bar Up", 300 * ratio2, ratio2 * 50);
  context$2.fillText("bar down", 300 * ratio2, ratio2 * 150);
};
const GameRoom = ({ gameData, isStart, isCustom, sendRoomSocket }) => {
  var _a;
  useEffect(() => {
    if (gameData.is_custom) {
      drawTooltip(0.7);
      addEventArray(eventType.KEYDOWN, (e) => {
        if (e.key === "t") {
          document.getElementById("tool-tip").style.display = "block";
        }
      });
      addEventArray(eventType.KEYUP, (e) => {
        if (e.key === "t") {
          document.getElementById("tool-tip").style.display = "none";
        }
      });
      addEventHandler();
    }
  }, [gameData.is_custom]);
  const handleStartBtn = () => {
    let find_items = [];
    if (gameData.is_custom) {
      document.querySelectorAll(".toggle-button").forEach((btn) => {
        const isChecked = btn.querySelector("input").checked;
        const toggleText = btn.querySelector(".toggle-text").textContent.replace(" ", "_");
        if (isChecked)
          find_items.push(toggleText);
      });
      sendRoomSocket({
        type: "start_game",
        goal_score: Number(document.querySelector("#Number").innerText),
        items: find_items
      });
    } else {
      sendRoomSocket({ type: "start_game" });
    }
  };
  const roomSetting = gameData.is_custom && gameData.user_list[0] === clientUserStore.getState().client.username ? /* @__PURE__ */ h("div", { class: "room-setting" }, /* @__PURE__ */ h(
    NumberStepper,
    {
      text: "set score",
      type: "input-goal",
      defaultValue: Number(3)
    }
  ), /* @__PURE__ */ h("div", { class: "item-buttons" }, /* @__PURE__ */ h(ToggleBtn, { text: "speed up" }), /* @__PURE__ */ h(ToggleBtn, { text: "speed down" }), /* @__PURE__ */ h(ToggleBtn, { text: "bar up" }), /* @__PURE__ */ h(ToggleBtn, { text: "bar down" }))) : /* @__PURE__ */ h("div", null);
  return /* @__PURE__ */ h("div", { class: "game-room-main" }, gameData.is_custom ? /* @__PURE__ */ h("canvas", { id: "tool-tip" }) : /* @__PURE__ */ h("div", null), /* @__PURE__ */ h("div", { class: "game-room-nav" }, /* @__PURE__ */ h("button", { class: "selected" }, /* @__PURE__ */ h("span", { class: "vertical-text selected" }, "Rooms"))), /* @__PURE__ */ h("div", { class: "game-room" }, /* @__PURE__ */ h("h3", null, (_a = gameData.room_name) == null ? void 0 : _a.slice(0, 30)), /* @__PURE__ */ h("h5", null, gameData.is_custom ? "Custom" : "General"), roomSetting, /* @__PURE__ */ h("div", { class: "user-cards" }, gameData.user_list && gameData.user_list.map((data2) => /* @__PURE__ */ h(UserCard, { user_name: data2 })), gameData.user_list && [...Array(gameData.mode - gameData.user_list.length)].map((i) => /* @__PURE__ */ h(UserCard, { user_name: "-" }))), /* @__PURE__ */ h("div", { class: "align-end" }, /* @__PURE__ */ h(
    "button",
    {
      class: "small-btn bg-gray40",
      onclick: () => gotoPage("/lobby")
    },
    "Go to Lobby"
  ), isStart ? /* @__PURE__ */ h("button", { class: "small-btn", onclick: handleStartBtn }, "Game Start!") : null)));
};
const MainProfileState = {
  LOBBY: 1,
  ROOM: 2
};
const RoomPage = () => {
  const [myProfile, setMyProfile] = useState({});
  const [gameData, setGameData] = useState([]);
  const [startBtn, setStartBtn] = useState(false);
  const [winSize, setWinSize] = useState(windowSizeStore.getState().winSize);
  useEffect(() => {
    const fetchProfile = async () => {
      const userMe = await axiosUserMe();
      setMyProfile(userMe.data);
    };
    const socketAsync = async () => {
      await connectGameLogicWebSocket(
        ws_gamelogic.dispatch,
        `/ws/room/${history.currentPath().split("/")[2]}/`
      );
      ws_gamelogic.getState().socket.onopen = function(e) {
      };
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "room_info" || data2.type === "connect_user") {
          setGameData(data2);
        } else if (data2.type === "disconnect_user") {
          setGameData(data2);
          if (data2.mode !== data2.user_list.length) {
            setStartBtn(false);
          }
        } else if (data2.type === "room_destroyed" || data2.type === "room_full" || data2.type === "room_not_exist") {
          gotoPage("/lobby");
        } else if (data2.type === "room_ready") {
          if (data2.you === data2.host) {
            setStartBtn(true);
          }
        } else if (data2.type === "goto_game") {
          if (data2.mode === 2) {
            if (data2.is_custom) {
              gotoPage(`/custom/${data2.room_id}`);
            } else {
              gotoPage(`/game/${data2.room_id}`);
            }
          } else if (data2.mode === 4)
            if (data2.is_custom) {
              gotoPage(`/customTournament/${data2.room_id}`);
            } else {
              gotoPage(`/tournament/${data2.room_id}`);
            }
        }
      };
    };
    fetchProfile();
    socketAsync();
  }, []);
  useEffect(() => {
    setWindowSize(windowSizeStore.dispatch, setWinSize);
    addEventArray(eventType.RESIZE, () => {
      setWindowSize(windowSizeStore.dispatch, setWinSize);
    });
    addEventHandler();
  }, []);
  const sendRoomSocket = (roomData) => {
    if (ws_gamelogic.getState().socket && ws_gamelogic.getState().socket.readyState === WebSocket.OPEN) {
      ws_gamelogic.getState().socket.send(JSON.stringify(roomData));
    }
  };
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", { id: "top" }, /* @__PURE__ */ h(TopNavBar, null)), /* @__PURE__ */ h("div", { id: "middle" }, /* @__PURE__ */ h("div", { class: "main-section flex-column" }, /* @__PURE__ */ h(LobbyProfile$1, { stat: MainProfileState.ROOM }), /* @__PURE__ */ h(
    GameRoom,
    {
      gameData,
      isStart: startBtn,
      sendRoomSocket
    }
  )), /* @__PURE__ */ h(UserList, null)));
};
const LobbyProfile$1 = ({ data: data2, sendLobbySocket, stat }) => {
  const [myProfile, setMyProfile] = useState({});
  useEffect(() => {
    const fetchProfile = async () => {
      const userMe = await axiosUserMe();
      if (!userMe.data) {
        return;
      }
      setUserData(clientUserStore.dispatch, userMe.data.user_info);
      setMyProfile(userMe.data.user_info);
    };
    fetchProfile();
  }, []);
  return /* @__PURE__ */ h("div", { class: "lobby-profile" }, /* @__PURE__ */ h("div", { class: "profile-space-btw" }, isEmpty(clientUserStore.getState().client) ? /* @__PURE__ */ h("div", null) : /* @__PURE__ */ h("div", { class: "profile-start" }, /* @__PURE__ */ h(
    "img",
    {
      src: clientUserStore.getState().client.profile_image ?? `/img/minji_${clientUserStore.getState().client.username[0].charCodeAt(0) % 5 + 1}.jpg`
    }
  ), /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("h3", null, clientUserStore.getState().client.username), /* @__PURE__ */ h("p", null, "Win: ", clientUserStore.getState().client.win), /* @__PURE__ */ h("p", null, "Lose: ", clientUserStore.getState().client.lose), /* @__PURE__ */ h("p", null, "Rate: ", calcGameRate(clientUserStore.getState().client), "%")), stat === MainProfileState.LOBBY ? /* @__PURE__ */ h(
    LobbyButton,
    {
      data: clientUserStore.getState().client,
      sendLobbySocket
    }
  ) : /* @__PURE__ */ h("div", null))), stat === MainProfileState.LOBBY ? /* @__PURE__ */ h("div", { class: "lobby-buttons" }, /* @__PURE__ */ h(
    "button",
    {
      class: "lobby-game-btn",
      onclick: () => {
        gotoPage(`/local/${myProfile.username}`);
      }
    },
    /* @__PURE__ */ h("img", { src: "/icon/user.svg" }),
    "Offline Game"
  ), /* @__PURE__ */ h(
    "button",
    {
      class: "lobby-game-btn",
      "data-bs-toggle": "modal",
      "data-bs-target": "#CreateRoomModal"
    },
    /* @__PURE__ */ h("img", { src: "/icon/users.svg" }),
    "Create Room"
  ), /* @__PURE__ */ h(
    "button",
    {
      class: "lobby-game-btn",
      "data-bs-toggle": "modal",
      "data-bs-target": "#FindUserModal"
    },
    /* @__PURE__ */ h("img", { src: "/icon/search.svg" }),
    "Find user"
  ), /* @__PURE__ */ h(
    "button",
    {
      class: "lobby-game-btn",
      onclick: () => {
        const quickMatchModal = new bootstrap.Modal(
          document.getElementById("QuickMatchModal")
        );
        quickMatchModal.show();
        sendLobbySocket({ type: "matchmaking" });
      }
    },
    /* @__PURE__ */ h("img", { src: "/icon/quick.svg" }),
    "Quick Match"
  )) : /* @__PURE__ */ h("div", null)));
};
const LobbyPage = () => {
  const [roomList, setRoomList] = useState([]);
  useEffect(() => {
    const socketAsync = async () => {
      await connectGameLogicWebSocket(ws_gamelogic.dispatch, "/ws/lobby/");
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "room_list") {
          setRoomList(data2.rooms);
        } else if (data2.type === "join_approved") {
          const pswdRoomModalElement = document.getElementById("PswdRoomModal");
          if (pswdRoomModalElement.classList.contains("show")) {
            pswdRoomModalElement.style.display = "none";
            setTimeout(() => {
              const modalBackdrop = document.querySelector(".modal-backdrop");
              if (modalBackdrop) {
                modalBackdrop.remove();
              }
            }, 10);
          }
          gotoPage(`/lobby/${data2.room_id}`);
        } else if (data2.type === "join_denied") {
          const pswdRoomModalElement = document.getElementById("PswdRoomModal");
          pswdRoomModalElement.querySelector(".modal-content").classList.add("active");
          pswdRoomModalElement.querySelector(".modal-content").classList.add("shake");
          pswdRoomModalElement.querySelector(".modal-content").addEventListener(
            "animationend",
            function() {
              this.classList.remove("shake");
              this.classList.remove("active");
            },
            { once: true }
          );
          pswdRoomModalElement.querySelector(".denied").classList.add("show");
        } else if (data2.type === "password_required") {
          let enterModal = new bootstrap.Modal(
            document.getElementById("PswdRoomModal")
          );
          enterModal.show();
        } else if (data2.type === "matchmaking_waiting")
          ;
        else if (data2.type === "goto_matchmaking_game") {
          const quickMatchModal = new bootstrap.Modal(
            document.getElementById("QuickMatchModal")
          );
          setTimeout(() => {
            if (quickMatchModal) {
              quickMatchModal.hide();
            }
            const modalBackdrop = document.querySelector(".modal-backdrop");
            if (modalBackdrop) {
              modalBackdrop.remove();
            }
          }, 10);
          gotoPage(`/game/${data2.room_id}`);
        } else if (data2.type === "room_created") {
          gotoPage(`/lobby/${data2.room_id}`);
        }
      };
    };
    socketAsync();
  }, []);
  const sendLobbySocket = (roomData) => {
    if (ws_gamelogic.getState().socket && ws_gamelogic.getState().socket.readyState === WebSocket.OPEN) {
      ws_gamelogic.getState().socket.send(JSON.stringify(roomData));
    }
  };
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", { id: "top" }, /* @__PURE__ */ h(TopNavBar, null)), /* @__PURE__ */ h("div", { id: "middle" }, /* @__PURE__ */ h("div", { class: "main-section flex-column" }, /* @__PURE__ */ h(
    LobbyProfile$1,
    {
      sendLobbySocket,
      stat: MainProfileState.LOBBY
    }
  ), /* @__PURE__ */ h(LobbyRooms, { roomList, sendLobbySocket })), /* @__PURE__ */ h(UserList, null)));
};
const WinMessage = () => /* @__PURE__ */ h("div", { class: "marquee-main" }, /* @__PURE__ */ h("div", { class: "marquee win winMessage" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, "You win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win!")), /* @__PURE__ */ h("div", { class: "marquee win winMessage transform-2" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, "You win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win!")), /* @__PURE__ */ h("div", { class: "marquee win winMessage transform-3" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, "You win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win!")), /* @__PURE__ */ h("div", { class: "marquee win winMessage transform-4" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, "You win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win! You Win!")));
const LoseMessage = () => /* @__PURE__ */ h("div", { class: "marquee-main" }, /* @__PURE__ */ h("div", { class: "marquee winMessage transform-1" }, /* @__PURE__ */ h("div", { class: "marquee-content" }, "You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose!")), /* @__PURE__ */ h("div", { class: "marquee winMessage transform-2" }, /* @__PURE__ */ h("div", { class: "marquee-content" }, "You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose!")), /* @__PURE__ */ h("div", { class: "marquee winMessage transform-3" }, /* @__PURE__ */ h("div", { class: "marquee-content" }, "You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose!")), /* @__PURE__ */ h("div", { class: "marquee winMessage transform-4" }, /* @__PURE__ */ h("div", { class: "marquee-content" }, "You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose! You Lose!")));
const resultMessage = (winner) => /* @__PURE__ */ h("div", { class: "marquee-main" }, /* @__PURE__ */ h("div", { class: "marquee winMessage win transform-1" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!")), /* @__PURE__ */ h("div", { class: "marquee winMessage win transform-2" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!")), /* @__PURE__ */ h("div", { class: "marquee winMessage win transform-3" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win!")), /* @__PURE__ */ h("div", { class: "marquee winMessage win transform-4" }, /* @__PURE__ */ h("div", { class: "marquee-content win" }, winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!", " ", winner, " Win! ", winner, " Win!", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win! ", winner, " Win!")));
const update$4 = () => {
  draw$3();
};
const dirStat$4 = {
  STOP: 0,
  UP: 1,
  DOWN: 2
};
const GamePage$2 = () => {
  const [gameStat, setGameStat] = useState([]);
  const [gameResult, setGameResult] = useState(null);
  let direction = dirStat$4.STOP;
  let startFlag = false;
  useEffect(() => {
    const socketAsync = async () => {
      connectGameLogicWebSocket(
        ws_gamelogic.dispatch,
        `/ws/game/${history.currentPath().split("/")[2]}/`
      );
      ws_gamelogic.getState().socket.onopen = (e) => {
        const waitOpponent = async () => {
          await new Promise((resolve2) => setTimeout(resolve2, 1e4));
          if (!startFlag) {
            ws_gamelogic.getState().socket.send(
              JSON.stringify({ type: "error", message: "timeout" })
            );
          }
        };
        waitOpponent();
      };
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "game_start") {
          startFlag = true;
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.game.roles]);
          let timer = 3;
          let interval = setInterval(() => {
            timer--;
            const counter = document.querySelector(".pong-game-info h1");
            if (counter) {
              counter.innerText = timer;
              if (timer <= 0) {
                counter.style.display = "none";
                clearInterval(interval);
                ws_gamelogic.getState().socket.send(JSON.stringify({ type: "start_game" }));
              }
            } else {
              timer++;
              clearInterval(interval);
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventArray(eventType.KEYDOWN, (e2) => {
            if (
              // direction === dirStat.STOP &&
              e2.key === "ArrowUp" || e2.key === "ArrowDown"
            ) {
              direction = e2.key === "ArrowUp" ? dirStat$4.UP : dirStat$4.DOWN;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "move_bar",
                  direction: direction === dirStat$4.UP ? "up" : "down",
                  role: data2.you
                })
              );
            }
          });
          addEventArray(eventType.KEYUP, (e2) => {
            if (direction !== dirStat$4.STOP && // (e.key === "ArrowUp" || e.key === "ArrowDown")
            (e2.key === "ArrowUp" && direction === dirStat$4.UP || e2.key === "ArrowDown" && direction === dirStat$4.DOWN)) {
              direction = dirStat$4.STOP;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "stop_bar",
                  role: data2.you
                })
              );
            }
          });
          addEventHandler();
        } else if (data2.type === "update_game") {
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.game.roles]);
        } else if (data2.type === "game_over") {
          if (clientUserStore.getState().client.username === data2.winner) {
            setGameResult(1);
          } else {
            setGameResult(2);
          }
          setTimeout(() => {
            gotoPage(`/lobby/${data2.room_id}`);
          }, 5e3);
        } else if (data2.type === "error") {
          alert(data2.message);
          gotoPage("/lobby");
        }
      };
    };
    socketAsync();
  }, []);
  useEffect(() => {
    if (isEmpty(gameStat))
      return;
    document.getElementById("pong-game").style.display = "block";
    if (window.innerHeight / 3 > window.innerWidth / 4) {
      setCanvas(
        document.getElementById("pong-game"),
        window.innerWidth - 10,
        window.innerWidth * 3 / 4 - 10
      );
    } else {
      setCanvas(
        document.getElementById("pong-game"),
        window.innerHeight * 4 / 3 - 10,
        window.innerHeight - 10
      );
    }
    document.querySelector(
      ".pong-game-info > p.user1"
    ).style.left = `calc(52% - ${canvas$4.width / 2}px)`;
    document.querySelector(
      ".pong-game-info > p.user2"
    ).style.right = `calc(52% - ${canvas$4.width / 2}px)`;
    setRatio(canvas$4.width / 1200);
    update$4();
  }, [gameStat]);
  return /* @__PURE__ */ h("div", { class: "game-display" }, /* @__PURE__ */ h("div", { class: "pong-game-main" }, /* @__PURE__ */ h("canvas", { id: "pong-game" }), isEmpty(gameStat) ? null : /* @__PURE__ */ h("div", { class: "pong-game-info" }, /* @__PURE__ */ h("p", { class: "user1" }, gameStat[1].left), /* @__PURE__ */ h("p", { class: "user2" }, gameStat[1].right), /* @__PURE__ */ h("h6", { class: "user1" }, gameStat[0].left), /* @__PURE__ */ h("h6", { class: "user2" }, gameStat[0].right), /* @__PURE__ */ h("h1", null, "3"))), gameResult == 1 ? /* @__PURE__ */ h(WinMessage, null) : gameResult == 2 ? /* @__PURE__ */ h(LoseMessage, null) : /* @__PURE__ */ h("div", null));
};
const isFull = (inputs) => {
  for (let i = 0; i < inputs.length; i++) {
    if (inputs[i].value === "") {
      return false;
    }
  }
  return true;
};
const OTP = ({ len }) => {
  const VerifyOTP = async (inputs) => {
    inputs.forEach((input) => {
      input.classList.toggle("bg-gray30");
    });
    let ret = await axiosVerfiyOTP(
      Array.from(inputs).map((input) => input.value).join("")
    );
    console.log(ret);
    if (ret.data.message === "  ") {
      MoveToLobby();
    } else {
      setTimeout(() => {
        window.location.href = "/2fa";
      }, 1500);
    }
  };
  const MoveToLobby = () => {
    window.location.href = "/lobby";
  };
  useEffect(() => {
    const inputs = document.querySelectorAll(".otp .input");
    let backspacePressed = false;
    const blurEvent = (e) => {
      if (e.target.value === "" && !backspacePressed || isFull(inputs)) {
        if (!isResendClicked) {
          e.preventDefault();
          e.target.focus();
        }
        isResendClicked = false;
      }
      backspacePressed = false;
    };
    inputs[0].focus();
    inputs.forEach((input, index2) => {
      input.addEventListener("input", async (e) => {
        const value2 = e.target.value;
        if (value2 != "") {
          if (value2.match(/[^0-9]/g)) {
            e.target.value = e.target.value.replace(/[^0-9]/g, "");
            return;
          } else if (index2 !== len - 1) {
            inputs[index2 + 1].focus();
          } else if (isFull(inputs)) {
            VerifyOTP(inputs);
          }
        }
      });
      input.addEventListener("keydown", (e) => {
        if (e.key === "Backspace") {
          backspacePressed = true;
          if (index2 > 0 && index2 !== len - 1) {
            inputs[index2 - 1].focus();
            inputs[index2 - 1].value = "";
          } else if (index2 === len - 1 && inputs[index2].value === "") {
            inputs[index2 - 1].focus();
            inputs[index2 - 1].value = "";
          } else if (index2 === len - 1 && inputs[index2].value !== "") {
            inputs[index2].value = "";
            backspacePressed = false;
          }
        } else if (["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"].includes(e.key) || e) {
          backspacePressed = false;
        } else {
          e.preventDefault();
          backspacePressed = false;
        }
      });
      input.addEventListener("blur", blurEvent);
      input.addEventListener("mousedown", (e) => {
        e.preventDefault();
      });
      input.addEventListener("paste", (e) => {
        let pastedData = e.clipboardData.getData("text");
        let pastedDatalen = pastedData.length;
        if (pastedData.match(/[^0-9]/g)) {
          e.preventDefault();
          return;
        }
        for (let i = 0; i < Math.min(pastedDatalen, 6); i++) {
          if (index2 + i >= 6) {
            break;
          }
          if (index2 + i !== 5) {
            inputs[index2 + i].removeEventListener("blur", blurEvent);
          }
          inputs[index2 + i].value = pastedData[i];
        }
        let foucusIndex = index2 + pastedDatalen;
        if (foucusIndex > 6) {
          foucusIndex = 6;
          VerifyOTP(inputs);
          return;
        }
        inputs[index2 + pastedDatalen - 1].addEventListener("blur", blurEvent);
        inputs[index2 + pastedDatalen - 1].focus();
      });
    });
  }, []);
  return /* @__PURE__ */ h("div", { class: "otp" }, [...Array(parseInt(len))].map((n) => /* @__PURE__ */ h("input", { class: "input", maxlength: "1" })));
};
const TwoFactorAuthPage = () => {
  useEffect(() => {
    const timer = document.querySelector(".timer");
    timer.addEventListener("load", resendBtn());
  });
  return /* @__PURE__ */ h("div", { class: "two-factor-auth-page", onDragStart: (e) => e.preventDefault() }, /* @__PURE__ */ h("h2", { class: "mention" }, "Please check your otp!"), /* @__PURE__ */ h(OTP, { len: 6 }), /* @__PURE__ */ h("div", { class: "bottom" }, /* @__PURE__ */ h("div", { class: "timer" })));
};
let isResendClicked = false;
const resendBtn = () => {
  if (document.querySelector(".small-btn")) {
    document.querySelector(".small-btn").remove();
  }
  clearInputs();
  setTimeout(() => {
    const bottom = document.getElementsByClassName("bottom")[0];
    const resendButton = document.createElement("button");
    resendButton.className = "small-btn";
    resendButton.innerText = "resend";
    resendButton.addEventListener("mousedown", (e) => {
      e.preventDefault();
    });
    resendButton.onclick = () => {
      isResendClicked = true;
      axios({
        method: "get",
        url: "https://10.31.5.2/api/auth/otp/",
        withCredentials: true
      });
      resendBtn();
    };
    bottom.appendChild(resendButton);
  }, 5e3);
};
const clearInputs = () => {
  const inputs = document.querySelectorAll(".otp input");
  inputs.forEach((input) => {
    input.value = "";
  });
  inputs[0].focus();
};
const dataURItoBlob = (dataURI) => {
  const binary = atob(dataURI.split(",")[1]);
  const array = [];
  for (let i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  }
  return new Blob([new Uint8Array(array)], { type: "image/jpeg" });
};
const cropImage = async (img, width2, height2) => {
  const cropSize = width2 > height2 ? height2 : width2;
  const canvas2 = document.createElement("canvas");
  canvas2.width = cropSize;
  canvas2.height = cropSize;
  const ctx2 = canvas2.getContext("2d");
  ctx2.drawImage(img, 0, 0, cropSize, cropSize, 0, 0, cropSize, cropSize);
  let file = dataURItoBlob(
    await new Promise((resolve2) => {
      resolve2(canvas2.toDataURL("image/jpeg"));
    })
  );
  const baseSize = 512e3;
  const compSize = 25600;
  if (file.size >= baseSize) {
    const ratio2 = Math.ceil(Math.sqrt(file.size / compSize, 2));
    canvas2.width /= ratio2;
    canvas2.height /= ratio2;
    const ctx22 = canvas2.getContext("2d");
    ctx22.drawImage(
      img,
      0,
      0,
      cropSize,
      cropSize,
      0,
      0,
      canvas2.width,
      canvas2.height
    );
    file = dataURItoBlob(
      await new Promise((resolve2) => {
        resolve2(canvas2.toDataURL("image/jpeg"));
      })
    );
  }
  const formData = new FormData();
  formData.append("file", file, "profile.jpg");
  return formData.get("file");
};
const ProfileImg = ({ stat, setStat, profile, setProfileImg }) => {
  const username = profile.username;
  const [profileImgSrc, setProfileImgSrc] = useState(profile.profile_image);
  const defaultImg = `/img/minji_${username[0].charCodeAt(0) % 5 + 1}.jpg`;
  useEffect(() => {
    const realUpload = document.querySelector(".real-upload");
    if (!realUpload)
      return;
    realUpload.addEventListener("change", (e) => {
      let file = e.currentTarget.files[0];
      if (!file) {
        return;
      }
      if (!file.type.match("image/*")) {
        alert("Only Image file can be uploaded.");
        return;
      }
      const img = document.createElement("img");
      img.src = URL.createObjectURL(file);
      img.onload = async () => {
        const { width: width2, height: height2 } = img;
        file = await cropImage(img, width2, height2);
        setProfileImg(file);
        setProfileImgSrc(URL.createObjectURL(file));
      };
    });
  }, []);
  const follow = async (username2) => {
    await axiosUserFollow(username2);
    ws_userlist.getState().socket.send(JSON.stringify({ type: "update" }));
    setStat(3);
  };
  const unfollow = async (username2) => {
    await axiosUserUnfollow(username2);
    ws_userlist.getState().socket.send(JSON.stringify({ type: "update" }));
    setStat(2);
  };
  const changeProfile = () => {
    const realUpload = document.querySelector(".real-upload");
    realUpload.click();
  };
  const deleteProfile = () => {
    setProfileImgSrc(null);
    setProfileImg(null);
  };
  return /* @__PURE__ */ h("div", { class: "profile-img" }, /* @__PURE__ */ h("img", { src: profileImgSrc ?? defaultImg }), stat === 0 ? /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(
    "button",
    {
      onclick: () => gotoPage("/profile/me/config"),
      class: "profile-img-btn"
    },
    /* @__PURE__ */ h("img", { src: "/icon/change.svg" }),
    "Change Profile"
  )) : stat === 1 ? /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(
    "input",
    {
      type: "file",
      class: "real-upload",
      accept: "image/*",
      required: true,
      style: "display: none"
    }
  ), /* @__PURE__ */ h("button", { class: "profile-change-btn", onclick: changeProfile }, /* @__PURE__ */ h("img", { src: "/icon/change.svg" }), "Change Profile Photo"), /* @__PURE__ */ h("button", { class: "profile-change-btn bg-red", onclick: deleteProfile }, /* @__PURE__ */ h("img", { src: "/icon/close.svg" }), "Delete Profile Photo")) : stat === 2 ? /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("button", { class: "follow-btn", onclick: () => follow(username) }, /* @__PURE__ */ h("img", { src: "/icon/user.svg" }), "Follow")) : /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("button", { class: "follow-btn", onclick: () => unfollow(username) }, /* @__PURE__ */ h("img", { src: "/icon/close.svg" }), "Unfollow")));
};
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h3) => Math.max(Math.min(v, h3), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex = [..."0123456789ABCDEF"];
const h1 = (b) => hex[b & 15];
const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
const eq = (b) => (b & 240) >> 4 === (b & 15);
const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h3, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h3 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h3, s, v) {
  const f = (n, k = (n + h3 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h3, w, b) {
  const rgb = hsl2rgbn(h3, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h3, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h3 = hueValue(r, g, b, d, max);
    h3 = h3 * 60 + 0.5;
  }
  return [h3 | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h3, s, l) {
  return calln(hsl2rgbn, h3, s, l);
}
function hwb2rgb(h3, w, b) {
  return calln(hwb2rgbn, h3, w, b);
}
function hsv2rgb(h3, s, v) {
  return calln(hsv2rgbn, h3, s, v);
}
function hue(h3) {
  return (h3 % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h3 = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h3, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h3, p1, p2);
  } else {
    v = hsl2rgb(h3, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h3 = rgb2hsl(v);
  h3[0] = hue(h3[0] + deg);
  h3 = hsl2rgb(h3);
  v.r = h3[0];
  v.g = h3[1];
  v.b = h3[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h3 = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h3}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h3}, ${s}%, ${l}%)`;
}
const map$2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$2[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate$1(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio2) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio2, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone$1(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone$1(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate$1(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio2) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio2;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val2 = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val2;
    return this;
  }
  opaquer(ratio2) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio2;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio2) {
    modHSL(this._rgb, 2, ratio2);
    return this;
  }
  darken(ratio2) {
    modHSL(this._rgb, 2, -ratio2);
    return this;
  }
  saturate(ratio2) {
    modHSL(this._rgb, 1, ratio2);
    return this;
  }
  desaturate(ratio2) {
    modHSL(this._rgb, 1, -ratio2);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
function noop() {
}
const uid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value2) {
  return value2 === null || typeof value2 === "undefined";
}
function isArray(value2) {
  if (Array.isArray && Array.isArray(value2)) {
    return true;
  }
  const type = Object.prototype.toString.call(value2);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value2) {
  return value2 !== null && Object.prototype.toString.call(value2) === "[object Object]";
}
function isNumberFinite(value2) {
  return (typeof value2 === "number" || value2 instanceof Number) && isFinite(+value2);
}
function finiteOrDefault(value2, defaultValue) {
  return isNumberFinite(value2) ? value2 : defaultValue;
}
function valueOrDefault(value2, defaultValue) {
  return typeof value2 === "undefined" ? defaultValue : value2;
}
const toPercentage = (value2, dimension) => typeof value2 === "string" && value2.endsWith("%") ? parseFloat(value2) / 100 : +value2 / dimension;
const toDimension = (value2, dimension) => typeof value2 === "string" && value2.endsWith("%") ? parseFloat(value2) / 100 * dimension : +value2;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key2) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key2) === -1;
}
function _merger(key2, target, source, options) {
  if (!isValidKey(key2)) {
    return;
  }
  const tval = target[key2];
  const sval = source[key2];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key2] = clone(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key2, target, source) {
  if (!isValidKey(key2)) {
    return;
  }
  const tval = target[key2];
  const sval = source[key2];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key2)) {
    target[key2] = clone(sval);
  }
}
const keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key2) {
  const parts = key2.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key2) {
  const keys = _splitKey(key2);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key2) {
  const resolver = keyResolvers[key2] || (keyResolvers[key2] = _getKeyResolver(key2));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value2) => typeof value2 !== "undefined";
const isFunction = (value2) => typeof value2 === "function";
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value2) {
  const result = [];
  const sqrt = Math.sqrt(value2);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value2 % i === 0) {
      result.push(i);
      result.push(value2 / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property2) {
  let i, ilen, value2;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value2 = array[i][property2];
    if (!isNaN(value2)) {
      target.min = Math.min(target.min, value2);
      target.max = Math.max(target.max, value2);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function _int16Range(value2) {
  return _limitValue(value2, -32768, 32767);
}
function _isBetween(value2, start, end, epsilon = 1e-6) {
  return value2 >= Math.min(start, end) - epsilon && value2 <= Math.max(start, end) + epsilon;
}
function _lookup(table, value2, cmp) {
  cmp = cmp || ((index2) => table[index2] < value2);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
const _lookupByKey = (table, key2, value2, last) => _lookup(table, value2, last ? (index2) => {
  const ti = table[index2][key2];
  return ti < value2 || ti === value2 && table[index2 + 1][key2] === value2;
} : (index2) => table[index2][key2] < value2);
const _rlookupByKey = (table, key2, value2) => _lookup(table, value2, (index2) => table[index2][key2] >= value2);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key2) => {
    const method = "_onData" + _capitalize(key2);
    const base = array[key2];
    Object.defineProperty(array, key2, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key2) => {
    delete array[key2];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
const requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      ), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value2) {
  if (value2 && typeof value2 === "object") {
    const type = value2.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value2) {
  return isPatternOrGradient(value2) ? value2 : new Color(value2);
}
function getHoverColor(value2) {
  return isPatternOrGradient(value2) ? value2 : new Color(value2).saturate(0.5).darken(0.1).hexString();
}
const numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
const colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
const formatters = {
  values(value2) {
    return isArray(value2) ? value2 : "" + value2;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash" && name2 !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
    _indexable: (name2) => name2 !== "backdropPadding"
  });
}
const overrides = /* @__PURE__ */ Object.create(null);
const descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key2) {
  if (!key2) {
    return node;
  }
  const keys = key2.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
class Defaults {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context2) => context2.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx2, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx2, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx2, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name2, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name2;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name2],
        writable: true
      },
      [name2]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value2) {
          this[privateName] = value2;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
}
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name2) => !name2.startsWith("on"),
  _indexable: (name2) => name2 !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx2, data2, gc, longest, string) {
  let textWidth = data2[string];
  if (!textWidth) {
    textWidth = data2[string] = ctx2.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx2, font, arrayOfThings, cache) {
  cache = cache || {};
  let data2 = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data2 = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx2.save();
  ctx2.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx2, data2, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx2, data2, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx2.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data2[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width2) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width2 !== 0 ? Math.max(width2 / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas2, ctx2) {
  if (!ctx2 && !canvas2) {
    return;
  }
  ctx2 = ctx2 || canvas2.getContext("2d");
  ctx2.save();
  ctx2.resetTransform();
  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
  ctx2.restore();
}
function drawPoint(ctx2, options, x, y) {
  drawPointLegend(ctx2, options, x, y, null);
}
function drawPointLegend(ctx2, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width2, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation2 = options.rotation;
  const radius = options.radius;
  let rad = (rotation2 || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx2.save();
      ctx2.translate(x, y);
      ctx2.rotate(rad);
      ctx2.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx2.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx2.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx2.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx2.arc(x, y, radius, 0, TAU);
      }
      ctx2.closePath();
      break;
    case "triangle":
      width2 = w ? w / 2 : radius;
      ctx2.moveTo(x + Math.sin(rad) * width2, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx2.lineTo(x + Math.sin(rad) * width2, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx2.lineTo(x + Math.sin(rad) * width2, y - Math.cos(rad) * radius);
      ctx2.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx2.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx2.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx2.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx2.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx2.closePath();
      break;
    case "rect":
      if (!rotation2) {
        size = Math.SQRT1_2 * radius;
        width2 = w ? w / 2 : size;
        ctx2.rect(x - width2, y - size, 2 * width2, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx2.moveTo(x - xOffsetW, y - yOffset);
      ctx2.lineTo(x + yOffsetW, y - xOffset);
      ctx2.lineTo(x + xOffsetW, y + yOffset);
      ctx2.lineTo(x - yOffsetW, y + xOffset);
      ctx2.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx2.moveTo(x - xOffsetW, y - yOffset);
      ctx2.lineTo(x + xOffsetW, y + yOffset);
      ctx2.moveTo(x + yOffsetW, y - xOffset);
      ctx2.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx2.moveTo(x - xOffsetW, y - yOffset);
      ctx2.lineTo(x + xOffsetW, y + yOffset);
      ctx2.moveTo(x + yOffsetW, y - xOffset);
      ctx2.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx2.moveTo(x - xOffsetW, y - yOffset);
      ctx2.lineTo(x + xOffsetW, y + yOffset);
      ctx2.moveTo(x + yOffsetW, y - xOffset);
      ctx2.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx2.moveTo(x - xOffset, y - yOffset);
      ctx2.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx2.moveTo(x, y);
      ctx2.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx2.closePath();
      break;
  }
  ctx2.fill();
  if (options.borderWidth > 0) {
    ctx2.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx2, area) {
  ctx2.save();
  ctx2.beginPath();
  ctx2.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx2.clip();
}
function unclipArea(ctx2) {
  ctx2.restore();
}
function _steppedLineTo(ctx2, previous, target, flip, mode) {
  if (!previous) {
    return ctx2.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx2.lineTo(midpoint, previous.y);
    ctx2.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx2.lineTo(previous.x, target.y);
  } else {
    ctx2.lineTo(target.x, previous.y);
  }
  ctx2.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx2, previous, target, flip) {
  if (!previous) {
    return ctx2.lineTo(target.x, target.y);
  }
  ctx2.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx2, opts) {
  if (opts.translation) {
    ctx2.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx2.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx2.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx2.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx2.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx2, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx2.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx2.strokeStyle = ctx2.fillStyle;
    ctx2.beginPath();
    ctx2.lineWidth = opts.decorationWidth || 2;
    ctx2.moveTo(left, yDecoration);
    ctx2.lineTo(right, yDecoration);
    ctx2.stroke();
  }
}
function drawBackdrop(ctx2, opts) {
  const oldColor = ctx2.fillStyle;
  ctx2.fillStyle = opts.color;
  ctx2.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx2.fillStyle = oldColor;
}
function renderText(ctx2, text2, x, y, font, opts = {}) {
  const lines = isArray(text2) ? text2 : [
    text2
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx2.save();
  ctx2.font = font.string;
  setRenderOpts(ctx2, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx2, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx2.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx2.lineWidth = opts.strokeWidth;
      }
      ctx2.strokeText(line, x, y, opts.maxWidth);
    }
    ctx2.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx2, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx2.restore();
}
function addRoundedRectPath(ctx2, rect) {
  const { x, y, w, h: h3, radius } = rect;
  ctx2.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx2.lineTo(x, y + h3 - radius.bottomLeft);
  ctx2.arc(x + radius.bottomLeft, y + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx2.lineTo(x + w - radius.bottomRight, y + h3);
  ctx2.arc(x + w - radius.bottomRight, y + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx2.lineTo(x + w, y + radius.topRight);
  ctx2.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx2.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value2, size) {
  const matches = ("" + value2).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value2 = +matches[2];
  switch (matches[3]) {
    case "px":
      return value2;
    case "%":
      value2 /= 100;
      break;
  }
  return size * value2;
}
const numberOrZero = (v) => +v || 0;
function _readValueToProps(value2, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value2) ? objProps ? (prop) => valueOrDefault(value2[prop], value2[props[prop]]) : (prop) => value2[prop] : () => value2;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value2) {
  return _readValueToProps(value2, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value2) {
  return _readValueToProps(value2, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value2) {
  const obj = toTRBL(value2);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context2, index2, info) {
  let i, ilen, value2;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value2 = inputs[i];
    if (value2 === void 0) {
      continue;
    }
    if (value2 !== void 0) {
      return value2;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value2, add2) => beginAtZero && value2 === 0 ? 0 : value2 + add2;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context2) {
  return Object.assign(Object.create(parentContext), context2);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value2) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value2;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context2, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context2,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx2) => _attachContext(proxy, ctx2, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context2, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value2) {
      proxy[prop] = value2;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
const needsSubResolver = (prop, value2) => isObject(value2) && prop !== "adapters" && (Object.getPrototypeOf(value2) === null || value2.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value2 = resolve2();
  target[prop] = value2;
  return value2;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value2 = _proxy[prop];
  if (isFunction(value2) && descriptors2.isScriptable(prop)) {
    value2 = _resolveScriptable(prop, value2, target, receiver);
  }
  if (isArray(value2) && value2.length) {
    value2 = _resolveArray(prop, value2, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value2)) {
    value2 = _attachContext(value2, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value2;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value2 = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value2)) {
    value2 = createSubResolver(_proxy._scopes, _proxy, prop, value2);
  }
  return value2;
}
function _resolveArray(prop, value2, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value2[_context.index % value2.length];
  } else if (isObject(value2[0])) {
    const arr = value2;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value2 = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value2.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value2;
}
function resolveFallback(fallback, prop, value2) {
  return isFunction(fallback) ? fallback(prop, value2) : fallback;
}
const getScope = (key2, parent2) => key2 === true ? parent2 : typeof key2 === "string" ? resolveObjectKey(parent2, key2) : void 0;
function addScopes(set2, parentScopes, key2, parentFallback, value2) {
  for (const parent2 of parentScopes) {
    const scope = getScope(key2, parent2);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key2, value2);
      if (typeof fallback !== "undefined" && fallback !== key2 && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key2 !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value2) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value2);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value2);
  let key2 = addScopesFromKey(set2, allScopes, prop, fallback || prop, value2);
  if (key2 === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key2 = addScopesFromKey(set2, allScopes, fallback, key2, value2);
    if (key2 === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value2));
}
function addScopesFromKey(set2, allScopes, key2, fallback, item) {
  while (key2) {
    key2 = addScopes(set2, allScopes, key2, fallback, item);
  }
  return key2;
}
function subGetTarget(resolver, prop, value2) {
  const parent2 = resolver._getTarget();
  if (!(prop in parent2)) {
    parent2[prop] = {};
  }
  const target = parent2[prop];
  if (isArray(target) && isObject(value2)) {
    return value2;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value2;
  for (const prefix of prefixes) {
    value2 = _resolve(readKey(prefix, prop), scopes);
    if (typeof value2 !== "undefined") {
      return needsSubResolver(prop, value2) ? createSubResolver(scopes, proxy, prop, value2) : value2;
    }
  }
}
function _resolve(key2, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value2 = scope[key2];
    if (typeof value2 !== "undefined") {
      return value2;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key2 of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key2);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data2, start, count) {
  const { iScale } = meta;
  const { key: key2 = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data2[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key2), index2)
    };
  }
  return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent2 = domNode.parentNode;
  if (parent2 && parent2.toString() === "[object ShadowRoot]") {
    parent2 = parent2.host;
  }
  return parent2;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property2) {
  return getComputedStyle(el).getPropertyValue(property2);
}
const positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas2) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas2.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas: canvas2, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas2);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas2);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width: width2, height: height2 } = chart;
  if (borderBox) {
    width2 -= paddings.width + borders.width;
    height2 -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width2 * canvas2.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height2 * canvas2.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas2, width2, height2) {
  let maxWidth, maxHeight;
  if (width2 === void 0 || height2 === void 0) {
    const container = canvas2 && _getParentNode(canvas2);
    if (!container) {
      width2 = canvas2.clientWidth;
      height2 = canvas2.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width2 = rect.width - containerPadding.width - containerBorder.width;
      height2 = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width: width2,
    height: height2,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas2, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas2);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas2, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas2, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas2, bbWidth, bbHeight);
  let { width: width2, height: height2 } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width2 -= paddings.width + borders.width;
    height2 -= paddings.height + borders.height;
  }
  width2 = Math.max(0, width2 - margins.width);
  height2 = Math.max(0, aspectRatio ? width2 / aspectRatio : height2 - margins.height);
  width2 = round1(Math.min(width2, maxWidth, containerSize.maxWidth));
  height2 = round1(Math.min(height2, maxHeight, containerSize.maxHeight));
  if (width2 && !height2) {
    height2 = round1(width2 / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height2 > containerSize.height) {
    height2 = containerSize.height;
    width2 = round1(Math.floor(height2 * aspectRatio));
  }
  return {
    width: width2,
    height: height2
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas2 = chart.canvas;
  if (canvas2.style && (forceStyle || !canvas2.style.height && !canvas2.style.width)) {
    canvas2.style.height = `${chart.height}px`;
    canvas2.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas2.height !== deviceHeight || canvas2.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas2.height = deviceHeight;
    canvas2.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property2) {
  const value2 = getStyle(element, property2);
  const matches = value2 && value2.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
const getRightToLeftAdapter = function(rectX, width2) {
  return {
    x(x) {
      return rectX + rectX + width2 - x;
    },
    setWidth(w) {
      width2 = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value2) {
      return x - value2;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value2) {
      return x + value2;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width2) {
  return rtl ? getRightToLeftAdapter(rectX, width2) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx2, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx2.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx2.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx2, original) {
  if (original !== void 0) {
    delete ctx2.prevTextDirection;
    ctx2.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property2) {
  if (property2 === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property: property2, start: startBound, end: endBound } = bounds;
  const { between, normalize: normalize2 } = propertyFn(property2);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize2(points[start % count][property2]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property: property2, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize: normalize2 } = propertyFn(property2);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value2, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value2) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value2) === 0 || between(endBound, prevValue, value2);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value2 = normalize2(point[property2]);
    if (value2 === prevValue) {
      continue;
    }
    inside = between(value2, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value2, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value2;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub2 = _boundSegment(segments[i], line.points, bounds);
    if (sub2.length) {
      result.push(...sub2);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key2, value2) {
    if (!isPatternOrGradient(value2)) {
      return value2;
    }
    if (!cache.includes(value2)) {
      cache.push(value2);
    }
    return cache.indexOf(value2);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
class Animator {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = /* @__PURE__ */ new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key2) => {
      const cfg = config[key2];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key2
      ]).forEach((prop) => {
        if (prop === key2 || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value2 = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value2, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value2;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value2);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale2, allowedOverflow) {
  const opts = scale2 && scale2.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value2) {
  let t, r, b, l;
  if (isObject(value2)) {
    t = value2.top;
    r = value2.right;
    b = value2.bottom;
    l = value2.left;
  } else {
    t = r = b = l = value2;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value2 === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value2, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value2 === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value2 === 0 || sign(value2) === sign(otherValue))) {
      value2 += otherValue;
    }
  }
  return value2;
}
function convertObjectDataToArray(data2, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data2);
  const adata = new Array(keys.length);
  let i, ilen, key2;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key2 = keys[i];
    adata[i] = {
      [iAxisKey]: key2,
      [vAxisKey]: data2[key2]
    };
  }
  return adata;
}
function isStacked(scale2, meta) {
  const stacked = scale2 && scale2.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale2) {
  const { min, max, minDefined, maxDefined } = scale2.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value2 = stack[meta.index];
    if (positive && value2 > 0 || !positive && value2 < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key2 = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value2 } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key2, index2);
    stack[datasetIndex] = value2;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value2;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key2) => scales2[key2].axis === axis).shift();
}
function createDatasetContext(parent2, index2) {
  return createContext(parent2, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent2, index2, element) {
  return createContext(parent2, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale2) {
    const meta = this._cachedMeta;
    return scale2 === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data2 = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data2)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data2, meta);
    } else if (_data !== data2) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data2 && Object.isExtensible(data2)) {
        listenArrayEvents(data2, this);
      }
      this._syncList = [];
      this._data = data2;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data2 } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data2.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data2;
      meta._sorted = true;
      parsed = data2;
    } else {
      if (isArray(data2[start])) {
        parsed = this.parseArrayData(meta, data2, start, count);
      } else if (isObject(data2[start])) {
        parsed = this.parseObjectData(meta, data2, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data2, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data2, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data2[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data2, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data2[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data2, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data2[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale2, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value2 = parsed[scale2.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale2.axis]._visualValues
    };
    return applyStack(stack, value2, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale2, parsed, stack) {
    const parsedValue = parsed[scale2.axis];
    let value2 = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale2.axis];
    if (stack && values) {
      stack.values = values;
      value2 = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value2);
    range.max = Math.max(range.max, value2);
  }
  getMinMax(scale2, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale2 === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale2);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale2.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale2, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale2, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale2) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value2;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value2 = parsed[i][scale2.axis];
      if (isNumberFinite(value2)) {
        values.push(value2);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx2 = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active2 = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx2, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active2.push(element);
      } else {
        element.draw(ctx2, area);
      }
    }
    for (i = 0; i < active2.length; ++i) {
      active2[i].draw(ctx2, area);
    }
  }
  getStyle(index2, active2) {
    const mode = active2 ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active2, mode) {
    const dataset = this.getDataset();
    let context2;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context2 = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context2.parsed = this.getParsed(index2);
      context2.raw = dataset.data[index2];
      context2.index = context2.dataIndex = index2;
    } else {
      context2 = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context2.dataset = dataset;
      context2.index = context2.datasetIndex = this.index;
    }
    context2.active = !!active2;
    context2.mode = mode;
    return context2;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active2 = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active2 ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context2 = () => this.getContext(index2, active2, mode);
    const values = config.resolveNamedOptions(scopes, names2, context2, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active2) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active2, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active2) {
    element.active = active2;
    const options = this.getStyle(index2, active2);
    this._resolveAnimations(index2, mode, active2).update(element, {
      options: !active2 && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data2 = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data2.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data2 = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data2);
    for (i = start; i < end; ++i) {
      data2[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data2, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale2, type) {
  if (!scale2._cache.$bar) {
    const visibleMetas = scale2.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale2));
    }
    scale2._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale2._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale2 = meta.iScale;
  const values = getAllScaleValues(scale2, meta.type);
  let min = scale2._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale2.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale2.ticks.length; i < ilen; ++i) {
    curr = scale2.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio2;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio2 = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio2 = 1;
  }
  return {
    chunk: size / stackCount,
    ratio: ratio2,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data2, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data2[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio2) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio2 === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data2, start, count) {
    return parseArrayOrPrimitive(meta, data2, start, count);
  }
  parseArrayData(meta, data2, start, count) {
    return parseArrayOrPrimitive(meta, data2, start, count);
  }
  parseObjectData(meta, data2, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data2[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale2, parsed, stack) {
    super.updateRangeFromParsed(range, scale2, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale2 === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value2 = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value: value2
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val2 = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val2) || isNaN(val2)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name2, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value2 = parsed[vScale.axis];
    let start = 0;
    let length2 = _stacked ? this.applyStack(vScale, parsed, _stacked) : value2;
    let head, size;
    if (length2 !== value2) {
      start = length2 - value2;
      length2 = value2;
    }
    if (floating) {
      value2 = custom.barStart;
      length2 = custom.barEnd - custom.barStart;
      if (value2 !== 0 && sign(value2) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value2;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length2);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value2 === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale2 = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale2.getPixelForValue(this.getParsed(index2)[scale2.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data2, start, count) {
    const parsed = super.parsePrimitiveData(meta, data2, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data2, start, count) {
    const parsed = super.parseArrayData(meta, data2, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data2[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data2, start, count) {
    const parsed = super.parseObjectData(meta, data2, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data2[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data2 = this._cachedMeta.data;
    let max = 0;
    for (let i = data2.length - 1; i >= 0; --i) {
      max = Math.max(max, data2[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation2, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation2;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data2 = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data2;
    } else {
      let getter = (i2) => +data2[i2];
      if (isObject(data2[start])) {
        const { key: key2 = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data2[i2], key2);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation2 = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation2);
        max = Math.max(max, rotation2 + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation: rotation2 } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation2, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value2 = meta._parsed[i];
      if (value2 !== null && !isNaN(value2) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value2);
      }
    }
    return total;
  }
  calculateCircumference(value2) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value2)) {
      return TAU * (Math.abs(value2) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value2 = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value: value2
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name2) => name2 !== "spacing",
  _indexable: (name2) => name2 !== "spacing" && !name2.startsWith("borderDash") && !name2.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data2 = chart.data;
          if (data2.labels.length && data2.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data2.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data2 = meta.data || [];
    if (!data2.length) {
      return border;
    }
    const firstPoint = data2[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data2[data2.length - 1].size(this.resolveDataElementOptions(data2.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value2 = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value: value2
    };
  }
  parseObjectData(meta, data2, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data2, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale2 = this._cachedMeta.rScale;
    const centerX = scale2.xCenter;
    const centerY = scale2.yCenter;
    const datasetStartAngle = scale2.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale2.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
}
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data2 = chart.data;
          if (data2.labels.length && data2.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data2.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
class PieController extends DoughnutController {
}
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class RadarController extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data2, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data2, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale2 = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale2.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale2.xCenter : pointPosition.x;
      const y = reset ? scale2.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class ScatterController extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data2 = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data2.length - 1; i >= 0; --i) {
        max = Math.max(max, data2[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data2.length) {
      return border;
    }
    const firstPoint = data2[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data2[data2.length - 1].size(this.resolveDataElementOptions(data2.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
}
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
}
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value2, intersect) {
  const { controller, data: data2, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data2.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data2, axis, value2);
    } else if (controller._sharedOptions) {
      const el = data2[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data2, axis, value2 - range);
        const end = lookupMethod(data2, axis, value2 + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data2.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position2, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value2 = position2[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data: data2 } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value2, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data2[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position2)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position2.x, position2.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position2, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position2, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position2.x,
      y: position2.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position2, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position2, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position2.x, position2.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position2, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position2, evaluationFunc);
  return items;
}
function getNearestItems(chart, position2, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position2)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position2, axis, useFinalPosition) : getNearestCartesianItems(chart, position2, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position2, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position2, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position2[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position2.x, position2.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position2 = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position2, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position2 = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position2, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data2 = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data2.length; ++i) {
          items.push({
            element: data2[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position2 = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position2 = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position2, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position2 = getRelativePosition(e, chart);
      return getAxisItems(chart, position2, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position2 = getRelativePosition(e, chart);
      return getAxisItems(chart, position2, "y", options.intersect, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position2) {
  return array.filter((v) => v.pos === position2);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width2, height2) {
  box.top = top;
  box.left = left;
  box.right = left + width2;
  box.bottom = top + height2;
  box.width = width2;
  box.height = height2;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width2 = chartArea.w * weight;
      const height2 = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height2);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width2, height2);
      }
      stack.start = y;
      stack.placed += width2;
      y = box.bottom;
    } else {
      const height2 = chartArea.h * weight;
      const width2 = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width2, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width2, height2);
      }
      stack.start = x;
      stack.placed += height2;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width2, height2, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width2 - padding.width, 0);
    const availableHeight = Math.max(height2 - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width2,
      outerHeight: height2,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class BasePlatform {
  acquireContext(canvas2, aspectRatio) {
  }
  releaseContext(context2) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width2, height2, aspectRatio) {
    width2 = Math.max(0, width2 || element.width);
    height2 = height2 || element.height;
    return {
      width: width2,
      height: Math.max(0, aspectRatio ? Math.floor(width2 / aspectRatio) : height2)
    };
  }
  isAttached(canvas2) {
    return true;
  }
  updateConfig(config) {
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
const isNullOrEmpty = (value2) => value2 === null || value2 === "";
function initCanvas(canvas2, aspectRatio) {
  const style = canvas2.style;
  const renderHeight = canvas2.getAttribute("height");
  const renderWidth = canvas2.getAttribute("width");
  canvas2[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas2, "width");
    if (displayWidth !== void 0) {
      canvas2.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas2.style.height === "") {
      canvas2.height = canvas2.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas2, "height");
      if (displayHeight !== void 0) {
        canvas2.height = displayHeight;
      }
    }
  }
  return canvas2;
}
const eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas2) {
  for (const node of nodeList) {
    if (node === canvas2 || node.contains(canvas2)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas2 = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas2);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas2);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas2 = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas2);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas2);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
const drpListeningCharts = /* @__PURE__ */ new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas2 = chart.canvas;
  const container = canvas2 && _getParentNode(canvas2);
  if (!container) {
    return;
  }
  const resize = throttled((width2, height2) => {
    const w = container.clientWidth;
    listener(width2, height2);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width2 = entry.contentRect.width;
    const height2 = entry.contentRect.height;
    if (width2 === 0 && height2 === 0) {
      return;
    }
    resize(width2, height2);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas2 = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas2, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas2, aspectRatio) {
    const context2 = canvas2 && canvas2.getContext && canvas2.getContext("2d");
    if (context2 && context2.canvas === canvas2) {
      initCanvas(canvas2, aspectRatio);
      return context2;
    }
    return null;
  }
  releaseContext(context2) {
    const canvas2 = context2.canvas;
    if (!canvas2[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas2[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value2 = initial[prop];
      if (isNullOrUndef(value2)) {
        canvas2.removeAttribute(prop);
      } else {
        canvas2.setAttribute(prop, value2);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key2) => {
      canvas2.style[key2] = style[key2];
    });
    canvas2.width = canvas2.width;
    delete canvas2[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas2, width2, height2, aspectRatio) {
    return getMaximumSize(canvas2, width2, height2, aspectRatio);
  }
  isAttached(canvas2) {
    const container = canvas2 && _getParentNode(canvas2);
    return !!(container && container.isConnected);
  }
}
function _detectPlatform(canvas2) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas2 instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
class Element {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale2, ticks) {
  const tickOpts = scale2.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale2);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale2) {
  const offset = scale2.options.offset;
  const tickLength = scale2._tickSize();
  const maxScale = scale2._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale2._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length2, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length2 = majorEnd - majorStart;
    spacing = length2 / Math.floor(length2 / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale2, edge, offset) => edge === "top" || edge === "left" ? scale2[edge] + offset : scale2[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale2, index2, offsetGridLines) {
  const length2 = scale2.ticks.length;
  const validIndex2 = Math.min(index2, length2 - 1);
  const start = scale2._startPixel;
  const end = scale2._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale2.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length2 === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale2.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale2.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length2) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length2) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent2, scale2) {
  return createContext(parent2, {
    scale: scale2,
    type: "scale"
  });
}
function createTickContext(parent2, index2, tick) {
  return createContext(parent2, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position2, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position2 !== "right" || !reverse && position2 === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale2, offset, position2, align) {
  const { top, left, bottom, right, chart } = scale2;
  const { chartArea, scales: scales2 } = chart;
  let rotation2 = 0;
  let maxWidth, titleX, titleY;
  const height2 = bottom - top;
  const width2 = right - left;
  if (scale2.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position2)) {
      const positionAxisID = Object.keys(position2)[0];
      const value2 = position2[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value2) + height2 - offset;
    } else if (position2 === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height2 - offset;
    } else {
      titleY = offsetFromEdge(scale2, position2, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position2)) {
      const positionAxisID = Object.keys(position2)[0];
      const value2 = position2[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value2) - width2 + offset;
    } else if (position2 === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width2 + offset;
    } else {
      titleX = offsetFromEdge(scale2, position2, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation2 = position2 === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation: rotation2
  };
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data2 = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data2.xLabels : data2.yLabels) || data2.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name2) {
    this.chart.notifyPlugins(name2, this.getContext());
    callback(this.options[name2], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position: position2 } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position2 !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position: position2 } = this.options;
    return position2 === "top" || position2 === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length2, maxTicksLimit) {
    const { ctx: ctx2, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length2 / getTicksLimit(length2, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width2, height2, nestedLabel;
    for (i = 0; i < length2; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx2.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width2 = height2 = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width2 = _measureText(ctx2, cache.data, cache.gc, width2, label);
        height2 = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width2 = _measureText(ctx2, cache.data, cache.gc, width2, nestedLabel);
            height2 += lineHeight;
          }
        }
      }
      widths.push(width2);
      heights.push(height2);
      widestLabelSize = Math.max(width2, widestLabelSize);
      highestLabelSize = Math.max(height2, highestLabelSize);
    }
    garbageCollect(caches, length2);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length2 - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value2) {
    return value2;
  }
  getPixelForValue(value2, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h3 * cos > w * sin ? w / cos : h3 / sin : h3 * sin < w * cos ? h3 / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position: position2, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position2 === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position2 === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position2 === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position2 === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position2 === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position2)) {
        const positionAxisID = Object.keys(position2)[0];
        const value2 = position2[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value2));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position2 === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position2)) {
        const positionAxisID = Object.keys(position2)[0];
        const value2 = position2[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value2));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step2 = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step2) {
      const context2 = this.getContext(i);
      const optsAtIndex = grid.setContext(context2);
      const optsAtIndexBorder = border.setContext(context2);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position: position2, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation2 = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position2 === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position2 === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position2 === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position2 === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position2 === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position2)) {
        const positionAxisID = Object.keys(position2)[0];
        const value2 = position2[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value2) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position2 === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position2)) {
        const positionAxisID = Object.keys(position2)[0];
        const value2 = position2[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value2);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position2 === "top") {
          if (crossAlign === "near" || rotation2 !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation2 !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation2 !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation2);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height2 = labelSizes.heights[i];
        const width2 = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height2 / 2;
            break;
          case "bottom":
            top -= height2;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width2 / 2;
            break;
          case "right":
            left -= width2;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width2;
            } else if (i > 0) {
              left -= width2 / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width2 + labelPadding.width,
          height: height2 + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation: rotation2,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position: position2, ticks } = this.options;
    const rotation2 = -toRadians(this.labelRotation);
    if (rotation2) {
      return position2 === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position: position2, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position2 === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position2 === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position2 = this.options.position;
    if (position2 === "left" || position2 === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position2 === "top" || position2 === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx: ctx2, options: { backgroundColor }, left, top, width: width2, height: height2 } = this;
    if (backgroundColor) {
      ctx2.save();
      ctx2.fillStyle = backgroundColor;
      ctx2.fillRect(left, top, width2, height2);
      ctx2.restore();
    }
  }
  getLineWidthForValue(value2) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value2);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx2 = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine2 = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx2.save();
      ctx2.lineWidth = style.width;
      ctx2.strokeStyle = style.color;
      ctx2.setLineDash(style.borderDash || []);
      ctx2.lineDashOffset = style.borderDashOffset;
      ctx2.beginPath();
      ctx2.moveTo(p1.x, p1.y);
      ctx2.lineTo(p2.x, p2.y);
      ctx2.stroke();
      ctx2.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine2({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine2({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx: ctx2, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx2.save();
    ctx2.lineWidth = borderOpts.width;
    ctx2.strokeStyle = borderOpts.color;
    ctx2.beginPath();
    ctx2.moveTo(x1, y1);
    ctx2.lineTo(x2, y2);
    ctx2.stroke();
    ctx2.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx2 = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx2, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx2, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx2);
    }
  }
  drawTitle() {
    const { ctx: ctx2, options: { position: position2, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position2 === "bottom" || position2 === "center" || isObject(position2)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation: rotation2 } = titleArgs(this, offset, position2, align);
    renderText(ctx2, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation: rotation2,
      textAlign: titleAlign(align, position2, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes2) {
  Object.keys(routes2).forEach((property2) => {
    const propertyParts = property2.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes2[property2].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
}
var registry = /* @__PURE__ */ new Registry();
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter2) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter2 ? this._descriptors(chart).filter(filter2) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all2) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all2 ? [] : createDescriptors(chart, plugins2, options, all2);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
}
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all2) {
  if (!all2 && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all2) {
  const result = [];
  const context2 = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all2);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context2)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context2) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context2, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position2) {
  if (position2 === "top" || position2 === "bottom") {
    return "x";
  }
  if (position2 === "left" || position2 === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key2) => {
    const scale2 = scales2[key2];
    mergeIf(scale2, [
      defaults.scales[scale2.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data2) {
  data2 = data2 || {};
  data2.datasets = data2.datasets || [];
  data2.labels = data2.labels || [];
  return data2;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = /* @__PURE__ */ new Map();
const keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set2, obj, key2) => {
  const opts = resolveObjectKey(obj, key2);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data2) {
    this._config.data = initData(data2);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key2) => addIfFound(scopes, mainScope, key2));
      }
      keys.forEach((key2) => addIfFound(scopes, options, key2));
      keys.forEach((key2) => addIfFound(scopes, overrides[type] || {}, key2));
      keys.forEach((key2) => addIfFound(scopes, defaults, key2));
      keys.forEach((key2) => addIfFound(scopes, descriptors, key2));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context2, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context2 = isFunction(context2) ? context2() : context2;
      const subResolver = this.createResolver(scopes, context2, subPrefixes);
      options = _attachContext(resolver, context2, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context2, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context2) ? _attachContext(resolver, context2, void 0, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = (value2) => isObject(value2) && Object.getOwnPropertyNames(value2).some((key2) => isFunction(value2[key2]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value2 = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value2) || hasFunction(value2)) || indexable && isArray(value2)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.3";
const KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position2, axis) {
  return position2 === "top" || position2 === "bottom" || KNOWN_POSITIONS.indexOf(position2) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context2) {
  const chart = context2.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context2
  ], chart);
}
function onAnimationProgress(context2) {
  const chart = context2.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context2
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key2) => {
  const canvas2 = getCanvas(key2);
  return Object.values(instances).filter((c) => c.canvas === canvas2).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key2 of keys) {
    const intKey = +key2;
    if (intKey >= start) {
      const value2 = obj[key2];
      delete obj[key2];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value2;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale2, chartArea, field) {
  return scale2.options.clip ? scale2[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
class Chart {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context2 = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas2 = context2 && context2.canvas;
    const height2 = canvas2 && canvas2.height;
    const width2 = canvas2 && canvas2.width;
    this.id = uid();
    this.ctx = context2;
    this.canvas = canvas2;
    this.width = width2;
    this.height = height2;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context2 || !canvas2) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width: width2, height: height2, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height2 ? width2 / height2 : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data2) {
    this.config.data = data2;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width2, height2) {
    if (!animator.running(this)) {
      this._resize(width2, height2);
    } else {
      this._resizeBeforeDraw = {
        width: width2,
        height: height2
      };
    }
  }
  _resize(width2, height2) {
    const options = this.options;
    const canvas2 = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas2, width2, height2, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale2 = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale2 = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale2 = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale2.id] = scale2;
      }
      scale2.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale2) => {
      layouts.configure(this, scale2, scale2.options);
      layouts.addBox(this, scale2);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale2) => {
      layouts.removeBox(this, scale2);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width: width2, height: height2 } = this._resizeBeforeDraw;
      this._resize(width2, height2);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx2 = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx2, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx2);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx2) => ctx2.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: canvas2, ctx: ctx2 } = this;
    this._stop();
    this.config.clearCache();
    if (canvas2) {
      this.unbindEvents();
      clearCanvas(canvas2, ctx2);
      this.platform.releaseContext(ctx2);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform2 = this.platform;
    const _add = (type, listener2) => {
      platform2.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform2 = this.platform;
    const _add = (type, listener2) => {
      platform2.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform2.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width2, height2) => {
      if (this.canvas) {
        this.resize(width2, height2);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform2.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active2 = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active2, lastActive);
    if (changed) {
      this._active = active2;
      this._lastEvent = null;
      this._updateHoverStyles(active2, lastActive);
    }
  }
  notifyPlugins(hook, args, filter2) {
    return this._plugins.notify(this, hook, args, filter2);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active2, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active2);
    const activated = replay ? active2 : diff(active2, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active2 = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active2,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active2,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active2, lastActive);
    if (changed || replay) {
      this._active = active2;
      this._updateHoverStyles(active2, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx2, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx2.beginPath();
  ctx2.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx2.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx2.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx2.closePath();
  ctx2.clip();
}
function toRadiusCorners(value2) {
  return _readValueToProps(value2, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val2) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val2)) * angleDelta / 2;
    return _limitValue(val2, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx2, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx2.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx2.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx2.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx2.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx2.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx2.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx2.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx2.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx2.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx2.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx2.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx2.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx2.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx2.lineTo(outerEndX, outerEndY);
  }
  ctx2.closePath();
}
function drawArc(ctx2, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx2, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx2.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx2, element, offset, spacing, endAngle, circular);
  ctx2.fill();
  return endAngle;
}
function drawBorder$1(ctx2, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx2.setLineDash(borderDash || []);
  ctx2.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx2.lineWidth = borderWidth * 2;
    ctx2.lineJoin = borderJoinStyle || "round";
  } else {
    ctx2.lineWidth = borderWidth;
    ctx2.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx2, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx2.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx2, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx2, element, offset, spacing, endAngle, circular);
    ctx2.stroke();
  }
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx2) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx2.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx2.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx2.fillStyle = options.backgroundColor;
    ctx2.strokeStyle = options.borderColor;
    drawArc(ctx2, this, radiusOffset, spacing, circular);
    drawBorder$1(ctx2, this, radiusOffset, spacing, circular);
    ctx2.restore();
  }
}
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name2) => name2 !== "borderDash"
});
function setStyle(ctx2, options, style = options) {
  ctx2.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx2.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx2.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx2.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx2.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx2.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx2, previous, target) {
  ctx2.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx2, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx2.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx2, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx2, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx2, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx2.lineTo(avgX, maxY);
      ctx2.lineTo(avgX, minY);
      ctx2.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx2.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx2.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx2, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx2, line.options);
  ctx2.stroke(path);
}
function strokePathDirect(ctx2, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx2, options, segment.style);
    ctx2.beginPath();
    if (segmentMethod(ctx2, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx2.closePath();
    }
    ctx2.stroke();
  }
}
const usePath2D = typeof Path2D === "function";
function draw$2(ctx2, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx2, line, start, count);
  } else {
    strokePathDirect(ctx2, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property2) {
    const options = this.options;
    const value2 = point[property2];
    const points = this.points;
    const segments = _boundSegments(this, {
      property: property2,
      start: value2,
      end: value2
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value2 - p1[property2]) / (p2[property2] - p1[property2]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property2] = point[property2];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx2, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx2, this, segment, params);
  }
  path(ctx2, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx2, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx2, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx2.save();
      draw$2(ctx2, this, start, count);
      ctx2.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
}
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value2 } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value2) < options.radius + options.hitRadius;
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx2, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx2.strokeStyle = options.borderColor;
    ctx2.lineWidth = options.borderWidth;
    ctx2.fillStyle = options.backgroundColor;
    drawPoint(ctx2, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width: width2, height: height2 } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height2 / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width2 / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value2, min, max) {
  return skip2 ? 0 : _limitValue(value2, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value2 = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value2);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value2 = bar.options.borderRadius;
  const o = toTRBLCorners(value2);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value2);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width2 = bounds.right - bounds.left;
  const height2 = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width2 / 2, height2 / 2);
  const radius = parseBorderRadius(bar, width2 / 2, height2 / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width2,
      h: height2,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width2 - border.l - border.r,
      h: height2 - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx2, rect) {
  ctx2.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h3,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx2) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx2.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx2.beginPath();
      addRectPath(ctx2, inflateRect(outer, inflateAmount, inner));
      ctx2.clip();
      addRectPath(ctx2, inflateRect(inner, -inflateAmount, outer));
      ctx2.fillStyle = borderColor;
      ctx2.fill("evenodd");
    }
    ctx2.beginPath();
    addRectPath(ctx2, inflateRect(inner, inflateAmount));
    ctx2.fillStyle = backgroundColor;
    ctx2.fill();
    ctx2.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
}
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
const BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
const BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data2, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data2.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data2[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data2[j].x;
      avgY += data2[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data2[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data2[j].y - pointAy) - (pointAx - data2[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data2[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data2[endIndex];
  return decimated;
}
function minMaxDecimation(data2, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data2[start].x;
  const xMax = data2[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data2[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data2[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data2[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data2[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data2 = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data2
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data2 = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data2);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data2;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data2, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data2, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property2) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property2, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property2, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property2]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property2]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property2, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property2];
  let end = last[property2];
  if (property2 === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property: property2,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale2) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale2.bottom;
  } else if (fill2 === "end") {
    pixel = scale2.top;
  } else if (isObject(fill2)) {
    pixel = scale2.getPixelForValue(fill2.value);
  } else if (scale2.getBasePixel) {
    pixel = scale2.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale2, startValue) {
  let value2;
  if (fill2 === "start") {
    value2 = startValue;
  } else if (fill2 === "end") {
    value2 = scale2.options.reverse ? scale2.min : scale2.max;
  } else if (isObject(fill2)) {
    value2 = fill2.value;
  } else {
    value2 = scale2.getBaseValue();
  }
  return value2;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale: scale2, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale2, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale2.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale2, index2) {
  const below = [];
  const metas = scale2.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property2) {
  const point = line.interpolate(sourcePoint, property2);
  if (!point) {
    return {};
  }
  const pointValue = point[property2];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property2];
    const lastValue = linePoints[segment.end][property2];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx2, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx2.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale2 = source.scale || {};
  if (scale2.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale: scale2 = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale2);
  if (isNumberFinite(pixel)) {
    const horizontal = scale2.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale: scale2, fill: fill2 } = source;
  const options = scale2.options;
  const length2 = scale2.getLabels().length;
  const start = options.reverse ? scale2.max : scale2.min;
  const value2 = _getTargetValue(fill2, scale2, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale2.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale2.getDistanceFromCenterForValue(value2)
    });
  }
  for (let i = 0; i < length2; ++i) {
    target.push(scale2.getPointPositionForValue(i, value2));
  }
  return target;
}
function _drawfill(ctx2, source, area) {
  const target = _getTarget(source);
  const { line, scale: scale2, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx2, area);
    doFill(ctx2, {
      line,
      target,
      above,
      below,
      area,
      scale: scale2,
      axis
    });
    unclipArea(ctx2);
  }
}
function doFill(ctx2, cfg) {
  const { line, target, above, below, area, scale: scale2 } = cfg;
  const property2 = line._loop ? "angle" : cfg.axis;
  ctx2.save();
  if (property2 === "x" && below !== above) {
    clipVertical(ctx2, target, area.top);
    fill(ctx2, {
      line,
      target,
      color: above,
      scale: scale2,
      property: property2
    });
    ctx2.restore();
    ctx2.save();
    clipVertical(ctx2, target, area.bottom);
  }
  fill(ctx2, {
    line,
    target,
    color: below,
    scale: scale2,
    property: property2
  });
  ctx2.restore();
}
function clipVertical(ctx2, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx2.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx2.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx2.lineTo(firstPoint.x, clipY);
      ctx2.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx2, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx2.closePath();
    } else {
      ctx2.lineTo(lastPoint.x, clipY);
    }
  }
  ctx2.lineTo(target.first().x, clipY);
  ctx2.closePath();
  ctx2.clip();
}
function fill(ctx2, cfg) {
  const { line, target, property: property2, color: color2, scale: scale2 } = cfg;
  const segments = _segments(line, target, property2);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx2.save();
    ctx2.fillStyle = backgroundColor;
    clipBounds(ctx2, scale2, notShape && _getBounds(property2, start, end));
    ctx2.beginPath();
    const lineLoop = !!line.pathSegment(ctx2, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx2.closePath();
      } else {
        interpolatedLineTo(ctx2, target, end, property2);
      }
      const targetLoop = !!target.pathSegment(ctx2, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx2, target, start, property2);
      }
    }
    ctx2.closePath();
    ctx2.fill(loop ? "evenodd" : "nonzero");
    ctx2.restore();
  }
}
function clipBounds(ctx2, scale2, bounds) {
  const { top, bottom } = scale2.chart.chartArea;
  const { property: property2, start, end } = bounds || {};
  if (property2 === "x") {
    ctx2.beginPath();
    ctx2.rect(start, top, end - start, bottom - top);
    ctx2.clip();
  }
}
function interpolatedLineTo(ctx2, target, point, property2) {
  const interpolatedPoint = target.interpolate(point, property2);
  if (interpolatedPoint) {
    ctx2.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
const getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx: ctx2 } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width2, height2;
    ctx2.font = labelFont.string;
    if (this.isHorizontal()) {
      width2 = this.maxWidth;
      height2 = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height2 = this.maxHeight;
      width2 = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width2, options.maxWidth || this.maxWidth);
    this.height = Math.min(height2, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx: ctx2, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx2.textAlign = "left";
    ctx2.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx2.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx: ctx2, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx2, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx2 = this.ctx;
      clipArea(ctx2, this);
      this._draw();
      unclipArea(ctx2);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx: ctx2 } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx2.textAlign = rtlHelper.textAlign("left");
    ctx2.textBaseline = "middle";
    ctx2.lineWidth = 0.5;
    ctx2.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx2.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx2.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx2.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx2.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx2.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx2.lineWidth = lineWidth;
      ctx2.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx2.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx2, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx2.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx2, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx2.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx2.fill();
        if (lineWidth !== 0) {
          ctx2.stroke();
        }
      }
      ctx2.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx2, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx2.strokeStyle = legendItem.fontColor;
      ctx2.fillStyle = legendItem.fontColor;
      const textWidth = ctx2.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width2 = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width2 + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width2 : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width2 + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx2 = this.ctx;
    const position2 = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position2, left, left + maxWidth);
    ctx2.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position2));
    ctx2.textBaseline = "middle";
    ctx2.strokeStyle = titleOpts.color;
    ctx2.fillStyle = titleOpts.color;
    ctx2.font = titleFont.string;
    renderText(ctx2, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
}
function calculateItemSize(boxWidth, labelFont, ctx2, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx2);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx2) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx2.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx2) => ctx2.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx2) => ctx2.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name2) => !name2.startsWith("on"),
    labels: {
      _scriptable: (name2) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name2)
    }
  }
};
class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation2 = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation2 = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation2 = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation: rotation2
    };
  }
  draw() {
    const ctx2 = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation: rotation2 } = this._drawArgs(offset);
    renderText(ctx2, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation: rotation2,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const map = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value: value2 } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value2,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx2 = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height2 = padding.height;
  let width2 = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height2 += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height2 += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height2 += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width2 = Math.max(width2, ctx2.measureText(line).width + widthPadding);
  };
  ctx2.save();
  ctx2.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx2.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx2.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx2.restore();
  width2 += padding.width;
  return {
    width: width2,
    height: height2
  };
}
function determineYAlign(chart, size) {
  const { y, height: height2 } = size;
  if (y < height2 / 2) {
    return "top";
  } else if (y > chart.height - height2 / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width: width2 } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width2 + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width2 - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width: width2 } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width2 / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width2 / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width: width2 } = size;
  if (xAlign === "right") {
    x -= width2;
  } else if (xAlign === "center") {
    x -= width2 / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height: height2 } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height2 + paddingAndSize;
  } else {
    y -= height2 / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent2, tooltip, tooltipItems) {
  return createContext(parent2, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context2) {
  const override = context2 && context2.dataset && context2.dataset.tooltip && context2.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value2 = tooltipItem.formattedValue;
    if (!isNullOrUndef(value2)) {
      label += value2;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name2, ctx2, arg) {
  const result = callbacks[name2].call(ctx2, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name2].call(ctx2, arg);
  }
  return result;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context2, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context2);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context2);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context2);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context2) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context2);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context2)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context2));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context2)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active2 = this._active;
    const data2 = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active2.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active2[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data2));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data2));
    }
    each(tooltipItems, (context2) => {
      const scoped = overrideCallbacks(options.callbacks, context2);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context2));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context2));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context2));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active2 = this._active;
    let properties;
    let tooltipItems = [];
    if (!active2.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position2 = positioners[options.position].call(this, active2, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position2, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position2.x,
        caretY: position2.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx2, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx2.lineTo(caretPosition.x1, caretPosition.y1);
    ctx2.lineTo(caretPosition.x2, caretPosition.y2);
    ctx2.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width: width2, height: height2 } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height2 / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width2;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width2 - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height2;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx2, options) {
    const title = this.title;
    const length2 = title.length;
    let titleFont, titleSpacing, i;
    if (length2) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx2.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx2.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx2.fillStyle = options.titleColor;
      ctx2.font = titleFont.string;
      for (i = 0; i < length2; ++i) {
        ctx2.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length2) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx2, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx2.strokeStyle = options.multiKeyBackground;
      ctx2.fillStyle = options.multiKeyBackground;
      drawPoint(ctx2, drawOptions, centerX, centerY);
      ctx2.strokeStyle = labelColor.borderColor;
      ctx2.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx2, drawOptions, centerX, centerY);
    } else {
      ctx2.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx2.strokeStyle = labelColor.borderColor;
      ctx2.setLineDash(labelColor.borderDash || []);
      ctx2.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx2.beginPath();
        ctx2.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx2, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx2.fill();
        ctx2.stroke();
        ctx2.fillStyle = labelColor.backgroundColor;
        ctx2.beginPath();
        addRoundedRectPath(ctx2, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx2.fill();
      } else {
        ctx2.fillStyle = options.multiKeyBackground;
        ctx2.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx2.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx2.fillStyle = labelColor.backgroundColor;
        ctx2.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx2.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx2, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx2.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx2.textAlign = bodyAlign;
    ctx2.textBaseline = "middle";
    ctx2.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx2.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx2.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx2, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx2, options) {
    const footer = this.footer;
    const length2 = footer.length;
    let footerFont, i;
    if (length2) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx2.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx2.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx2.fillStyle = options.footerColor;
      ctx2.font = footerFont.string;
      for (i = 0; i < length2; ++i) {
        ctx2.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx2, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width: width2, height: height2 } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx2.fillStyle = options.backgroundColor;
    ctx2.strokeStyle = options.borderColor;
    ctx2.lineWidth = options.borderWidth;
    ctx2.beginPath();
    ctx2.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx2, tooltipSize, options);
    }
    ctx2.lineTo(x + width2 - topRight, y);
    ctx2.quadraticCurveTo(x + width2, y, x + width2, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx2, tooltipSize, options);
    }
    ctx2.lineTo(x + width2, y + height2 - bottomRight);
    ctx2.quadraticCurveTo(x + width2, y + height2, x + width2 - bottomRight, y + height2);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx2, tooltipSize, options);
    }
    ctx2.lineTo(x + bottomLeft, y + height2);
    ctx2.quadraticCurveTo(x, y + height2, x, y + height2 - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx2, tooltipSize, options);
    }
    ctx2.lineTo(x, y + topLeft);
    ctx2.quadraticCurveTo(x, y, x + topLeft, y);
    ctx2.closePath();
    ctx2.fill();
    if (options.borderWidth > 0) {
      ctx2.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position2 = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position2) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position2, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position2.x;
        this.caretY = position2.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx2) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx2.save();
      ctx2.globalAlpha = opacity;
      this.drawBackground(pt, ctx2, tooltipSize, options);
      overrideTextDirection(ctx2, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx2, options);
      this.drawBody(pt, ctx2, options);
      this.drawFooter(pt, ctx2, options);
      restoreTextDirection(ctx2, options.textDirection);
      ctx2.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active2 = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active2);
    const positionChanged = this._positionChanged(active2, eventPosition);
    if (changed || positionChanged) {
      this._active = active2;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active2 = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active2, e);
    const changed = replay || !_elementsEqual(active2, lastActive) || positionChanged;
    if (changed) {
      this._active = active2;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active2 = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active2.reverse();
    }
    return active2;
  }
  _positionChanged(active2, e) {
    const { caretX, caretY, options } = this;
    const position2 = positioners[options.position].call(this, active2, e);
    return position2 !== false && (caretX !== position2.x || caretY !== position2.y);
  }
}
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx2, opts) => opts.bodyFont.size,
    boxWidth: (ctx2, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value2) {
  const labels = this.getLabels();
  if (value2 >= 0 && value2 < labels.length) {
    return labels[value2];
  }
  return value2;
}
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value2 = min; value2 <= max; value2++) {
      ticks.push({
        value: value2
      });
    }
    return ticks;
  }
  getLabelForValue(value2) {
    return _getLabelForValue.call(this, value2);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value2) {
    if (typeof value2 !== "number") {
      value2 = this.parse(value2);
    }
    return value2 === null ? NaN : this.getPixelForDecimal((value2 - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step: step2, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step2 || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step2 && almostWhole((max - min) / step2, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value2, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio2 = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length2 = 0.75 * minSpacing * ("" + value2).length;
  return Math.min(minSpacing / ratio2, length2);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value2) {
    return formatNumber(value2, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length2 = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio2 = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length2 / Math.min(40, tickFont.lineHeight / ratio2));
  }
  getPixelForValue(value2) {
    return value2 === null ? NaN : this.getPixelForDecimal((value2 - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
const log10Floor = (v) => Math.floor(log10(v));
const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value2 = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value2 < max) {
    ticks.push({
      value: value2,
      major: isMajor(value2),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value2 = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value2);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value2 = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value2 === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value2) && value2 > 0 ? value2 : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value2) {
    return value2 === void 0 ? "0" : formatNumber(value2, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value2) {
    if (value2 === void 0 || value2 === 0) {
      value2 = this.min;
    }
    if (value2 === null || isNaN(value2)) {
      return NaN;
    }
    return this.getPixelForDecimal(value2 === this.min ? 0 : (log10(value2) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx2, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx2, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale2) {
  const orig = {
    l: scale2.left + scale2._padding.left,
    r: scale2.right - scale2._padding.right,
    t: scale2.top + scale2._padding.top,
    b: scale2.bottom - scale2._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale2._pointLabels.length;
  const pointLabelOpts = scale2.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale2.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale2.getPointPosition(i, scale2.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale2.ctx, plFont, scale2._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale2.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale2.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale2._pointLabelItems = buildPointLabelItems(scale2, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale2, index2, itemOpts) {
  const outerDistance = scale2.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale2.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale2, labelSizes, padding) {
  const items = [];
  const valueCount = scale2._pointLabels.length;
  const opts = scale2.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale2, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h3, angle) {
  if (angle === 90 || angle === 270) {
    y -= h3 / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h3;
  }
  return y;
}
function drawPointLabelBox(ctx2, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx2.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx2.beginPath();
      addRoundedRectPath(ctx2, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx2.fill();
    } else {
      ctx2.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale2, labelCount) {
  const { ctx: ctx2, options: { pointLabels } } = scale2;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale2._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale2.getPointLabelContext(i));
    drawPointLabelBox(ctx2, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx2, scale2._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale2, radius, circular, labelCount) {
  const { ctx: ctx2 } = scale2;
  if (circular) {
    ctx2.arc(scale2.xCenter, scale2.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale2.getPointPosition(0, radius);
    ctx2.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale2.getPointPosition(i, radius);
      ctx2.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale2, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx2 = scale2.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx2.save();
  ctx2.strokeStyle = color2;
  ctx2.lineWidth = lineWidth;
  ctx2.setLineDash(borderOpts.dash);
  ctx2.lineDashOffset = borderOpts.dashOffset;
  ctx2.beginPath();
  pathRadiusLine(scale2, radius, circular, labelCount);
  ctx2.closePath();
  ctx2.stroke();
  ctx2.restore();
}
function createPointLabelContext(parent2, index2, label) {
  return createContext(parent2, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h3 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h3) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value2, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value2,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value2) {
    if (isNullOrUndef(value2)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value2) * scalingFactor;
    }
    return (value2 - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value2) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value2));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx2 = this.ctx;
      ctx2.save();
      ctx2.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx2.closePath();
      ctx2.fillStyle = backgroundColor;
      ctx2.fill();
      ctx2.restore();
    }
  }
  drawGrid() {
    const ctx2 = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position2;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context2 = this.getContext(index2);
          const optsAtIndex = grid.setContext(context2);
          const optsAtIndexBorder = border.setContext(context2);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx2.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx2.lineWidth = lineWidth;
        ctx2.strokeStyle = color2;
        ctx2.setLineDash(optsAtIndex.borderDash);
        ctx2.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position2 = this.getPointPosition(i, offset);
        ctx2.beginPath();
        ctx2.moveTo(this.xCenter, this.yCenter);
        ctx2.lineTo(position2.x, position2.y);
        ctx2.stroke();
      }
      ctx2.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx2 = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width2;
    ctx2.save();
    ctx2.translate(this.xCenter, this.yCenter);
    ctx2.rotate(startAngle);
    ctx2.textAlign = "center";
    ctx2.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx2.font = tickFont.string;
        width2 = ctx2.measureText(tick.label).width;
        ctx2.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx2.fillRect(-width2 / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width2 + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx2, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx2.restore();
  }
  drawTitle() {
  }
}
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale2, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale2._adapter;
  const { parser, round: round2, isoWeekday } = scale2._parseOpts;
  let value2 = input;
  if (typeof parser === "function") {
    value2 = parser(value2);
  }
  if (!isNumberFinite(value2)) {
    value2 = typeof parser === "string" ? adapter.parse(value2, parser) : adapter.parse(value2);
  }
  if (value2 === null) {
    return null;
  }
  if (round2) {
    value2 = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value2, "isoWeek", isoWeekday) : adapter.startOf(value2, round2);
  }
  return +value2;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale2, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale2._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time2, timestamps) {
  if (!timestamps) {
    ticks[time2] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time2);
    const timestamp = timestamps[lo] >= time2 ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale2, ticks, map2, majorUnit) {
  const adapter = scale2._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale2, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i, value2;
  for (i = 0; i < ilen; ++i) {
    value2 = values[i];
    map2[value2] = i;
    ticks.push({
      value: value2,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map2, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time2 = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time2.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time2.parser,
      round: time2.round,
      isoWeekday: time2.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time2, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time2 = first, count = 0; time2 < max; time2 = +adapter.add(time2, stepSize, minor), count++) {
      addTick(ticks, time2, timestamps);
    }
    if (time2 === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time2, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value2) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value2, timeOpts.tooltipFormat);
    }
    return adapter.format(value2, timeOpts.displayFormats.datetime);
  }
  format(value2, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value2, fmt);
  }
  _tickFormatFunction(time2, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time2,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time2, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value2) {
    return value2 === null ? NaN : (value2 - this.min) / (this.max - this.min);
  }
  getPixelForValue(value2) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value2);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate(table, val2, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val2 >= table[lo].pos && val2 <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val2));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val2 >= table[lo].time && val2 <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val2));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val2 - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data2 = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data2.length && label.length) {
      timestamps = this.normalize(data2.concat(label));
    } else {
      timestamps = data2.length ? data2 : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value2) {
    return (interpolate(this._table, value2) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
const registerables = [
  controllers,
  elements,
  plugins,
  scales
];
let canvas$2;
let routeInfo;
let ctx;
let ratio$2;
let step = 0;
let gameMaxIdx = 0;
let requestId;
let canvasDone = false;
Chart.register(...registerables);
const drawLine$2 = (stX, stY, edX, edY, color2, gameIdx) => {
  ctx[gameIdx].setLineDash([]);
  ctx[gameIdx].beginPath();
  ctx[gameIdx].moveTo(stX * ratio$2, stY * ratio$2);
  ctx[gameIdx].lineTo(edX * ratio$2, edY * ratio$2);
  ctx[gameIdx].strokeStyle = color2;
  ctx[gameIdx].lineWidth = 1;
  ctx[gameIdx].stroke();
  ctx[gameIdx].closePath();
};
const drawLineDash = (stX, stY, edX, edY, color2, gameIdx) => {
  ctx[gameIdx].setLineDash([5, 5]);
  ctx[gameIdx].beginPath();
  ctx[gameIdx].moveTo(stX * ratio$2, stY * ratio$2);
  ctx[gameIdx].lineTo(edX * ratio$2, edY * ratio$2);
  ctx[gameIdx].strokeStyle = color2;
  ctx[gameIdx].lineWidth = 1;
  ctx[gameIdx].stroke();
  ctx[gameIdx].closePath();
};
const drawBall$2 = (x, y, radius, gameIdx) => {
  ctx[gameIdx].beginPath();
  ctx[gameIdx].arc(
    x * ratio$2,
    y * ratio$2,
    Math.max(radius * ratio$2, 7),
    0,
    Math.PI * 2
  );
  ctx[gameIdx].fill();
  ctx[gameIdx].closePath();
};
const drawRoute = (start, end, stepX, gameIdx) => {
  let slopeSt = start.speedY / start.speedX;
  let dir = 1;
  if (start.speedX < 0) {
    dir = -1;
  }
  const calcY = (slope, x0, y0, x2) => {
    return slope * (x2 - x0) + y0;
  };
  let xDir = (0 - start.y) / slopeSt + start.x;
  let xDir2 = (900 - start.y) / slopeSt + start.x;
  let delta = Math.abs(xDir2 - xDir) * dir;
  let x = start.x;
  let y = start.y;
  let ex = slopeSt * dir < 0 ? xDir : xDir2;
  let ey = slopeSt * dir < 0 ? 0 : 900;
  drawLineDash(
    x,
    y,
    Math.abs(ex - x) < Math.abs(stepX - x) ? ex : stepX,
    Math.abs(ex - x) < Math.abs(stepX - x) ? ey : calcY(slopeSt, x, y, stepX),
    "#ffffff",
    gameIdx
  );
  x = slopeSt * dir < 0 ? xDir : xDir2;
  y = slopeSt * dir < 0 ? 0 : 900;
  while (x * dir < stepX * dir) {
    ex = x + delta;
    ey = y === 900 ? 0 : 900;
    slopeSt = -slopeSt;
    drawLineDash(
      x,
      y,
      Math.abs(ex - x) < Math.abs(stepX - x) ? ex : stepX,
      Math.abs(ex - x) < Math.abs(stepX - x) ? ey : calcY(slopeSt, x, y, stepX),
      "#ffffff",
      gameIdx
    );
    x += delta;
    y = start.y === 900 ? 0 : 900;
  }
};
const drawBallRouteDone = () => {
  for (let gameIdx = 0; gameIdx < gameMaxIdx; gameIdx++) {
    ratio$2 = canvas$2[gameIdx].width / 1200;
    ctx[gameIdx].fillStyle = "#181818";
    ctx[gameIdx].fillRect(0, 0, canvas$2[gameIdx].width, canvas$2[gameIdx].height);
    ctx[gameIdx].fillStyle = "#ffffff";
    drawLine$2(600, 0, 600, 900, "#ffffff", gameIdx);
    for (let idx = 0; idx < routeInfo[gameIdx].length; idx++) {
      const info = routeInfo[gameIdx][idx];
      drawRoute(
        info.ball_start_position,
        info.ball_end_position,
        info.ball_end_position.x,
        gameIdx
      );
      drawBall$2(
        info.ball_end_position.x,
        info.ball_end_position.y,
        info.ball_end_position.radius,
        gameIdx
      );
    }
  }
};
const drawBallRoute = (doneIdx) => {
  step++;
  let countDone = 0;
  for (let gameIdx = 0; gameIdx < gameMaxIdx; gameIdx++) {
    if (doneIdx >= routeInfo[gameIdx].length) {
      countDone++;
      continue;
    }
    ratio$2 = canvas$2[gameIdx].width / 1200;
    ctx[gameIdx].fillStyle = "#181818";
    ctx[gameIdx].fillRect(0, 0, canvas$2[gameIdx].width, canvas$2[gameIdx].height);
    ctx[gameIdx].fillStyle = "#ffffff";
    drawLine$2(600, 0, 600, 900, "#ffffff", gameIdx);
    for (let idx = 0; idx < doneIdx; idx++) {
      const info2 = routeInfo[gameIdx][idx];
      drawRoute(
        info2.ball_start_position,
        info2.ball_end_position,
        info2.ball_end_position.x,
        gameIdx
      );
      drawBall$2(
        info2.ball_end_position.x,
        info2.ball_end_position.y,
        info2.ball_end_position.radius,
        gameIdx
      );
    }
    const info = routeInfo[gameIdx][doneIdx];
    const stepX = info.ball_start_position.x + (info.ball_end_position.x - info.ball_start_position.x) / 50 * step;
    drawRoute(info.ball_start_position, info.ball_end_position, stepX, gameIdx);
    if (step >= 50) {
      drawBall$2(
        info.ball_end_position.x,
        info.ball_end_position.y,
        info.ball_end_position.radius,
        gameIdx
      );
    }
  }
  if (countDone === gameMaxIdx) {
    canvasDone = true;
    return;
  }
  if (step >= 50) {
    step = 0;
    requestId = requestAnimationFrame(() => drawBallRoute(doneIdx + 1));
    return;
  }
  requestId = requestAnimationFrame(() => drawBallRoute(doneIdx));
};
function convertOrdinalNumber(n) {
  n = parseInt(n, 10);
  const suffix = ["th", "st", "nd", "rd"];
  const mod100 = n % 100;
  return n + (suffix[(mod100 - 20) % 10] || suffix[mod100] || suffix[0]);
}
function convertDate(date) {
  var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  const date_type = new Date(date);
  const date_text = `${convertOrdinalNumber(date_type.getDate())} ${monthNames[date_type.getMonth()]}`;
  return date_text;
}
const convertRouteInfo = (data2) => {
  const routeInfo2 = data2.data.goal_list;
  routeInfo2.forEach((info, idx) => {
    info.left = routeInfo2.slice(0, idx + 1).reduce(
      (accu, value2) => value2.goal_user_position === "left" ? accu + 1 : accu,
      0
    );
    info.right = routeInfo2.slice(0, idx + 1).reduce(
      (accu, value2) => value2.goal_user_position === "right" ? accu + 1 : accu,
      0
    );
    info.ball_start_position = JSON.parse(info.ball_start_position);
    info.ball_end_position = JSON.parse(info.ball_end_position);
  });
  return routeInfo2;
};
const LogSingleItem = ({ record, setLogStat, gameRecords, setGameRecords }) => {
  const defaultImg = `/img/minji_${record.opponent_name[0].charCodeAt(0) % 5 + 1}.jpg`;
  const handleGameDetail = async (id) => {
    const gameDetail = await axiosGameDetail({ gameId: id });
    routeInfo = [convertRouteInfo(gameDetail)];
    setGameRecords({
      ...gameRecords,
      gameDetail: {}
    });
    setLogStat(PlayStat.DETAIL);
  };
  return /* @__PURE__ */ h("div", { class: "log-single-item", onclick: () => handleGameDetail(record.id) }, /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("img", { src: record.opponent_profile ?? defaultImg }), /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("h4", null, record.opponent_name), /* @__PURE__ */ h("p", null, record.user_score, ":", record.opponent_score))), /* @__PURE__ */ h("div", { class: "log-result flex-column" }, /* @__PURE__ */ h("h3", null, record.user_score > record.opponent_score ? "WIN!" : "LOSE"), /* @__PURE__ */ h("p", null, convertDate(record.created_at))));
};
const getDefaultImg = (name2) => {
  return `/img/minji_${name2[0].charCodeAt(0) % 5 + 1}.jpg`;
};
const LogMultiItem = ({
  name: name2,
  record,
  setLogStat,
  gameRecords,
  setGameRecords,
  userProfile
}) => {
  const handleGameDetail = async (idArr) => {
    routeInfo = [];
    for (let id of idArr) {
      const gameDetail = await axiosGameDetail({ gameId: id });
      routeInfo.push(convertRouteInfo(gameDetail));
    }
    setLogStat(PlayStat.DETAILS);
    setGameRecords({
      ...gameRecords,
      gameDetail: {}
    });
  };
  return /* @__PURE__ */ h(
    "div",
    {
      class: "log-multi-item",
      onclick: () => handleGameDetail([record.game1_id, record.game2_id, record.game3_id])
    },
    /* @__PURE__ */ h("div", { class: "log-multi-info" }, /* @__PURE__ */ h("div", { class: "flex-row" }, /* @__PURE__ */ h("div", { class: "flex-column" }, /* @__PURE__ */ h(
      "img",
      {
        class: "my-profile",
        src: userProfile ?? getDefaultImg(name2)
      }
    ), /* @__PURE__ */ h(
      "img",
      {
        src: record.opponent1_profile ?? getDefaultImg(record.opponent1_name)
      }
    )), /* @__PURE__ */ h("div", { class: "flex-column" }, /* @__PURE__ */ h(
      "img",
      {
        src: record.opponent2_profile ?? getDefaultImg(record.opponent2_name)
      }
    ), /* @__PURE__ */ h(
      "img",
      {
        src: record.opponent3_profile ?? getDefaultImg(record.opponent3_name)
      }
    ))), /* @__PURE__ */ h("div", { class: "flex-row" }, /* @__PURE__ */ h("div", { class: "flex-column" }, /* @__PURE__ */ h("h6", { class: "my-profile" }, name2), /* @__PURE__ */ h("h6", null, record.opponent1_name)), /* @__PURE__ */ h("div", { class: "flex-column" }, /* @__PURE__ */ h("h6", null, record.opponent2_name), /* @__PURE__ */ h("h6", null, record.opponent3_name)))),
    /* @__PURE__ */ h("div", { class: "log-result flex-column" }, /* @__PURE__ */ h("h3", null, record.user_score > record.opponent_score ? "WIN!" : "LOSE"), /* @__PURE__ */ h("p", null, convertDate(record.created_at)))
  );
};
const PlayStat = {
  SINGLE: "single",
  MULTI: "multi",
  DASHBOARD: "dashboard",
  DETAIL: "detail",
  DETAILS: "details"
};
const LobbyProfile = ({ profile }) => {
  const [logStat, setLogStat] = useState(PlayStat.SINGLE);
  const [gameRecords, setGameRecords] = useState({});
  useEffect(() => {
    const getGameRecords = async () => {
      const dayStatApi = await axiosUserDayStat({
        username: profile.username
      });
      const recentOpponentApi = await axiosUserRecentOpponent({
        username: profile.username
      });
      const singleRecordsApi = await axiosGameRecords({
        username: profile.username,
        isSingle: "SINGLE"
      });
      const multiRecordsApi = await axiosGameRecords({
        username: profile.username,
        isSingle: "MULTI"
      });
      const avgGameLineApi = await axiosAvgGameLine({
        username: profile.username
      });
      setGameRecords({
        playOfWeek: dayStatApi.data.day_count_stats,
        recentOpponent: recentOpponentApi.data.opponent_records,
        singleRecords: singleRecordsApi.data.record_list,
        multiRecords: multiRecordsApi.data.record_list,
        avgGameLine: avgGameLineApi.data
      });
    };
    getGameRecords();
  }, []);
  useEffect(() => {
    if (logStat === PlayStat.DASHBOARD) {
      const labels = gameRecords.playOfWeek.map((data2) => data2.day);
      const numOfRound = gameRecords.playOfWeek.map((data2) => data2.count);
      const numOfWins = gameRecords.playOfWeek.map((data2) => data2.wins);
      const numOfLoses = gameRecords.playOfWeek.map(
        (data2) => data2.count - data2.wins
      );
      const rateOfWins = gameRecords.playOfWeek.map(
        (data2) => data2.count ? data2.wins / data2.count * 100 : 0
      );
      let ctx2 = document.getElementById("myChartCnt");
      new Chart(ctx2, {
        data: {
          labels,
          datasets: [
            {
              type: "bar",
              label: "Rounds",
              data: numOfRound,
              borderWidth: 1
            },
            {
              type: "bar",
              label: "Win",
              data: numOfWins,
              borderWidth: 1
            },
            {
              type: "bar",
              label: "Loses",
              data: numOfLoses,
              borderWidth: 1
            }
          ]
        },
        options: {
          scales: {
            y: {
              grid: {
                color: (context2) => {
                  return "rgba(255,255,255,0.4)";
                }
              },
              ticks: {
                stepSize: (context2) => {
                  return Math.max(Math.max(...numOfRound) / 5, 1);
                }
              },
              beginAtZero: true
            }
          }
        }
      });
      ctx2 = document.getElementById("myChartRate");
      new Chart(ctx2, {
        data: {
          labels,
          datasets: [
            {
              type: "line",
              tension: 0.3,
              label: "Rate of Week",
              data: rateOfWins,
              borderWidth: 1,
              fill: true,
              backgroundColor: "rgba(255,255,255,0.3)"
            }
          ]
        },
        options: {
          scales: {
            y: {
              grid: {
                color: (context2) => {
                  return "rgba(255,255,255,0.4)";
                },
                lineWidth: (context2) => {
                  return 1;
                }
              },
              ticks: {
                stepSize: 20
              },
              beginAtZero: true
            }
          }
        }
      });
      const avgLabels = gameRecords.avgGameLine.index;
      const avgRates = gameRecords.avgGameLine.rates_total;
      const avgRates3 = gameRecords.avgGameLine.rates_3play;
      const avgRates5 = gameRecords.avgGameLine.rates_5play;
      ctx2 = document.getElementById("myChartAvgRates");
      new Chart(ctx2, {
        data: {
          labels: avgLabels,
          datasets: [
            {
              type: "line",
              tension: 0.3,
              label: "3plays avg",
              data: avgRates3,
              borderWidth: 1,
              fill: true,
              backgroundColor: "rgba(255,130,130,0.5)"
            },
            {
              type: "line",
              tension: 0.3,
              label: "Total avg",
              data: avgRates,
              borderWidth: 1,
              fill: true,
              backgroundColor: "rgba(255,255,255,0.2)"
            },
            {
              type: "line",
              tension: 0.3,
              label: "5plays avg",
              data: avgRates5,
              borderWidth: 1,
              fill: true,
              backgroundColor: "rgba(130,130,255,0.5)"
            }
          ]
        },
        options: {
          scales: {
            y: {
              grid: {
                color: (context2) => {
                  return "rgba(255,255,255,0.4)";
                },
                lineWidth: (context2) => {
                  return 1;
                }
              },
              ticks: {
                stepSize: 20
              },
              beginAtZero: true
            }
          }
        }
      });
    } else if (logStat === PlayStat.DETAIL || logStat === PlayStat.DETAILS) {
      canvas$2 = document.querySelectorAll(".game-detail > canvas");
      ctx = [...canvas$2].map((cvsComponent) => cvsComponent.getContext("2d"));
      for (let context2 of ctx) {
        context2.scale(1, 1);
      }
      canvas$2.forEach((cvsComponent) => {
        let rate = 1;
        if (document.querySelector(".game-detail").clientWidth > 600) {
          rate = document.querySelector(".game-detail").clientWidth / 600;
        }
        cvsComponent.width = document.querySelector(".game-detail").clientWidth / rate;
        cvsComponent.height = cvsComponent.width * 0.75;
      });
      gameMaxIdx = routeInfo.length;
      canvasDone = false;
      drawBallRoute(0);
    }
  }, [logStat]);
  useEffect(() => {
    addEventArray(eventType.RESIZE, () => {
      canvas$2 = document.querySelectorAll(".game-detail > canvas");
      if (canvas$2.length === 0)
        return;
      canvas$2.forEach((cvsComponent) => {
        let rate = 1;
        if (document.querySelector(".game-detail").clientWidth > 600) {
          rate = document.querySelector(".game-detail").clientWidth / 600;
        }
        cvsComponent.width = document.querySelector(".game-detail").clientWidth / rate;
        cvsComponent.height = cvsComponent.width * 0.75;
      });
      if (canvasDone) {
        gameMaxIdx = routeInfo.length;
        drawBallRouteDone();
      }
    });
    addEventHandler();
  }, []);
  const matchNum = profile.win + profile.lose;
  const handleLogStat = (stat) => {
    if (logStat === PlayStat.DETAIL || logStat === PlayStat.DETAILS) {
      cancelAnimationFrame(requestId);
      setGameRecords({
        ...gameRecords,
        gameDetail: {}
      });
    }
    setLogStat(stat);
  };
  console.log(profile);
  return /* @__PURE__ */ h("div", { class: "profile-main" }, /* @__PURE__ */ h("div", { class: "profile-info" }, /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("h3", null, profile.username)), /* @__PURE__ */ h("p", null, "Win: ", profile.win), /* @__PURE__ */ h("p", null, "Lose: ", profile.lose), /* @__PURE__ */ h("p", null, "Rate: ", matchNum ? (profile.win / matchNum * 100).toFixed(2) : 0, "%")), /* @__PURE__ */ h("div", { class: "profile-log" }, /* @__PURE__ */ h("div", { class: "select-bar" }, /* @__PURE__ */ h(
    "button",
    {
      onclick: () => handleLogStat(PlayStat.SINGLE),
      class: logStat === PlayStat.SINGLE ? "selected" : ""
    },
    /* @__PURE__ */ h("span", { class: "vertical-text" }, "Single")
  ), /* @__PURE__ */ h(
    "button",
    {
      onclick: () => handleLogStat(PlayStat.MULTI),
      class: logStat === PlayStat.MULTI ? "selected" : ""
    },
    /* @__PURE__ */ h("span", { class: "vertical-text" }, "Multi")
  ), /* @__PURE__ */ h(
    "button",
    {
      onclick: () => handleLogStat(PlayStat.DASHBOARD),
      class: `dashboardBtn ${logStat === PlayStat.DASHBOARD ? "selected" : ""}`
    },
    /* @__PURE__ */ h("span", { class: "vertical-text" }, "DashBoard")
  )), !isEmpty(gameRecords) ? logStat === PlayStat.SINGLE ? /* @__PURE__ */ h("div", { class: "log-container" }, gameRecords.singleRecords.slice().reverse().map((record) => /* @__PURE__ */ h(
    LogSingleItem,
    {
      record,
      setLogStat,
      gameRecords,
      setGameRecords
    }
  ))) : logStat === PlayStat.MULTI ? /* @__PURE__ */ h("div", { class: "log-container" }, gameRecords.multiRecords.slice().reverse().map((record) => /* @__PURE__ */ h(
    LogMultiItem,
    {
      name: profile.username,
      record,
      setLogStat,
      gameRecords,
      setGameRecords,
      userProfile: profile.profile_image
    }
  ))) : logStat === PlayStat.DASHBOARD ? /* @__PURE__ */ h("div", { class: "log-container detail" }, /* @__PURE__ */ h("h4", null, "Play of Week"), /* @__PURE__ */ h("canvas", { id: "myChartCnt" }), /* @__PURE__ */ h("h4", null, "Winning Rate of Week"), /* @__PURE__ */ h("canvas", { id: "myChartRate" }), /* @__PURE__ */ h("h4", null, "Average Winning Rates"), /* @__PURE__ */ h("canvas", { id: "myChartAvgRates" })) : gameRecords.gameDetail ? /* @__PURE__ */ h("div", { class: "log-container detail" }, routeInfo.map((value2, idx) => /* @__PURE__ */ h("div", { class: "game-detail-page" }, /* @__PURE__ */ h("div", { class: "game-detail" }, /* @__PURE__ */ h("canvas", null)), /* @__PURE__ */ h("h4", null, "Game Details"), /* @__PURE__ */ h("div", { class: "goal-info-item main" }, /* @__PURE__ */ h("p", { class: "no" }, "no.", idx), /* @__PURE__ */ h("p", null, "Username"), /* @__PURE__ */ h("p", null, "Score"), /* @__PURE__ */ h("p", null, "Time")), routeInfo[idx] && routeInfo[idx].map((goal, idx2) => /* @__PURE__ */ h("div", { key: idx2, class: "goal-info-item" }, /* @__PURE__ */ h("p", { class: "no" }, idx2 + 1), /* @__PURE__ */ h("p", null, goal.goal_user_name), /* @__PURE__ */ h("p", null, goal.left, ":", goal.right), /* @__PURE__ */ h("p", null, goal.timestamp.toFixed(2))))))) : /* @__PURE__ */ h("div", null) : null));
};
const ProfilePage = () => {
  const [profile, setProfile] = useState({});
  const [stat, setStat] = useState(0);
  const [userName, setUserName] = useState("");
  useEffect(() => {
    const fetchProfile = async () => {
      let user = null;
      let name2 = window.location.pathname.split("/").pop();
      setUserName(name2);
      if (name2 === "me") {
        user = await axiosUserMe();
        setUserData(clientUserStore.dispatch, user.data.user_info);
      } else {
        user = await axiosUserOther(name2);
        if (!user.data) {
          return;
        } else if (user.data.message === "User not found") {
          gotoPage("/lobby");
          return;
        }
        let follow = user.data.user_info.is_following;
        if (!follow)
          setStat(2);
        else
          setStat(3);
      }
      if (!user.data) {
        return;
      }
      setProfile(user.data.user_info);
    };
    fetchProfile();
  }, []);
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", { id: "top" }, /* @__PURE__ */ h(TopNavBar, null)), /* @__PURE__ */ h("div", { id: "middle" }, isEmpty(profile) ? /* @__PURE__ */ h("div", { class: "main-section flex-row" }) : /* @__PURE__ */ h("div", { class: "main-section flex-row" }, /* @__PURE__ */ h(ProfileImg, { stat, setStat, profile }), /* @__PURE__ */ h(LobbyProfile, { profile })), /* @__PURE__ */ h(UserList, null)));
};
const ProfileConfig = ({ profile, getProfileImg }) => {
  useEffect(() => {
    const inputs = document.querySelectorAll("input[type=text]");
    inputs.forEach((input) => {
      input.addEventListener("keydown", (e) => {
        const isalpha = /^[a-zA-Z0-9]*$/i.test(e.key);
        const isnumpad = /^[0-9]*$/i.test(e.key);
        if (!isalpha && !isnumpad) {
          e.preventDefault();
        }
      });
    });
  }, []);
  const saveMyConfig = async () => {
    const config2Change = new FormData();
    if (document.querySelectorAll("input[type=text]")[0].value !== "") {
      config2Change.append(
        "username",
        document.querySelectorAll("input[type=text]")[0].value
      );
    }
    if (document.querySelectorAll("input[type=text]")[1].value !== "") {
      config2Change.append(
        "multi_nickname",
        document.querySelectorAll("input[type=text]")[1].value
      );
    }
    config2Change.append(
      "otp_enabled",
      document.querySelectorAll("input[type=checkbox]")[0].checked
    );
    if (getProfileImg() === void 0)
      ;
    else if (getProfileImg() === null) {
      axiosDeleteProfileImg();
    } else {
      config2Change.append("profile_image", getProfileImg());
    }
    const res = await axiosUserMeConfig(config2Change);
    console.log(res.data);
    if (res.data.message === "Invalid username" || res.data.message === "duplicate username") {
      if (res.data.message === "Invalid username") {
        document.querySelector(".inval-msg").innerHTML = "Invalid user name, may be wrong nickname policy";
      } else {
        document.querySelector(".inval-msg").innerHTML = "Duplicated user name";
      }
      document.querySelector(".inval-msg").classList.add("show");
      document.querySelector(".inval-msg").classList.add("active");
      document.querySelectorAll("input[type=text]")[0].focus();
      document.querySelector(".inval-msg").addEventListener(
        "animationend",
        function() {
          this.classList.remove("active");
        },
        { once: true }
      );
    } else {
      const userMe = await axiosUserMe();
      ws_userlist.getState().socket.send(
        JSON.stringify({
          type: "change_name",
          new_name: userMe.data.user_info.username
        })
      );
      setUserData(clientUserStore.dispatch, userMe.data.user_info);
      gotoPage("/profile/me");
    }
  };
  return /* @__PURE__ */ h("div", { class: "profile-config-main" }, !profile ? null : /* @__PURE__ */ h("h3", null, profile.username), /* @__PURE__ */ h("div", { class: "profile-config-list" }, /* @__PURE__ */ h(ItemInput, { ItemName: "Nickname", defaultValue: profile.username }), /* @__PURE__ */ h("div", { class: "cl-red inval-msg" }), /* @__PURE__ */ h("div", { style: "display: none;" }, /* @__PURE__ */ h(
    ItemInput,
    {
      ItemName: "Multi-nickname",
      defaultValue: profile.multi_nickname
    }
  )), /* @__PURE__ */ h(ItemToggle, { ItemName: "2FA", isOn: profile.otp_enabled })), /* @__PURE__ */ h("div", { class: "profile-config-submit" }, /* @__PURE__ */ h(
    "button",
    {
      onclick: () => gotoPage("/profile/me"),
      class: "config-btn bg-gray50"
    },
    /* @__PURE__ */ h("img", { src: "/icon/close.svg" }),
    "cancel"
  ), /* @__PURE__ */ h("button", { onclick: saveMyConfig, class: "config-btn bg-gray70" }, /* @__PURE__ */ h("img", { src: "/icon/done.svg" }), "save change")));
};
const ProfileConfigPage = () => {
  const [profile, setProfile] = useState({});
  const [getProfileImg, setProfileImg] = useRef(null);
  useEffect(() => {
    const fetchProfile = async () => {
      const userMe = await axiosUserMe();
      if (!userMe.data) {
        return;
      }
      setUserData(clientUserStore.dispatch, userMe.data.user_info);
      setProfile(userMe.data.user_info);
    };
    fetchProfile();
  }, []);
  return /* @__PURE__ */ h("div", null, isEmpty(clientUserStore.getState().client) ? null : /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("div", { id: "top" }, /* @__PURE__ */ h(TopNavBar, null)), /* @__PURE__ */ h("div", { id: "middle" }, /* @__PURE__ */ h("div", { class: "main-section flex-row" }, /* @__PURE__ */ h(
    ProfileImg,
    {
      stat: 1,
      profile: clientUserStore.getState().client,
      setProfileImg
    }
  ), /* @__PURE__ */ h(
    ProfileConfig,
    {
      profile: clientUserStore.getState().client,
      getProfileImg
    }
  )), /* @__PURE__ */ h(UserList, null))));
};
let bracketShow = false;
let drawBorder = (ctx2, player, pos) => {
  ctx2.font = "16px Arial";
  ctx2.fillStyle = "white";
  ctx2.textAlign = "center";
  if (!player) {
    ctx2.fillText("", pos.x, pos.y + 25);
  } else {
    ctx2.fillText(player, pos.x, pos.y + 25);
  }
  ctx2.strokeRect(pos.x - 50, pos.y, 100, 40);
};
const Bracket = (users2) => {
  addEventArray(eventType.KEYDOWN, (e) => {
    if (e.key === "t") {
      const bracketElem = document.querySelector("#Bracket");
      if (!bracketElem || bracketShow)
        return;
      bracketElem.setAttribute("class", "show");
      bracketShow = true;
    }
  });
  addEventArray(eventType.KEYUP, (e) => {
    if (e.key === "t") {
      const bracketElem = document.querySelector("#Bracket");
      if (!bracketElem || !bracketShow)
        return;
      bracketElem.removeAttribute("class");
      bracketShow = false;
    }
  });
  addEventHandler();
  const drawBracket = (canvas2, p_width) => {
    const ctx2 = canvas2.getContext("2d");
    canvas2.width = p_width;
    canvas2.height = 400;
    ctx2.strokeStyle = "white";
    ctx2.lineWidth = 2;
    const basex = window.innerWidth / 2 - 350;
    const basey = -50;
    const positions2 = [
      { x: basex + 50, y: basey + 350 },
      { x: basex + 250, y: basey + 350 },
      { x: basex + 450, y: basey + 350 },
      { x: basex + 650, y: basey + 350 },
      { x: basex + 150, y: basey + 200 },
      { x: basex + 550, y: basey + 200 },
      { x: basex + 350, y: basey + 80 }
    ];
    for (let i = 0; i < 7; i++) {
      drawBorder(ctx2, users2.users[i], positions2[i]);
    }
    ctx2.textAlign = "center";
    ctx2.beginPath();
    ctx2.moveTo(basex + 50, basey + 350);
    ctx2.lineTo(basex + 50, basey + 275);
    ctx2.lineTo(basex + 250, basey + 275);
    ctx2.lineTo(basex + 250, basey + 350);
    ctx2.moveTo(basex + 150, basey + 275);
    ctx2.lineTo(basex + 150, basey + 240);
    ctx2.stroke();
    ctx2.beginPath();
    ctx2.moveTo(basex + 450, basey + 350);
    ctx2.lineTo(basex + 450, basey + 275);
    ctx2.lineTo(basex + 650, basey + 275);
    ctx2.lineTo(basex + 650, basey + 350);
    ctx2.moveTo(basex + 550, basey + 275);
    ctx2.lineTo(basex + 550, basey + 240);
    ctx2.stroke();
    ctx2.beginPath();
    ctx2.moveTo(basex + 150, basey + 200);
    ctx2.lineTo(basex + 150, basey + 150);
    ctx2.lineTo(basex + 550, basey + 150);
    ctx2.lineTo(basex + 550, basey + 200);
    ctx2.stroke();
    ctx2.beginPath();
    ctx2.moveTo(basex + 350, basey + 150);
    ctx2.lineTo(basex + 350, basey + 120);
    ctx2.stroke();
  };
  useEffect(() => {
    const canvas2 = document.getElementById("Bracket");
    drawBracket(canvas2, window.innerWidth);
  }, [users2]);
  return /* @__PURE__ */ h("canvas", { id: "Bracket" });
};
let role$1;
let match$1;
let users$1;
const update$3 = () => {
  draw$3();
};
const dirStat$3 = {
  STOP: 0,
  UP: 1,
  DOWN: 2
};
const GamePage$1 = () => {
  const [gameStat, setGameStat] = useState([]);
  const [userStat, setUserStat] = useState([]);
  const [gameResult, setGameResult] = useState(null);
  let direction = dirStat$3.STOP;
  let startFlag = false;
  useEffect(() => {
    const socketAsync = async () => {
      connectGameLogicWebSocket(
        ws_gamelogic.dispatch,
        `/ws/tournament/${history.currentPath().split("/")[2]}/`
      );
      ws_gamelogic.getState().socket.onopen = (e) => {
        const waitOpponent = async () => {
          await new Promise((resolve2) => setTimeout(resolve2, 1e4));
          if (!startFlag) {
            ws_gamelogic.getState().socket.send(
              JSON.stringify({ type: "error", message: "timeout" })
            );
          }
        };
        waitOpponent();
      };
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "game_start") {
          startFlag = true;
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.roles]);
          users$1 = [
            data2.match_a_player[0],
            data2.match_a_player[1],
            data2.match_b_player[0],
            data2.match_b_player[1],
            "tbd",
            "tbd",
            "tbd"
          ];
          setUserStat(users$1);
          role$1 = data2.role;
          match$1 = data2.match;
          let timer = 3;
          let interval = setInterval(() => {
            timer--;
            const counter = document.querySelector(".pong-game-info h1");
            if (counter) {
              counter.innerText = timer;
              if (timer <= 0) {
                counter.style.display = "none";
                clearInterval(interval);
                ws_gamelogic.getState().socket.send(
                  JSON.stringify({
                    type: "start_game",
                    role: role$1,
                    match: match$1
                  })
                );
              }
            } else {
              timer++;
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventArray(eventType.KEYDOWN, (e2) => {
            if (e2.key === "ArrowUp" || e2.key === "ArrowDown") {
              direction = e2.key === "ArrowUp" ? dirStat$3.UP : dirStat$3.DOWN;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "move_bar",
                  direction: direction === dirStat$3.UP ? "up" : "down",
                  role: role$1,
                  match: match$1
                })
              );
            }
          });
          addEventArray(eventType.KEYUP, (e2) => {
            if (direction !== dirStat$3.STOP && (e2.key === "ArrowUp" && direction === dirStat$3.UP || e2.key === "ArrowDown" && direction === dirStat$3.DOWN)) {
              direction = dirStat$3.STOP;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "stop_bar",
                  role: role$1,
                  match: match$1
                })
              );
            }
          });
          addEventHandler();
        } else if (data2.type === "update_game") {
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.roles]);
        } else if (data2.type === "game_over") {
          const newUsers = [...users$1];
          if (data2.match === "f") {
            for (let i = 0; i < 7; i++) {
              if (newUsers[i] === data2.winner) {
                newUsers[6] = data2.winner;
                newUsers[i] = "";
                break;
              }
            }
            users$1 = newUsers;
            setUserStat(newUsers);
            if (clientUserStore.getState().client.username === data2.winner) {
              setGameResult(1);
            } else {
              setGameResult(2);
            }
            setTimeout(() => {
              gotoPage(`/lobby/${data2.room_id}`);
            }, 5e3);
          } else {
            if (data2.winner === data2.you) {
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "final_ready"
                })
              );
            }
            if (data2.match === "a") {
              const newUsers2 = [...users$1];
              for (let i = 0; i < 7; i++) {
                if (newUsers2[i] === data2.winner) {
                  newUsers2[4] = data2.winner;
                  newUsers2[i] = "";
                  break;
                }
              }
              users$1 = newUsers2;
              setUserStat(newUsers2);
            } else {
              const newUsers2 = [...users$1];
              for (let i = 0; i < 7; i++) {
                if (newUsers2[i] === data2.winner) {
                  newUsers2[5] = data2.winner;
                  newUsers2[i] = "";
                  break;
                }
              }
              users$1 = newUsers2;
              setUserStat(newUsers2);
            }
          }
        } else if (data2.type === "error") {
          alert(data2.message);
          gotoPage("/lobby");
        } else if (data2.type === "final_game_start") {
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.roles]);
          role$1 = data2.role;
          match$1 = data2.match;
          let timer = 3;
          const counter = document.querySelector(".pong-game-info h1");
          counter.innerText = timer;
          counter.style.display = "inline";
          let interval = setInterval(() => {
            timer--;
            counter.innerText = timer;
            if (timer <= 0) {
              counter.style.display = "none";
              clearInterval(interval);
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "start_final_game",
                  role: role$1,
                  match: match$1
                })
              );
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventHandler();
        }
      };
    };
    socketAsync();
  }, []);
  useEffect(() => {
    if (isEmpty(gameStat))
      return;
    document.getElementById("pong-game").style.display = "block";
    let windowH = window.innerHeight;
    if (windowH / 3 > window.innerWidth / 4) {
      setCanvas(
        document.getElementById("pong-game"),
        window.innerWidth - 10,
        window.innerWidth * 3 / 4 - 10
      );
    } else {
      setCanvas(
        document.getElementById("pong-game"),
        windowH * 4 / 3 - 10,
        windowH.innerHeight - 10
      );
    }
    document.querySelector(
      ".pong-game-info > p.user1"
    ).style.left = `calc(52% - ${canvas$4.width / 2}px)`;
    document.querySelector(
      ".pong-game-info > p.user2"
    ).style.right = `calc(52% - ${canvas$4.width / 2}px)`;
    setRatio(canvas$4.width / 1200);
    update$3();
  }, [gameStat, userStat]);
  return /* @__PURE__ */ h("div", { class: "game-display" }, /* @__PURE__ */ h("div", { class: "tournament" }, /* @__PURE__ */ h(Bracket, { users: userStat }), /* @__PURE__ */ h("div", { class: "pong-game-main" }, /* @__PURE__ */ h("canvas", { id: "pong-game" }), isEmpty(gameStat) ? null : /* @__PURE__ */ h("div", { class: "pong-game-info" }, /* @__PURE__ */ h("p", { class: "user1" }, gameStat[1].left), /* @__PURE__ */ h("p", { class: "user2" }, gameStat[1].right), /* @__PURE__ */ h("h6", { class: "user1" }, gameStat[0].left), /* @__PURE__ */ h("h6", { class: "user2" }, gameStat[0].right), /* @__PURE__ */ h("h1", null, "3")))), gameResult == 1 ? /* @__PURE__ */ h(WinMessage, null) : gameResult == 2 ? /* @__PURE__ */ h(LoseMessage, null) : /* @__PURE__ */ h("div", null));
};
let gameState$1;
let canvas$1;
let context$1;
let ratio$1;
let role;
let match;
let users;
const drawPaddle$1 = (x, y, bar_size) => {
  context$1.fillStyle = "red";
  context$1.fillRect(x * ratio$1, y * ratio$1, 20 * ratio$1, canvas$1.height / bar_size);
};
const drawBall$1 = (x, y) => {
  context$1.fillStyle = "#ffffff";
  context$1.beginPath();
  context$1.arc(
    gameState$1.ball.x * ratio$1,
    gameState$1.ball.y * ratio$1,
    gameState$1.ball.radius * ratio$1,
    0,
    Math.PI * 2
  );
  context$1.fill();
  context$1.closePath();
};
const drawLine$1 = () => {
  context$1.beginPath();
  context$1.moveTo(canvas$1.width / 2, 0);
  context$1.lineTo(canvas$1.width / 2, canvas$1.height);
  context$1.strokeStyle = "#ffffff";
  context$1.lineWidth = 2;
  context$1.stroke();
  context$1.closePath();
};
var img1$1 = new Image();
var img2$1 = new Image();
var img3$1 = new Image();
var img4$1 = new Image();
img1$1.src = "/icon/ball_speed_up.svg";
img2$1.src = "/icon/ball_speed_down.svg";
img3$1.src = "/icon/expand_arrow.svg";
img4$1.src = "/icon/reduct_arrow.svg";
var imgs$1 = { speed_up: img1$1, speed_down: img2$1, bar_up: img3$1, bar_down: img4$1 };
const drawItems$1 = (items) => {
  items.forEach((item) => {
    switch (item.type) {
      case "speed_up":
        context$1.fillStyle = "rgba(255, 0, 0, 0.75)";
        break;
      case "speed_down":
        context$1.fillStyle = "rgba(0, 0, 255, 0.75)";
        break;
      case "bar_up":
        context$1.fillStyle = "rgba(255, 0, 255, 0.75)";
        break;
      case "bar_down":
        context$1.fillStyle = "rgba(255, 165, 0, 0.75)";
        break;
      default:
        context$1.fillStyle = "white";
    }
    context$1.fillRect(
      item.x * ratio$1 - 25 * ratio$1,
      item.y * ratio$1 - 25 * ratio$1,
      50 * ratio$1,
      50 * ratio$1
    );
    context$1.drawImage(
      imgs$1[item.type],
      item.x * ratio$1 - 25 * ratio$1,
      item.y * ratio$1 - 25 * ratio$1,
      50 * ratio$1,
      50 * ratio$1
    );
  });
};
const draw$1 = () => {
  context$1.clearRect(0, 0, canvas$1.width, canvas$1.height);
  context$1.fillStyle = "#181818";
  context$1.fillRect(0, 0, canvas$1.width, canvas$1.height);
  context$1.fillStyle = "#ffffff";
  drawPaddle$1(20, gameState$1.player_bar.left, gameState$1.bar_size.left);
  drawPaddle$1(1160, gameState$1.player_bar.right, gameState$1.bar_size.right);
  drawBall$1(gameState$1.ball.x, gameState$1.ball.y);
  drawItems$1(gameState$1.items);
  drawLine$1();
};
const update$2 = () => {
  draw$1();
};
const dirStat$2 = {
  STOP: 0,
  UP: 1,
  DOWN: 2
};
const GamePage = () => {
  const [gameStat, setGameStat] = useState([]);
  const [userStat, setUserStat] = useState([]);
  const [gameResult, setGameResult] = useState(null);
  let direction = dirStat$2.STOP;
  let startFlag = false;
  useEffect(() => {
    const socketAsync = async () => {
      connectGameLogicWebSocket(
        ws_gamelogic.dispatch,
        `/ws/custom-tournament/${history.currentPath().split("/")[2]}/`
      );
      ws_gamelogic.getState().socket.onopen = (e) => {
        const waitOpponent = async () => {
          await new Promise((resolve2) => setTimeout(resolve2, 1e4));
          if (!startFlag) {
            ws_gamelogic.getState().socket.send(
              JSON.stringify({ type: "error", message: "timeout" })
            );
          }
        };
        waitOpponent();
      };
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "game_start") {
          startFlag = true;
          gameState$1 = data2.game;
          setGameStat([data2.game.scores, data2.roles]);
          users = [
            data2.match_a_player[0],
            data2.match_a_player[1],
            data2.match_b_player[0],
            data2.match_b_player[1],
            "tbd",
            "tbd",
            "tbd"
          ];
          setUserStat(users);
          role = data2.role;
          match = data2.match;
          let timer = 3;
          let interval = setInterval(() => {
            timer--;
            const counter = document.querySelector(".pong-game-info h1");
            if (counter) {
              counter.innerText = timer;
              if (timer <= 0) {
                counter.style.display = "none";
                clearInterval(interval);
                ws_gamelogic.getState().socket.send(
                  JSON.stringify({
                    type: "start_game",
                    role,
                    match
                  })
                );
              }
            } else {
              timer++;
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventArray(eventType.KEYDOWN, (e2) => {
            if (e2.key === "ArrowUp" || e2.key === "ArrowDown") {
              direction = e2.key === "ArrowUp" ? dirStat$2.UP : dirStat$2.DOWN;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "move_bar",
                  direction: direction === dirStat$2.UP ? "up" : "down",
                  role,
                  match
                })
              );
            }
          });
          addEventArray(eventType.KEYUP, (e2) => {
            if (direction !== dirStat$2.STOP && (e2.key === "ArrowUp" && direction === dirStat$2.UP || e2.key === "ArrowDown" && direction === dirStat$2.DOWN)) {
              direction = dirStat$2.STOP;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "stop_bar",
                  role,
                  match
                })
              );
            }
          });
          addEventHandler();
        } else if (data2.type === "update_game") {
          gameState$1 = data2.game;
          setGameStat([data2.game.scores, data2.roles]);
        } else if (data2.type === "game_over") {
          const newUsers = [...users];
          if (data2.match === "f") {
            for (let i = 0; i < 7; i++) {
              if (newUsers[i] === data2.winner) {
                newUsers[6] = data2.winner;
                newUsers[i] = "";
                break;
              }
            }
            users = newUsers;
            setUserStat(newUsers);
            if (clientUserStore.getState().client.username === data2.winner) {
              setGameResult(1);
            } else {
              setGameResult(2);
            }
            setTimeout(() => {
              gotoPage(`/lobby/${data2.room_id}`);
            }, 5e3);
          } else {
            if (data2.winner === data2.you) {
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "final_ready"
                })
              );
            }
            if (data2.match === "a") {
              const newUsers2 = [...users];
              for (let i = 0; i < 7; i++) {
                if (newUsers2[i] === data2.winner) {
                  newUsers2[4] = data2.winner;
                  newUsers2[i] = "";
                  break;
                }
              }
              users = newUsers2;
              setUserStat(newUsers2);
            } else {
              const newUsers2 = [...users];
              for (let i = 0; i < 7; i++) {
                if (newUsers2[i] === data2.winner) {
                  newUsers2[5] = data2.winner;
                  newUsers2[i] = "";
                  break;
                }
              }
              users = newUsers2;
              setUserStat(newUsers2);
            }
          }
        } else if (data2.type === "error") {
          alert(data2.message);
          gotoPage("/lobby");
        } else if (data2.type === "final_game_start") {
          gameState$1 = data2.game;
          setGameStat([data2.game.scores, data2.roles]);
          role = data2.role;
          match = data2.match;
          let timer = 3;
          const counter = document.querySelector(".pong-game-info h1");
          counter.innerText = timer;
          counter.style.display = "inline";
          let interval = setInterval(() => {
            timer--;
            counter.innerText = timer;
            if (timer <= 0) {
              counter.style.display = "none";
              clearInterval(interval);
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "start_final_game",
                  role,
                  match
                })
              );
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventHandler();
        }
      };
    };
    socketAsync();
  }, []);
  useEffect(() => {
    if (isEmpty(gameStat))
      return;
    document.getElementById("pong-game").style.display = "block";
    canvas$1 = document.getElementById("pong-game");
    let windowH = window.innerHeight;
    if (windowH / 3 > window.innerWidth / 4) {
      canvas$1.width = window.innerWidth - 10;
      canvas$1.height = window.innerWidth * 3 / 4 - 10;
    } else {
      canvas$1.height = windowH - 10;
      canvas$1.width = windowH * 4 / 3 - 10;
    }
    context$1 = canvas$1.getContext("2d");
    context$1.scale(1, 1);
    document.querySelector(
      ".pong-game-info > p.user1"
    ).style.left = `calc(52% - ${canvas$1.width / 2}px)`;
    document.querySelector(
      ".pong-game-info > p.user2"
    ).style.right = `calc(52% - ${canvas$1.width / 2}px)`;
    ratio$1 = canvas$1.width / 1200;
    update$2();
  }, [gameStat, userStat]);
  return /* @__PURE__ */ h("div", { class: "game-display" }, /* @__PURE__ */ h("div", { class: "tournament" }, /* @__PURE__ */ h(Bracket, { users: userStat }), /* @__PURE__ */ h("div", { class: "pong-game-main" }, /* @__PURE__ */ h("canvas", { id: "pong-game" }), isEmpty(gameStat) ? null : /* @__PURE__ */ h("div", { class: "pong-game-info" }, /* @__PURE__ */ h("p", { class: "user1" }, gameStat[1].left), /* @__PURE__ */ h("p", { class: "user2" }, gameStat[1].right), /* @__PURE__ */ h("h6", { class: "user1" }, gameStat[0].left), /* @__PURE__ */ h("h6", { class: "user2" }, gameStat[0].right), /* @__PURE__ */ h("h1", null, "3")))), gameResult == 1 ? /* @__PURE__ */ h(WinMessage, null) : gameResult == 2 ? /* @__PURE__ */ h(LoseMessage, null) : /* @__PURE__ */ h("div", null));
};
let gameState;
let canvas;
let context;
let ratio;
const drawPaddle = (x, y, bar_size) => {
  context.fillStyle = "red";
  context.fillRect(x * ratio, y * ratio, 20 * ratio, canvas.height / bar_size);
};
const drawBall = (x, y) => {
  context.fillStyle = "blue";
  context.beginPath();
  context.arc(
    gameState.ball.x * ratio,
    gameState.ball.y * ratio,
    gameState.ball.radius * ratio,
    0,
    Math.PI * 2
  );
  context.fill();
  context.closePath();
};
var img1 = new Image();
var img2 = new Image();
var img3 = new Image();
var img4 = new Image();
img1.src = "/icon/ball_speed_up.svg";
img2.src = "/icon/ball_speed_down.svg";
img3.src = "/icon/expand_arrow.svg";
img4.src = "/icon/reduct_arrow.svg";
var imgs = { speed_up: img1, speed_down: img2, bar_up: img3, bar_down: img4 };
const drawItems = (items) => {
  items.forEach((item) => {
    switch (item.type) {
      case "speed_up":
        context.fillStyle = "rgba(255, 0, 0, 0.75)";
        break;
      case "speed_down":
        context.fillStyle = "rgba(0, 0, 255, 0.75)";
        break;
      case "bar_up":
        context.fillStyle = "rgba(255, 0, 255, 0.75)";
        break;
      case "bar_down":
        context.fillStyle = "rgba(255, 165, 0, 0.75)";
        break;
      default:
        context.fillStyle = "white";
    }
    context.fillRect(
      item.x * ratio - 25 * ratio,
      item.y * ratio - 25 * ratio,
      50 * ratio,
      50 * ratio
    );
    context.drawImage(
      imgs[item.type],
      item.x * ratio - 25 * ratio,
      item.y * ratio - 25 * ratio,
      50 * ratio,
      50 * ratio
    );
  });
};
const drawLine = () => {
  context.beginPath();
  context.moveTo(canvas.width / 2, 0);
  context.lineTo(canvas.width / 2, canvas.height);
  context.strokeStyle = "#ffffff";
  context.lineWidth = 2;
  context.stroke();
  context.closePath();
};
const draw = () => {
  context.fillStyle = "#181818";
  context.fillRect(0, 0, canvas.width, canvas.height);
  context.fillStyle = "#ffffff";
  drawPaddle(20, gameState.player_bar.left, gameState.bar_size.left);
  drawPaddle(1160, gameState.player_bar.right, gameState.bar_size.right);
  drawBall(gameState.ball.x, gameState.ball.y);
  drawItems(gameState.items);
  drawLine();
};
const update$1 = () => {
  draw();
};
const dirStat$1 = {
  STOP: 0,
  UP: 1,
  DOWN: 2
};
const CustumGamePage = () => {
  const [gameStat, setGameStat] = useState([]);
  const [gameResult, setGameResult] = useState(null);
  let direction = dirStat$1.STOP;
  let startFlag = false;
  useEffect(() => {
    const socketAsync = async () => {
      connectGameLogicWebSocket(
        ws_gamelogic.dispatch,
        `/ws/custom/${history.currentPath().split("/")[2]}/`
      );
      ws_gamelogic.getState().socket.onopen = (e) => {
        const waitOpponent = async () => {
          await new Promise((resolve2) => setTimeout(resolve2, 1e4));
          if (!startFlag) {
            ws_gamelogic.getState().socket.send(
              JSON.stringify({ type: "error", message: "timeout" })
            );
          }
        };
        waitOpponent();
      };
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "game_start") {
          startFlag = true;
          gameState = data2.game;
          setGameStat([data2.game.scores, data2.game.roles]);
          let timer = 3;
          let interval = setInterval(() => {
            timer--;
            const counter = document.querySelector(".pong-game-info h1");
            counter.innerText = timer;
            if (timer <= 0) {
              counter.style.display = "none";
              clearInterval(interval);
              ws_gamelogic.getState().socket.send(JSON.stringify({ type: "start_game" }));
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventArray(eventType.KEYDOWN, (e2) => {
            if (e2.key === "ArrowUp" || e2.key === "ArrowDown") {
              direction = e2.key === "ArrowUp" ? dirStat$1.UP : dirStat$1.DOWN;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "move_bar",
                  direction: direction === dirStat$1.UP ? "up" : "down",
                  role: data2.you
                })
              );
            }
          });
          addEventArray(eventType.KEYUP, (e2) => {
            if (direction !== dirStat$1.STOP && (e2.key === "ArrowUp" && direction === dirStat$1.UP || e2.key === "ArrowDown" && direction === dirStat$1.DOWN)) {
              direction = dirStat$1.STOP;
              ws_gamelogic.getState().socket.send(
                JSON.stringify({
                  type: "stop_bar",
                  role: data2.you
                })
              );
            }
          });
          addEventHandler();
        } else if (data2.type === "update_game") {
          gameState = data2.game;
          setGameStat([data2.game.scores, data2.game.roles]);
        } else if (data2.type === "game_over") {
          if (clientUserStore.getState().client.username === data2.winner) {
            setGameResult(1);
          } else {
            setGameResult(2);
          }
          setTimeout(() => {
            gotoPage(`/lobby/${data2.room_id}`);
          }, 5e3);
        } else if (data2.type === "error") {
          alert(data2.message);
          gotoPage("/lobby");
        }
      };
    };
    socketAsync();
  }, []);
  useEffect(() => {
    if (isEmpty(gameStat))
      return;
    document.getElementById("pong-game").style.display = "block";
    canvas = document.getElementById("pong-game");
    if (window.innerHeight / 3 > window.innerWidth / 4) {
      canvas.width = window.innerWidth - 10;
      canvas.height = window.innerWidth * 3 / 4 - 10;
    } else {
      canvas.height = window.innerHeight - 10;
      canvas.width = window.innerHeight * 4 / 3 - 10;
    }
    context = canvas.getContext("2d");
    context.scale(1, 1);
    document.querySelector(
      ".pong-game-info > p.user1"
    ).style.left = `calc(52% - ${canvas.width / 2}px)`;
    document.querySelector(
      ".pong-game-info > p.user2"
    ).style.right = `calc(52% - ${canvas.width / 2}px)`;
    ratio = canvas.width / 1200;
    update$1();
  }, [gameStat]);
  return /* @__PURE__ */ h("div", { class: "game-display" }, /* @__PURE__ */ h("div", { class: "pong-game-main" }, /* @__PURE__ */ h("canvas", { id: "pong-game" }), isEmpty(gameStat) ? null : /* @__PURE__ */ h("div", { class: "pong-game-info" }, /* @__PURE__ */ h("p", { class: "user1" }, gameStat[1].left), /* @__PURE__ */ h("p", { class: "user2" }, gameStat[1].right), /* @__PURE__ */ h("h6", { class: "user1" }, gameStat[0].left), /* @__PURE__ */ h("h6", { class: "user2" }, gameStat[0].right), /* @__PURE__ */ h("h1", null, "3"))), gameResult == 1 ? /* @__PURE__ */ h(WinMessage, null) : gameResult == 2 ? /* @__PURE__ */ h(LoseMessage, null) : /* @__PURE__ */ h("div", null));
};
const update = () => {
  draw$3();
};
const dirStat = {
  STOP: 0,
  UP: 1,
  DOWN: 2
};
const LocalGamePage = () => {
  const [gameStat, setGameStat] = useState([]);
  const [gameResult, setGameResult] = useState("");
  let directionRight = dirStat.STOP;
  let directionLeft = dirStat.STOP;
  let startFlag = false;
  const handleKeyDown = (e) => {
    if (e.key === "ArrowUp" || e.key === "ArrowDown") {
      directionRight = e.key === "ArrowUp" ? dirStat.UP : dirStat.DOWN;
      ws_gamelogic.getState().socket.send(
        JSON.stringify({
          type: "move_bar",
          direction: directionRight === dirStat.UP ? "up" : "down",
          role: "right"
        })
      );
    }
    if (e.key === "w" || e.key === "s") {
      directionLeft = e.key === "w" ? dirStat.UP : dirStat.DOWN;
      ws_gamelogic.getState().socket.send(
        JSON.stringify({
          type: "move_bar",
          direction: directionLeft === dirStat.UP ? "up" : "down",
          role: "left"
        })
      );
    }
  };
  const handleKeyUp = (e) => {
    if (e.key === "ArrowUp" || e.key === "ArrowDown") {
      directionRight = dirStat.STOP;
      ws_gamelogic.getState().socket.send(
        JSON.stringify({
          type: "move_bar",
          direction: "stop",
          role: "right"
        })
      );
    }
    if (e.key === "w" || e.key === "s") {
      directionLeft = dirStat.STOP;
      ws_gamelogic.getState().socket.send(
        JSON.stringify({
          type: "move_bar",
          direction: "stop",
          role: "left"
        })
      );
    }
  };
  useEffect(() => {
    const socketAsync = async () => {
      connectGameLogicWebSocket(
        ws_gamelogic.dispatch,
        `/ws/localgame/${history.currentPath().split("/")[2]}/`
      );
      ws_gamelogic.getState().socket.onopen = (e) => {
        const waitOpponent = async () => {
          await new Promise((resolve2) => setTimeout(resolve2, 1e4));
          if (!startFlag) {
            ws_gamelogic.getState().socket.send(
              JSON.stringify({ type: "error", message: "timeout" })
            );
          }
        };
        waitOpponent();
      };
      ws_gamelogic.getState().socket.onmessage = (e) => {
        const data2 = JSON.parse(e.data);
        if (data2.type === "game_start") {
          startFlag = true;
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.game.roles]);
          let timer = 3;
          let interval = setInterval(() => {
            timer--;
            const counter = document.querySelector(".pong-game-info h1");
            if (counter) {
              counter.innerText = timer;
              if (timer <= 0) {
                counter.style.display = "none";
                clearInterval(interval);
                ws_gamelogic.getState().socket.send(JSON.stringify({ type: "start_game" }));
              }
            } else {
              timer++;
              clearInterval(interval);
            }
          }, 1e3);
          addEventArray(eventType.BEFOREUNLOAD, () => {
            clearInterval(interval);
          });
          addEventArray(eventType.KEYDOWN, handleKeyDown);
          addEventArray(eventType.KEYUP, handleKeyUp);
          addEventHandler();
        } else if (data2.type === "update_game") {
          setGameState(data2.game);
          setGameStat([data2.game.scores, data2.game.roles]);
        } else if (data2.type === "game_over") {
          setGameResult(data2.winner);
          setTimeout(() => {
            gotoPage(`/lobby`);
          }, 5e3);
        } else if (data2.type === "error") {
          alert(data2.message);
          gotoPage("/lobby");
        }
      };
    };
    socketAsync();
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, []);
  useEffect(() => {
    if (isEmpty(gameStat))
      return;
    document.getElementById("pong-game").style.display = "block";
    if (window.innerHeight / 3 > window.innerWidth / 4) {
      setCanvas(
        document.getElementById("pong-game"),
        window.innerWidth - 10,
        window.innerWidth * 3 / 4 - 10
      );
    } else {
      setCanvas(
        document.getElementById("pong-game"),
        window.innerHeight * 4 / 3 - 10,
        window.innerHeight - 10
      );
    }
    document.querySelector(
      ".pong-game-info > p.user1"
    ).style.left = `calc(52% - ${canvas$4.width / 2}px)`;
    document.querySelector(
      ".pong-game-info > p.user2"
    ).style.right = `calc(52% - ${canvas$4.width / 2}px)`;
    setRatio(canvas$4.width / 1200);
    update();
  }, [gameStat]);
  return /* @__PURE__ */ h("div", { class: "game-display" }, /* @__PURE__ */ h("div", { class: "pong-game-main" }, /* @__PURE__ */ h("canvas", { id: "pong-game" }), isEmpty(gameStat) ? null : /* @__PURE__ */ h("div", { class: "pong-game-info" }, /* @__PURE__ */ h("p", { class: "user1" }, gameStat[1].left), /* @__PURE__ */ h("p", { class: "user2" }, gameStat[1].right), /* @__PURE__ */ h("h6", { class: "user1" }, gameStat[0].left), /* @__PURE__ */ h("h6", { class: "user2" }, gameStat[0].right), /* @__PURE__ */ h("h1", null, "3"))), gameResult === "" ? /* @__PURE__ */ h("div", null) : resultMessage(gameResult));
};
const TestPage = () => {
  useState(0);
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h(LoseMessage, null));
};
const routes = [
  {
    path: "/",
    element: MainPage,
    errorElement: NotFoundPage,
    children: [
      {
        path: "2fa",
        element: TwoFactorAuthPage,
        children: []
      },
      {
        path: "lobby",
        element: LobbyPage,
        children: [
          {
            path: ":id",
            element: RoomPage
          }
        ]
      },
      {
        path: "profile",
        children: [
          {
            path: "me",
            element: ProfilePage,
            children: [
              {
                path: "config",
                element: ProfileConfigPage
              }
            ]
          },
          {
            path: ":id",
            element: ProfilePage
          }
        ]
      },
      {
        path: "game",
        children: [
          {
            path: ":id",
            element: GamePage$2
          }
        ]
      },
      {
        path: "test",
        element: TestPage
      },
      {
        path: "tournament",
        children: [
          {
            path: ":id",
            element: GamePage$1
          }
        ]
      },
      {
        path: "custom",
        children: [
          {
            path: ":id",
            element: CustumGamePage
          }
        ]
      },
      {
        path: "customTournament",
        children: [
          {
            path: ":id",
            element: GamePage
          }
        ]
      },
      {
        path: "local",
        children: [
          {
            path: ":id",
            element: LocalGamePage
          }
        ]
      }
    ]
  }
];
const app = document.getElementById("app");
router(app, routes);
